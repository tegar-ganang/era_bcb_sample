package com.worldware.ichabod.node;

import java.util.Vector;
import java.util.Date;
import java.util.Enumeration;
import java.io.File;
import java.security.*;
import com.listsite.*;
import com.listsite.store.*;
import com.listsite.store.id.*;
import com.worldware.ichabod.*;
import com.worldware.mail.pop3.*;
import com.worldware.mail.*;
import com.worldware.ichabod.webui.*;
import com.worldware.misc.*;
import com.worldware.ichabod.store.*;

/** There are four ways to access a child descendend from type DataNode
  *		getChildByName		- does not create or load the child, returns the child only if in the currently loaded childList. Handles aliases
  *		getChildFromList	- does not create or load the child, returns the child only if in the currently loaded childList. Ignores aliases
  *     loadChild			- does not create. Returns a value from the list if found, else loads the child from the disk
  *		createChild			- creates a new child node.
  * Also:
  * each child should implement a _static_ load function. This fuction should verify that a load is
  * possible, before calling the constructor for its type.
  */
public abstract class DataNode implements IHasListener, ITickable, DataNodeKeys {

    /** Name of this object. Must be unique among its siblings. 
	  * That is, no two children of the same parent may have the same name.
	  */
    private String m_name;

    /** List of listeners to notify when this object changes. 
	  */
    private Vector m_listeners = new Vector();

    /** Name of configuration file used by instances of this class 
	  */
    private static String infoFileName = "info.dat";

    /** The directory where the info file is stored */
    private File m_baseDirFile;

    /** The parent object of this object. This is null for the top level node. 
	  */
    private DataNode m_parent;

    /** The web user interface object for this node.
	  */
    WebUI m_webUI = null;

    /** Controls display of debugging messages. */
    public boolean m_debugEnabled = false;

    /** List of children that have already been loaded. The idea is to prevent
	  * multple objects from being created to represent the same user.
	  */
    Vector childList = new Vector();

    /** Property file where all static info about the class is stored.
	  */
    private IPropertyBundle m_propertyBundle;

    /**
	  * default password for newly created accounts.
	  * Having it in one place makes it easier for the automated testing
	  * to work.<P>
	  * Public so test code can know the password of newly created accounts
	  */
    public static final String defaultPassword = "newpass";

    /** The address this node will use for any 'errorsto' header generated by this node.
	  * may be null, in which case the parent's address is usually used.
	  * @see #getErrorsAddress
	  * @see #getErrorsAddressLocal
	  */
    private String errorsAddress = null;

    static Class m_UIClass = null;

    /** Used as a reply from delete. Delete succeeded */
    public static final int DEL_OK = 1;

    /** Used as a reply from delete. Delete failed, the user still has messages */
    public static final int DEL_NOT_EMPTY = 2;

    /** Used as a reply from delete. Delete failed, someone is referencing it */
    public static final int DEL_IN_USE = 3;

    /** Used as a reply from delete. Delete failed, generic failure */
    public static final int DEL_FAILED = 4;

    /** Vector of externally settable properties */
    public Vector m_externalProperties = new Vector();

    /** This version maps directly to the childs constructor, in each derived class
	  * Note: loadAllChildren does the notification, loadChild does not. At least for now.
	  * That way the kid is attached (on childList) before the notification is sent
	  * Attaching is done in loadAllChildren.
	  * we might want to change this, as children are created through other methods
	  * than load all children.
	  * @see #loadAllChildren
	  */
    abstract DataNode loadChild(String hostName, File hostDir) throws DataNodeException;

    /** Creates a new child. This version  is overridden in most child
	  * classes to create the correct type of child. The other version
	  * createChild(string) is usually not overridden.
	  */
    abstract DataNode createChild(String childName, File baseDir) throws DataNodeException;

    IStore m_store;

    MailRecipientID m_nodeID;

    /** Loads an existing DataNode from the persistant store.
	 * @param store Reference to the persistant store. (File/DB/etc)
	 * @param node Identifies the node to load. (e.g. record ID for DB, Dir for file store)
	 * @param parent The parent of this object. null for the router (root object)
	 */
    DataNode(IStore store, MailRecipientID node, DataNode parent) throws DataNodeException {
        m_store = store;
        m_nodeID = node;
        m_propertyBundle = (IPropertyBundle) store.getProperties(node);
        String nameFromPropFile = (String) m_propertyBundle.get(targetNameKey);
        setName(nameFromPropFile);
        m_parent = parent;
        String ea = getProperty(errorsToKey);
        if ((ea != null) && ea.length() != 0) setErrorsAddress(ea);
    }

    /** Creates a new DataNode
	 * @param store Reference to the persistant store. (File/DB/etc)
	 * @param nodeName The name of the new node
	 * @param parent The parent of this object. null for the router (root object)
	 */
    DataNode(IStore store, String nodeName, DataNode parent) throws DataNodeException, StoreException {
        m_store = store;
        m_nodeID = store.createNode(parent.getID(), nodeName);
        m_propertyBundle = store.getProperties(m_nodeID);
        m_propertyBundle.put(passwordKey, defaultPassword);
        m_propertyBundle.put(targetClassKey, this.getClass().getName());
        m_propertyBundle.put(targetNameKey, nodeName);
        m_parent = parent;
        setName(nodeName);
    }

    /** Loads an existing DataNode from the specified directory */
    public DataNode(File targetDir, String tentativeName, DataNode parent) throws DataNodeException {
        if (targetDir == null) throw new DataNodeException("DataNode: null targetDir parameter.");
        if (!targetDir.canRead()) throw new DataNodeException("DataNode: Can't read dir " + targetDir);
        File infoFile = getInfoFile(targetDir, true);
        if (infoFile == null) throw new DataNodeException("DataNode: No info file " + infoFile);
        common(tentativeName, targetDir, parent);
    }

    /** The constructor is used to load existing objects. If you need to create an object, call
	  * the static create method in the child class.
	  * @see #create
	  */
    DataNode(String name, File baseDirFile, DataNode parent) throws DataNodeException {
        common(name, baseDirFile, parent);
    }

    /** Code shared by the constructors. */
    private void common(String name, File baseDirFile, DataNode parent) throws DataNodeException {
        m_name = name;
        m_baseDirFile = baseDirFile;
        m_parent = parent;
        File infoFile = getInfoFile(false);
        if (infoFile.exists()) {
            m_propertyBundle = new PropertyFile(infoFile);
            String nameFromPropFile = m_propertyBundle.get(targetNameKey, getName());
            setName(nameFromPropFile);
        } else {
            m_propertyBundle = new PropertyFile(infoFile);
        }
        String ea = getProperty(errorsToKey);
        if ((ea != null) && ea.length() != 0) setErrorsAddress(ea);
        this.putProperty(targetClassKey, this.getClass().getName());
    }

    /** Checks to see if this item is using the specified address.
	  * 'Using' means this object expects that address to exist.
	  * add example would be a mailing list (TargetList) expects its
	  * moderators address to exist, therefore it is 'using' the
	  * moderators address
	  * returns null if no-one is using the address
	  * returns a reference to the object using it if one is found
	  * (i.e. may return 'this' or a reference to one of this' children
	  * This base class version just
	  */
    public DataNode usesAddress(String emailAddress, boolean recursive) {
        if (!recursive) return null;
        Enumeration current;
        DataNode child;
        DataNode user;
        if (emailAddress.equalsIgnoreCase(getErrorsAddress())) return this;
        for (current = childList.elements(); current.hasMoreElements(); ) {
            child = (DataNode) current.nextElement();
            user = child.usesAddress(emailAddress, recursive);
            if (null != user) return user;
        }
        return null;
    }

    /** Creates the property file for this object.
	  * creates targetDir if not found.
	  * Throws RuntimeExceptions if it fails.
	  */
    static void createInfoFile(File targetDir) {
        if (!targetDir.exists()) {
            if (!targetDir.mkdirs()) {
                throw new RuntimeException("Could not create directory for info file:" + targetDir.toString());
            }
        }
        File newFile = new File(targetDir, infoFileName);
        if (!PropertyFile.createFile(newFile)) throw new RuntimeException("Could not create info file " + newFile.toString());
        return;
    }

    /** Gets the parent DataNode for this DataNode. 
	  * Example: A user's parent is the host the user belongs to */
    public DataNode getParent() {
        return m_parent;
    }

    /** Gets the top level directory for this object */
    public File getBaseDir() {
        return m_baseDirFile;
    }

    /** Gets the name assigned to this object */
    public String getName() {
        return m_name;
    }

    /** Changes the name assigned to this object, and saves it to persistant storage
	  * @see #setName
	  */
    public void setNameSave(String newName) throws DataNodeException {
        setName(newName);
        putProperty(targetNameKey, m_name);
    }

    /** Sets the name assigned to this object. This is done during init, so it doesn't
	  * need to write it to disk (since we just loaded it), and it doesn't need to notify
	  * since this isn't a change, it is the initial load.
	  * It's also used by the view classes, but that needs to change.
	  * @see #setNameSave
	  */
    public void setName(String newName) throws DataNodeException {
        isNameOK(newName);
        if (m_name.equals(newName)) return;
        DataNode parent = getParent();
        if (parent != null) {
            DataNode existing = parent.getChildByName(newName);
            if (existing != null) throw new DataNodeException("That name is already in use by an object named '" + existing.getName() + "'. (It may be an alias)");
        }
        m_name = newName;
        notifyListeners(IViewNotify.OBJECT_CHANGED, newName);
    }

    /** Checks to see if the object responds to the given name.
	  * @returns true if the object has that name, or has an alias matching the name.
	  */
    boolean hasNameOf(String name) {
        return matches(name);
    }

    /** Checks to see if the name is this object's name */
    boolean matches(String name) {
        return m_name.equalsIgnoreCase(name);
    }

    /** Gets a File representing the info file for this source
	  * this version can be called by a static function 
	  */
    public static File getInfoFile(File infoDir, boolean checkRead) {
        if (infoDir == null) throw new IllegalArgumentException("Null directory in DataNode.getInfoFile");
        File infoFile = new File(infoDir, infoFileName);
        if (checkRead && !infoFile.canRead()) {
            Log.error("Can't read DataNode info file: " + infoFile);
            return null;
        }
        return infoFile;
    }

    /** Gets a File representing the info file for this source
	  */
    private File getInfoFile(boolean checkReadAccess) {
        return getInfoFile(getBaseDir(), checkReadAccess);
    }

    /** Finds all children of this node, and creates an object for each
	  * Listeners are notified if 'notify' is true;
	  * Note: loadAllChildren does the notification, loadChild does not. At least for now.
	  * That way the kid is attached (on childList) before the notification is sent
	  * Attaching is done in loadAllChildren.
	  * we might want to change this, as children are created through other methods
	  * than load all children.
	  */
    boolean loadAllChildren(boolean recursive) throws DataNodeException {
        childList = new Vector();
        File childDir = getBaseDir();
        if (childDir == null) return false;
        String[] list = childDir.list(new dirFilter());
        for (int h = 0; h < list.length; h++) {
            String childName = list[h];
            File newdir = getChildDir(childName, true);
            DataNode newChild = loadChild(list[h], newdir);
            if (newChild != null) {
                childList.addElement(newChild);
                notifyListeners(IViewNotify.CHILD_LOADED, newChild);
                if (recursive) newChild.loadAllChildren(true);
            } else Log.error("DataNode: Unable to load child " + childName + " from " + newdir);
        }
        return true;
    }

    /** Gets the directory for the specified child. Does not check for access, since
	  * it may be called by a routine that wants to know if it is ok to create the dir
	  * @see #getChildDir
	  */
    File getChildDirX(String child) {
        if (!getBaseDir().canRead()) {
            Log.error("Can't read base directory:  " + getBaseDir());
            return null;
        }
        File childDir = new File(getBaseDir(), child);
        return childDir;
    }

    /** Gets the directory for the specified child 
	  * @see #getChildDirX
	  */
    File getChildDir(String child, boolean checkAccess) {
        File childDir = getChildDirX(child);
        if (checkAccess && !childDir.canRead()) {
            Log.error("Can't read child directory:  " + childDir);
            return null;
        }
        return childDir;
    }

    /** Adds a 'Listener' to the list of classes to be notified when 
	  * this object changes.<P>
	  * This is obsolete, and not really used, although some code still
	  * references it. 
	  * @see #notifyListeners
	  * @see #removeListener
	  * @see #removeAllListeners
	  * @see IViewNotify
	  */
    public void addListener(IViewNotify clientView) {
        if (m_listeners.contains(clientView)) {
            throw new IllegalArgumentException("DataNode.addListener: duplicate listener.");
        }
        m_listeners.addElement(clientView);
    }

    /** Removes a listener from this object 
	  * @see #addListener
	  * @see #notifyListeners
	  * @see #removeAllListeners
	  * @see IViewNotify
	  */
    public boolean removeListener(IViewNotify clientView) {
        return m_listeners.removeElement(clientView);
    }

    /** Removes a listener from this object 
	  * @see #addListener
	  * @see #notifyListeners
	  * @see #removeAllListeners
	  * @see IViewNotify
	  */
    public void removeAllListeners() {
        m_listeners.removeAllElements();
    }

    /** Lets all listeners know that a change has occured with this object.
	  * @see #addListener
	  * @see #removeAllListeners
	  * @see #removeListener
	  * @see IViewNotify
	  */
    public void notifyListeners(int code, Object data) {
        IViewNotify ivn = null;
        for (Enumeration e = m_listeners.elements(); e.hasMoreElements(); ) {
            ivn = (IViewNotify) e.nextElement();
            ivn.notifyChange(code, this, data);
        }
    }

    /** This allows you to get a child by its main name, or
	  * by any alias it recognizes
	  */
    public DataNode getChildByName(String childName) {
        Enumeration current;
        DataNode child;
        Vector v = (Vector) childList.clone();
        for (current = v.elements(); current.hasMoreElements(); ) {
            child = (DataNode) current.nextElement();
            if (child.hasNameOf(childName)) return child;
        }
        return null;
    }

    /** Gets a DataNode object representing the child from the list of 
	  * children that are already loaded. Does not load or create DataNode.
	  * Only gets by the objects true name, not aliases.
	  * @see #getChildByName
	  */
    DataNode getChildFromList(String childName) {
        Enumeration current;
        DataNode child;
        for (current = childList.elements(); current.hasMoreElements(); ) {
            child = (DataNode) current.nextElement();
            if (child.matches(childName)) return child;
        }
        return null;
    }

    /** Deletes the given object from the list of children.
	  * does not delete if from disk, see delete()
	  */
    void deleteChildFromList(DataNode childToDelete) {
        if (!childList.removeElement(childToDelete)) throw new IllegalArgumentException("DataNode.deleteChildFromList: Object '" + childToDelete.toString() + "' is not a child of " + this.toString());
    }

    /** Returns a DataNode object representing the first child on the list, or null
	  */
    DataNode getFirstChildFromList() {
        if (childList.isEmpty()) return null;
        return (DataNode) childList.firstElement();
    }

    /** Gets the object that stores configuration info for this Target
	  * for now, this has to be a PropertyFile, but I hope to fix that soon
	  */
    IPropertyBundle getConfig() {
        return m_propertyBundle;
    }

    /** This method creates a unique filename to be used as 
	  * the directory for a user. Thisi s a first cut implementation.
	  * it is very inefficient.
	  * It does not create the directory, it just returns a name.
	  * ZZZ there are possible race conditions here.
	  */
    File getNewChildDir(File baseDir, String prefix) {
        File newUniqueFile = new File(baseDir, prefix);
        if (!newUniqueFile.exists()) return newUniqueFile;
        for (int i = 0; i < 9999; i++) {
            String tentative = prefix + i;
            newUniqueFile = new File(baseDir, tentative);
            if (!newUniqueFile.exists()) return newUniqueFile;
        }
        return null;
    }

    /** Creates a new directory to hold a child to be created
	  * This version is usually not overridden.
	  * The method createChild(String, File) is overridden in most child
	  * classes to create the correct type of child.
	  */
    File createChildDir(String childName) {
        File childDir = getNewChildDir(getBaseDir(), childName);
        if (childDir == null) return null;
        if (!childDir.exists()) childDir.mkdir();
        if (!childDir.exists()) {
            Log.error("DataNode: Unable to make directory " + childDir);
            return null;
        }
        return childDir;
    }

    /** Performs some validity checking on the name
	  * returns true if name is OK
	  * We need the static version for testing prior to creating an object (e.g. in TargetList.create())
	  * @see #isNameOK
	  */
    public static void staticIsNameOK(String childName) throws DataNodeException {
        if (childName.indexOf(' ') != -1) throw new DataNodeException("Illegal name, contains spaces: '" + childName + "'");
        if (childName.indexOf('@') != -1) throw new DataNodeException("Illegal name, contains @ sign: '" + childName + "'");
    }

    /** Performs some validity checking on the name
	  * returns true if name is OK
	  * Non-static version in case someone wants to override.
	  * @see #staticIsNameOK
	  */
    public void isNameOK(String childName) throws DataNodeException {
        staticIsNameOK(childName);
    }

    /** Creates a new child. 
	  * This version is usually not overridden.
	  * The method createChild(String, File) is overridden in most child
	  * classes to create the correct type of child.
	  */
    public DataNode createChild(String childName) throws DataNodeException {
        isNameOK(childName);
        DataNode dn = getChildByName(childName);
        if (dn != null) return null;
        File childDir = createChildDir(childName);
        if (childDir == null) return null;
        DataNode newChild = createChild(childName, childDir);
        if (newChild != null) childList.addElement(newChild);
        return newChild;
    }

    /** This method writes all of this DataNodes properties back to the disk. */
    boolean writeProperties() {
        return m_propertyBundle.write();
    }

    /** returns a list of all properties for this object */
    String[] getPropertyList() {
        int size = m_propertyBundle.size();
        Enumeration k = m_propertyBundle.keys();
        if (size == 0) return null;
        String[] list = new String[size];
        for (int i = 0; k.hasMoreElements(); i++) {
            list[i] = k.nextElement().toString();
        }
        return list;
    }

    /** returns the number of children of this object.
	  */
    public int getChildCount() {
        return childList.size();
    }

    /** returns the number of grand children of this object.
	  */
    public int getGrandChildCount() {
        Enumeration current;
        DataNode child;
        int count = 0;
        for (current = childList.elements(); current.hasMoreElements(); ) {
            child = (DataNode) current.nextElement();
            count += child.getChildCount();
        }
        return count;
    }

    /** All debugging output should go through this function, not just system.out.println.
	  * This allows turning on and off of debug messages globally. Also, it will allow replacing
	  * Ssytem.out.println with some other method later.
	  */
    void debugOut(String s) {
        if (m_debugEnabled) Log.info(s);
    }

    /** Gets the name of the UI class for this object
	  * This will replace MapUI when it is implemented in all child classes
	  * use either 
	  *		Class.forName("ViewUser");	// 1.02 and 1.1
	  *		ViewUser.class;				// JDK 1.1 only. Better, doesn't throw exceptions. But not supported on 1.02
	  */
    Class getUIClass() {
        return m_UIClass;
    }

    ;

    /** Sets the name of the UI class for this object
	  * This will replace MapUI when it is implemented in all child classes
	  * use either 
	  *		Class.forName("ViewUser");	// 1.02 and 1.1
	  *		ViewUser.class;				// JDK 1.1 only. Better, doesn't throw exceptions. But not supported on 1.02
	  */
    protected void setUIClass(Class newUIClass) {
        m_UIClass = newUIClass;
    }

    ;

    /** Gets the highest message # used by this object */
    int getLocalHighMsgNumber() {
        return 0;
    }

    /** recursive, checks all children, too */
    int getHighMsgNumber() {
        int childHigh = getChildHighMsgNumber();
        int localHigh = getLocalHighMsgNumber();
        return Math.max(childHigh, localHigh);
    }

    int getChildHighMsgNumber() {
        int high = 0;
        Enumeration current;
        DataNode child;
        int count = 0;
        for (current = childList.elements(); current.hasMoreElements(); ) {
            child = (DataNode) current.nextElement();
            int childHigh = child.getHighMsgNumber();
            if (childHigh > high) high = childHigh;
        }
        return high;
    }

    /** Deletes this DataNode object from the persistant store, listeners are notified.
	  * force isn't used yet, but some of the derived classes will use it 
	  * to control whether you can delete a user who still has messages, for example
	  * ZZZ: we need to delete the object from the parent's chain. That's why deleted lists
	  * are still visible to the ListServer. Later comment: Should the delete from parent be a consequence
	  * of the Notitify?
	  */
    public int delete(boolean force) {
        boolean b = true;
        if (!force && getChildCount() != 0) {
            Log.info("DataNode.delete: Attempt to delete a node '" + getName() + "' failed, because it has children ");
            return DEL_NOT_EMPTY;
        }
        File infoFile = getInfoFile(false);
        if ((infoFile != null) && infoFile.exists()) {
            if (!infoFile.delete()) {
                Log.error("DataNode.delete: unable to delete info file " + infoFile + " for " + getName());
                return DEL_FAILED;
            }
        }
        File baseDir = getBaseDir();
        if (!baseDir.delete()) Log.error("DataNode.delete: unable to delete directory " + baseDir + " for " + getName());
        notifyListeners(IViewNotify.OBJECT_DELETED, null);
        DataNode parent = getParent();
        parent.deleteChildFromList(this);
        Log.log(Log.MASK_ALWAYS, "Deleted '" + m_name + "' from " + parent.getName());
        return DEL_OK;
    }

    /** Returns a String containing the names of all children, one to a line
	  * suitable for debugging, or including in email
	  */
    String getChildListString() {
        Enumeration current;
        DataNode child;
        String result = "";
        for (current = childList.elements(); current.hasMoreElements(); ) {
            child = (DataNode) current.nextElement();
            result += child.getName() + POP3.lineTermination;
        }
        return result;
    }

    /** Returns an enumeration for walking through all children of this node
	  */
    public Enumeration getChildren() {
        return childList.elements();
    }

    /** Gets one property from the data store. Returns null if not found */
    String getProperty(String key) {
        return getProperty(key, null);
    }

    /** Gets one property from the data store. Returns defValue if not found */
    String getProperty(String key, String defValue) {
        String rc = (String) getConfig().get(key, defValue);
        if (rc == null) return null;
        if (rc.length() == 0) return null;
        return rc;
    }

    /** For properties that you want external obejcts (like WebUIs) to be able to access
	 */
    public String getPublicProperty(String key, String defValue) {
        return getProperty("public_" + key, defValue);
    }

    /** For properties that you want external obejcts (like WebUIs) to be able to access
	 */
    public boolean getPublicProperty(String key, boolean defValue) {
        return getProperty("public_" + key, defValue);
    }

    /** For properties that you want external obejcts (like WebUIs) to be able to access
	 */
    public int getPublicProperty(String key, int defValue) {
        String s = getProperty("public_" + key, "" + defValue);
        try {
            return Integer.parseInt(s);
        } catch (NumberFormatException nfe) {
            return defValue;
        }
    }

    /** Gets one property from the data store. Returns defValue if not found */
    boolean getProperty(String key, boolean defValue) {
        boolean rc = getConfig().get(key, defValue);
        return rc;
    }

    /** Sets a property. */
    void putPublicProperty(String key, String newValue) {
        putProperty("public_" + key, newValue);
    }

    /** Sets a property. */
    void putPublicProperty(String key, boolean newValue) {
        putProperty("public_" + key, newValue);
    }

    /** Sets a property. */
    void putProperty(String key, String newValue) {
        if (newValue == null) newValue = "";
        getConfig().put(key, newValue);
        writeProperties();
    }

    /** Sets a property. */
    void putProperty(String key, boolean newValue) {
        if (newValue) putProperty(key, "1"); else putProperty(key, "0");
        writeProperties();
    }

    /** Returns the errors-to address set in this node. 
	  * null is a valid setting, it indicates that this node
	  * doesn't have a setting, and will use its parent's value.
	  * This function should only be used by callers that are 
	  * going to be setting the errors-to address. Callers
	  * that just want the value to use in mail should call
	  * getErrorsAddress();
	  * @see #getErrorsAddress
	  */
    public String getErrorsAddressLocal() {
        return errorsAddress;
    }

    /** Returns the address that will be used as the 'Errors-to' address
	  * for email generated by this node.
	  */
    public String getErrorsAddress() {
        if (errorsAddress != null) return errorsAddress;
        DataNode parent = getParent();
        if (parent != null) return parent.getErrorsAddress();
        Log.log(Log.MASK_ALWAYS, "No errors-to address set. Using webmaster@softwareforum.org");
        return "webmaster@softwareforum.org";
    }

    public void setErrorsAddress(String newAddress) {
        putProperty(errorsToKey, newAddress);
        errorsAddress = newAddress;
    }

    /** Checks to see if the given password is valid for this object. 
	  * A parents password is considered valid for a child. This 
	  * allows the system or host admin to log in once as root, and
	  * not have to log in again for each page he visits.
	  */
    public boolean checkPassword(String passwordTry, boolean def) {
        String password = (String) getConfig().get(passwordKey, null);
        if (password == null) return def;
        password = password.trim();
        if (!password.equals(passwordTry)) {
            String logMessage = "Incorrect password for " + getName();
            if (getParent() != null) logMessage += " on " + getParent().getName();
            Log.info(logMessage);
            return false;
        }
        return true;
    }

    /** Checks to see if the given password is valid for this object. Using APOP
	  * A parents password is considered valid for a child. This 
	  * allows the system or host admin to log in once as root, and
	  * not have to log in again for each page he visits.
	  * @param key The parameter passed to the client
	  * @param response The String returned from the client
	  */
    public boolean checkPassword(byte[] key, byte[] response, boolean def) {
        String password = (String) getConfig().get(passwordKey, null);
        if (password == null) return def;
        password = password.trim();
        MessageDigest md;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException nsa) {
            Log.error("DataNode: Can't get MD5 implementation " + nsa);
            return false;
        }
        md.update(key);
        byte[] hash = md.digest(password.getBytes());
        if (hash.length != response.length) return false;
        for (int i = 0; i < hash.length; i++) {
            if (hash[i] != response[i]) return false;
        }
        return true;
    }

    /** Sets a new password. Passwords are set per object, and a needed by the UI 
	  * classes to verify access permission
	  */
    public void setPassword(String newPassword) {
        putProperty(passwordKey, newPassword);
    }

    /** Gets the WEB ui object for this data node. See WebUI.java */
    public WebUI getWebUIObject() {
        if (m_webUI == null) {
            m_webUI = createWebUI();
        }
        return m_webUI;
    }

    /** Creates the object that will provide the web user interface for this object
	 * <P>
	 * Override in child classes to choose UI object
	 */
    protected WebUI createWebUI() {
        return new WebUI(this);
    }

    /** Sets the object that provides the web user interface for this object
	 */
    protected void setWebUIObject(WebUI obj) {
        m_webUI = obj;
    }

    /** User visible description of the object */
    public void setOneLineDescription(String newDesc) {
        putProperty(targetDescKey, newDesc);
    }

    /** User visible description of the object */
    public String getOneLineDescription() {
        return getProperty(targetDescKey, null);
    }

    /** This is called periodically by the system, to allow nodes to do whatever backups,
	  * etc, that they need to do on a regular basis
	  */
    public void timerTick(java.util.Date d) {
        Enumeration current = childList.elements();
        DataNode child;
        while (current.hasMoreElements()) {
            child = (DataNode) current.nextElement();
            child.timerTick(d);
        }
        return;
    }

    /** Gets a list of the external properties of this object.
	 * This is the version for internal use
	 * @see #getExternalProperties
	 * @see #m_externalProperties
	 * @see com.worldware.ichabod.node.Property
	 * @return An enumeration of the preperties
	 */
    protected Enumeration getExtProps() {
        return m_externalProperties.elements();
    }

    /** Gets a list of the external properties of this object.
	 * This is the publicly accessible version (which really should return a read only copy, but doesn't yet.)
	 * @see #m_externalProperties
	 * @see com.worldware.ichabod.node.Property
	 * @return An enumeration of the preperties
	 */
    public Enumeration getExternalProperties() {
        return m_externalProperties.elements();
    }

    /** Gets the ID for this node
	 */
    public MailRecipientID getID() {
        return this.m_nodeID;
    }

    /** Creates a sequence, for this DataNode, with a minimum value for the
	 * start of the sequence.
	 */
    public ISequence createSequence(int min) {
        return createSequence(min, "MessageID.int", 1);
    }

    /** Creates a sequence with the specified minimum, name, and blocksize for this DataNode
	 */
    public ISequence createSequence(int min, String seqName, int blockSize) {
        if (m_store == null) return new MessageNumber(min, getBaseDir(), seqName, blockSize);
        return m_store.createSequence(m_nodeID, seqName, min, blockSize);
    }

    public String getExpiringDynamicAddress(int days) {
        Date now = new Date();
        long lNow = now.getTime();
        long lFuture = lNow + (1000L * 60L * 60L * 24L * days);
        Date future = new Date(lFuture);
        DynamicAddress da = new DynamicAddress(this.getName(), future, null, getPublicProperty("onetimekey", null));
        return da.createString();
    }
}
