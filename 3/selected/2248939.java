package org.expasy.jpl.demos;

import java.io.File;
import java.io.IOException;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.PosixParser;
import org.expasy.jpl.commons.base.builder.BuilderException;
import org.expasy.jpl.commons.base.cond.Condition;
import org.expasy.jpl.commons.base.io.DecimalFormatFactory;
import org.expasy.jpl.core.mol.chem.MassCalculator;
import org.expasy.jpl.core.mol.polymer.pept.PeptideType;
import org.expasy.jpl.core.mol.polymer.pept.Peptide;
import org.expasy.jpl.core.mol.polymer.pept.PeptideTypeImpl;
import org.expasy.jpl.core.mol.polymer.pept.PeptideTypeComposite;
import org.expasy.jpl.core.mol.polymer.pept.PeptideTypeCondition;
import org.expasy.jpl.core.mol.polymer.pept.cutter.CleavageSiteCutter;
import org.expasy.jpl.core.mol.polymer.pept.cutter.DigestedPeptide;
import org.expasy.jpl.core.mol.polymer.pept.cutter.Digester;
import org.expasy.jpl.core.mol.polymer.pept.cutter.Peptidase;
import org.expasy.jpl.core.mol.polymer.pept.fragmenter.FragmentationType;
import org.expasy.jpl.core.mol.polymer.pept.fragmenter.PeptideFragmentationException;
import org.expasy.jpl.core.mol.polymer.pept.fragmenter.PeptideFragmenter;
import org.expasy.jpl.core.ms.spectrum.PeakListImpl;
import org.expasy.jpl.core.ms.spectrum.annot.FragmentAnnotation;
import org.expasy.jpl.core.ms.spectrum.peak.AnnotatedPeak;
import org.expasy.jpl.io.mol.fasta.FastaEntry;
import org.expasy.jpl.io.mol.fasta.FastaReader;

/**
 * This application digests a database of proteins given a fasta file and make
 * the fragmentation of digested peptide to generate theoretical MS2 spectra.
 * 
 * @author nikitin
 * 
 */
public class Fas2MS {

    static String version = "1.2";

    /** the default double precision */
    static int DEFAULT_PRECISION = 6;

    /** the default charge */
    static int DEFAULT_CHARGE = 1;

    /** the default fragment generated */
    static String DEFAULT_FRAGS = "b,y";

    /** the default protease */
    static String DEFAULT_PROTEASE_PATTERN = "[KR]|[^P]";

    /** no annot-mode by default */
    static boolean DEFAULT_ANNOT_MODE = false;

    /** the program name */
    static String PROG_NAME = "Fas2MS";

    /** the digester */
    static Digester digester;

    /** the peptidase */
    static Peptidase peptidase;

    /** the fragmenter */
    static PeptideFragmenter fragmenter;

    /** the file name for fasta data */
    static String filename = "";

    /** the fragment charges */
    static Set<Integer> charges;

    /** the type of fragments */
    static Set<PeptideType> peakTypes;

    /** the type of fragmentation(s) */
    static Set<FragmentationType> fragmentationTypes;

    /** the filter on spectra */
    static Condition<AnnotatedPeak> fragmentCondition;

    /** the mass calculator */
    static MassCalculator MASS_CALC = MassCalculator.getMonoAccuracyInstance();

    static boolean isAnnotMode;

    /** the print formatter for doubles */
    static NumberFormat formatter;

    /** the precision for doubles */
    static int precision;

    /** true if no digestion to do */
    static boolean noDigestion = false;

    public static void main(String[] args) throws IOException {
        try {
            parseCommandLine(args);
        } catch (org.apache.commons.cli.ParseException e) {
            System.err.println(e);
            System.exit(1);
        }
        System.out.println("###");
        System.out.println("# Generated by " + PROG_NAME + "v." + version);
        System.out.println("# ");
        System.out.println("# Database read from  : " + filename);
        if (noDigestion) {
            System.out.println("# No Digestion");
        } else {
            System.out.println("# Digested by         : " + peptidase);
        }
        System.out.println("# Fragmentation types : " + fragmentationTypes);
        System.out.println("# Generate frag types : " + peakTypes);
        System.out.println("# With charges        : " + charges);
        System.out.println("# Peak mode format    : " + ((isAnnotMode) ? "annot mode" : "charge mode"));
        System.out.println("# Decimal precision   : " + precision);
        System.out.println("#############");
        fragmenter = new PeptideFragmenter.Builder(fragmentationTypes).build();
        fragmenter.setChargeSerie(charges);
        try {
            processFasta(filename);
        } catch (ParseException e) {
            System.err.println(e);
            System.exit(2);
        } catch (PeptideFragmentationException e) {
            System.err.println(e);
            System.exit(3);
        }
    }

    /**
	 * @return options of Fas2MS.
	 */
    @SuppressWarnings("static-access")
    private static Options createShortOptions() {
        Options options = new Options();
        options.addOption("h", "help", false, "print this message.");
        options.addOption("v", "version", false, "print the version info.");
        options.addOption("a", "annot-mode", false, "enable peak annot mode.");
        options.addOption("q", "charge-numbers", true, "define the list of charge for fragments:\n" + "a sequence of integers like in 1,2,3:5,10:7\n" + "by default: " + DEFAULT_CHARGE + ".");
        options.addOption("d", "digest-motif", true, "define the motif for digestion:\n" + "\n" + "<pre-cut> <cut-token> <post-cut>\n" + "<pre-cut> := (<AA> | <AA-class>)+\n" + "<post-cut> := (<AA> | <AA-class>)+\n" + "<AA> := [A-Z]\n" + "<AA-class> := '[' AA+ ']'\n" + "by default: Trypsin, " + DEFAULT_PROTEASE_PATTERN + ".");
        options.addOption("f", "frag-types", true, "define the fragment type(s):\n" + "a,b,c,x,y,z for backbone type fragments\n" + "i for immonium and p for precursor\n" + "by default: " + DEFAULT_FRAGS + ".");
        OptionBuilder.withLongOpt("no-dig");
        options.addOption(OptionBuilder.withDescription("non digestion mode.").create());
        options.addOption("p", "precision", true, "define the decimal precision for any mass-to-charge ratio\n" + "by default: " + DEFAULT_PRECISION + ".");
        return options;
    }

    /**
	 * Parse command line and configure the system.
	 * 
	 * @param args the arguments.
	 * @throws org.apache.commons.cli.ParseException
	 * 
	 * @throws ParseException if parsing of parameters failed.
	 */
    private static void parseCommandLine(String[] args) throws org.apache.commons.cli.ParseException {
        Options options = null;
        CommandLineParser parser = null;
        options = createShortOptions();
        parser = new PosixParser();
        HelpFormatter usage = new HelpFormatter();
        try {
            CommandLine line = parser.parse(options, args);
            if (line.hasOption("h")) {
                usage.printHelp(PROG_NAME + " <fasta>", options, true);
                System.exit(0);
            }
            if (line.hasOption("v")) {
                System.out.println(PROG_NAME + " v." + version);
                System.exit(0);
            }
            if (line.hasOption("a")) {
                isAnnotMode = true;
            } else {
                isAnnotMode = DEFAULT_ANNOT_MODE;
            }
            charges = parseCharges(line.getOptionValue("q"));
            if (charges.size() == 0) {
                charges.add(DEFAULT_CHARGE);
            }
            if (line.hasOption("no-dig")) {
                noDigestion = true;
            } else {
                String pattern = line.getOptionValue("d");
                if (pattern == null) {
                    pattern = DEFAULT_PROTEASE_PATTERN;
                }
                CleavageSiteCutter cutter = new CleavageSiteCutter.Builder(pattern).build();
                peptidase = Peptidase.valueOf(cutter);
                digester = Digester.newInstance(peptidase);
            }
            String fragTypes = line.getOptionValue("f");
            if (fragTypes == null) {
                fragTypes = DEFAULT_FRAGS;
            }
            parsePeakTypes(fragTypes);
            String precisionStr = line.getOptionValue("p");
            if (precisionStr == null) {
                precision = DEFAULT_PRECISION;
            } else {
                precision = Integer.parseInt(precisionStr);
            }
            formatter = DecimalFormatFactory.valueOf(precision);
            if (line.getArgList().size() == 0) {
                System.err.println("missing file name");
                usage.printHelp(PROG_NAME + " <fasta>", options, true);
                System.exit(1);
            } else if (line.getArgList().size() > 1) {
                System.err.println("too many arguments");
                usage.printHelp(PROG_NAME + " <fasta>", options, true);
                System.exit(2);
            } else {
                filename = line.getArgs()[0];
            }
        } catch (ParseException exp) {
            System.out.println("Unexpected exception:" + exp.getMessage());
            usage.printHelp(PROG_NAME + " <fasta>", options, true);
            System.exit(3);
        }
    }

    private static Set<Integer> parseCharges(String line) {
        Set<Integer> charges = new HashSet<Integer>();
        if (line != null) {
            Pattern pattern = Pattern.compile("\\d+(\\:\\d+)*");
            Matcher matcher = pattern.matcher(line);
            while (matcher.find()) {
                String value = matcher.group();
                if (value.indexOf(":") != -1) {
                    int sepCount = value.replaceAll("[^:]", "").length();
                    if (sepCount > 0) {
                        if (sepCount == 1) {
                            String[] se = value.split(":");
                            int from = Integer.parseInt(se[0]);
                            int to = Integer.parseInt(se[1]);
                            int tmp = 0;
                            if (to < from) {
                                tmp = from;
                                from = to;
                                to = tmp;
                            }
                            for (int i = from; i <= to; i++) {
                                charges.add(i);
                            }
                        } else {
                            System.err.println("bad syntax: " + value + "\n");
                        }
                    }
                } else {
                    charges.add(Integer.parseInt(value));
                }
            }
        }
        return charges;
    }

    private static void parsePeakTypes(String fragments) throws ParseException {
        peakTypes = new HashSet<PeptideType>();
        fragmentationTypes = new HashSet<FragmentationType>();
        for (String fragment : fragments.split(",")) {
            PeptideType type = PeptideTypeImpl.valueOf(fragment);
            if (type != null) {
                peakTypes.add(type);
                if (type == PeptideTypeComposite.A || type == PeptideTypeComposite.X) {
                    fragmentationTypes.add(FragmentationType.AX);
                } else if (type == PeptideTypeComposite.B || type == PeptideTypeComposite.Y) {
                    fragmentationTypes.add(FragmentationType.BY);
                } else if (type == PeptideTypeComposite.C || type == PeptideTypeComposite.Z) {
                    fragmentationTypes.add(FragmentationType.CZ);
                } else if (type == PeptideTypeImpl.I) {
                    peakTypes.add(PeptideTypeImpl.I);
                    fragmentationTypes.add(FragmentationType.IMMONIUM);
                } else if (type == PeptideTypeImpl.P) {
                    peakTypes.add(PeptideTypeImpl.P);
                    fragmentationTypes.add(FragmentationType.PRECURSOR);
                } else {
                    System.err.println("not supported type " + type);
                }
            } else {
                System.err.println("water/ammonium losses: not yet implemented");
            }
        }
        fragmentCondition = new PeptideTypeCondition.Builder<AnnotatedPeak>(fragments).accessor(AnnotatedPeak.TO_PEAK_TYPE).build();
    }

    /**
	 * Digest and fragment all fasta entries.
	 * 
	 * @param filename the fasta filename.
	 * 
	 * @throws ParseException if parsing failed.
	 * @throws IOException if file does not exist.
	 * @throws PeptideFragmentationException if fragmentation crashed.
	 */
    private static void processFasta(String filename) throws ParseException, IOException, PeptideFragmentationException {
        if (noDigestion) {
            processFastaNoDigestion(filename);
        } else {
            processFastaWithDigestion(filename);
        }
    }

    private static void processFastaNoDigestion(String filename) throws ParseException, IOException, PeptideFragmentationException {
        FastaReader fastaScanner = FastaReader.newInstance();
        fastaScanner.parse(new File(filename));
        Iterator<FastaEntry> it = fastaScanner.iterator();
        while (it.hasNext()) {
            FastaEntry nextEntry = it.next();
            try {
                Peptide peptide = new Peptide.Builder(nextEntry.getSequence()).build();
                Map<Peptide, PeakListImpl> peptideFragments = makeFragmentation(peptide, charges);
                if (!peptideFragments.isEmpty()) {
                    writeMGF(peptide.toAAString(), peptideFragments);
                }
            } catch (BuilderException e) {
                System.err.println(e.getMessage() + ": cannot make spectrum from ambiguous peptide " + nextEntry.getSequence() + ".");
            }
        }
    }

    private static void processFastaWithDigestion(String filename) throws ParseException, IOException, PeptideFragmentationException {
        FastaReader fastaScanner = FastaReader.newInstance();
        fastaScanner.parse(new File(filename));
        Iterator<FastaEntry> it = fastaScanner.iterator();
        while (it.hasNext()) {
            FastaEntry nextEntry = it.next();
            Set<DigestedPeptide> peptides = makeDigestion(nextEntry.getSequence());
            for (DigestedPeptide digest : peptides) {
                if (digest.isAmbiguous()) {
                    System.err.println("# " + digest + ": ambigous.");
                } else if (!fragmenter.isFragmentable(digest)) {
                    System.err.println("# " + digest + ": too short.");
                } else {
                    Map<Peptide, PeakListImpl> peptideFragments = makeFragmentation(digest.getPeptide(), charges);
                    if (!peptideFragments.isEmpty()) {
                        writeMGF(digest.toAAString(), peptideFragments);
                    }
                }
            }
        }
    }

    private static Set<DigestedPeptide> makeDigestion(String sequence) throws ParseException {
        digester.digest(new Peptide.Builder(sequence).ambiguityEnabled().build());
        return digester.getDigests();
    }

    private static Map<Peptide, PeakListImpl> makeFragmentation(Peptide seq, Set<Integer> charges) throws PeptideFragmentationException {
        Map<Peptide, PeakListImpl> peptideFragments = new HashMap<Peptide, PeakListImpl>();
        int maxCharge = 0;
        Iterator<Integer> it = charges.iterator();
        while (it.hasNext()) {
            int currentCharge = it.next();
            if (currentCharge > maxCharge) {
                maxCharge = currentCharge;
            }
        }
        fragmenter.setFragmentablePrecursor(new Peptide.Builder(seq).protons(maxCharge).build());
        fragmenter.setChargeSerie(charges);
        fragmenter.generateFragments();
        PeakListImpl pl = fragmenter.getPeakList(fragmentCondition);
        if (pl.size() == 0) {
            throw new PeptideFragmentationException("no peaks found for " + seq);
        }
        peptideFragments.put(fragmenter.getFragmentablePrecursor(), pl);
        return peptideFragments;
    }

    public static void writeMGF(String title, Map<Peptide, PeakListImpl> peptideFragments) {
        for (Peptide precursorPeptide : peptideFragments.keySet()) {
            String peptideName = precursorPeptide.toAAString() + "/" + precursorPeptide.getNumberOfProtons();
            PeakListImpl fragments = peptideFragments.get(precursorPeptide);
            System.out.print("\n\n");
            System.out.println("BEGIN ION");
            System.out.println("TITLE=" + peptideName);
            System.out.println("PEPMASS=" + formatter.format(MASS_CALC.getMz(precursorPeptide)));
            System.out.println("CHARGE=" + precursorPeptide.getNumberOfProtons());
            int n = fragments.size();
            for (int i = 0; i < n; i++) {
                FragmentAnnotation annot = fragments.getAnnotationsAt(i).get(0);
                System.out.println(formatter.format(fragments.getMzAt(i)) + "\t" + ((isAnnotMode) ? annot : annot.getCharge()));
            }
            System.out.println("END IONS");
        }
    }
}
