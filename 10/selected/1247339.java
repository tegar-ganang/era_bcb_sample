package com.apelon.dts.db;

import com.apelon.common.util.GidGenerator;
import com.apelon.common.xml.XMLException;
import com.apelon.dts.db.modules.WFPlugin;
import com.apelon.dts.server.DTSPermission;
import com.apelon.dts.server.PermissionException;
import com.apelon.dts.util.DTSXMLFactory;
import com.apelon.dts.common.DTSValidationException;
import com.apelon.dts.util.DTSUtil;
import com.apelon.dts.common.DTSDataLimits;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.sql.*;
import java.util.HashMap;
import java.util.Iterator;

/**
 * Thesaurus Concept additions, deletions and updates.
 *
 * @since DTS 3.0
 *
 * Copyright (c) 2006 Apelon, Inc. All rights reserved.
 */
public class ThesaurusConceptDb extends DTSConceptDb {

    private static final String TABLE_KEY = "THESAURUSCONCEPT_DB";

    private static final String COLUMN = "column";

    private static final String VALUE = "value";

    private static final String NAME = "name";

    private static final String ID = "id";

    private static final String CODE = "code";

    private static final String NAMESPACE_ID = "namespaceId";

    private PreparedStatement insertSt = null;

    private PreparedStatement updateSt = null;

    private PreparedStatement updateConceptRelatedSt = null;

    private PreparedStatement deleteConceptRelatedSt = null;

    private Statement stmt = null;

    /**
  * Set the database connection in {@linkplain  BasicDb BasicDb}
  * and initiate by storing and preparing SQL statements.
  *
  * @param conn a java.sql.Connection for access to DTS schema.
  *
  * @since DTS 3.0
  */
    public ThesaurusConceptDb(Connection conn) throws SQLException {
        this(conn, true);
    }

    /**
  * Set the database connection in {@linkplain  BasicDb BasicDb}
  * and option to initiate by storing and preparing SQL statements.
  *
  * @param conn a java.sql.Connection for access to DTS schema.
  * @param init_p true if initiate by storing and preparing SQL statements.
  *
  * @since DTS 3.0
  */
    public ThesaurusConceptDb(Connection conn, boolean init_p) throws SQLException {
        super(conn);
        if (init_p) {
            init();
        }
    }

    protected void init() throws SQLException {
        String statement = getDAO().getStatement(TABLE_KEY, "INSERT");
        insertSt = conn.prepareStatement(statement);
        statement = getDAO().getStatement(TABLE_KEY, "UPDATE");
        updateSt = conn.prepareStatement(statement);
        stmt = conn.createStatement();
        statement = getDAO().getStatement(TABLE_KEY, "FIND_CONCEPT_ASSN");
        updateConceptRelatedSt = this.conn.prepareStatement(statement);
        statement = getDAO().getStatement(TABLE_KEY, "DELETE_CONCEPT_ASSN");
        deleteConceptRelatedSt = this.conn.prepareStatement(statement);
    }

    public void close() throws SQLException {
        super.close();
        this.closeStatements(new Statement[] { insertSt, updateSt, stmt, updateConceptRelatedSt, deleteConceptRelatedSt });
    }

    /**
  * Add concept name, code, id and gid generated by
  * BasicDb.getGID(int namespaceId, int id) to a namespace.
  *
  * @param root a Xml DOM Element holding data about the concept to add.
  * @param permit a DTSPermission object used to validate the user.
  *
  * @return a String of Xml holding data about the added concept.
  *
  * @since DTS 3.0
  */
    public String addConcept(Element root, DTSPermission permit) throws SQLException, XMLException, PermissionException {
        NodeList children = root.getChildNodes();
        int len = children.getLength();
        Node node = children.item(0);
        Element asd = (Element) children.item(1);
        String name = getAttribute(node, NAME);
        String id = getAttribute(node, ID);
        String code = getAttribute(node, CODE);
        String namespaceId = getAttribute(node, NAMESPACE_ID);
        checkPermission(permit, namespaceId);
        int namespaceIdInt = Integer.parseInt(namespaceId);
        int idInt = Integer.parseInt(id);
        if (idInt == -1) {
            idInt = getItemSeq("C", namespaceIdInt);
        }
        if ((code == null) || code.equals("") || code.equals("null")) {
            code = generateCode(idInt);
        }
        name = DTSUtil.checkValue("Concept Name", name, DTSDataLimits.LEN_NAME_TERM);
        code = DTSUtil.checkValue("Concept Code", code, DTSDataLimits.LEN_CODE);
        long concept_gid = getGID(namespaceIdInt, idInt);
        insertSt.setLong(1, concept_gid);
        insertSt.setInt(2, idInt);
        insertSt.setString(3, code);
        insertSt.setString(4, name);
        insertSt.setInt(5, namespaceIdInt);
        insertSt.setString(6, name.toUpperCase());
        boolean success = doTransaction(null, insertSt, idInt, namespaceIdInt, permit, WFPlugin.ATTR_ITEM, WFPlugin.EDIT_ADD);
        return findConcept("ID", Integer.toString(idInt), Integer.toString(namespaceIdInt), asd, true, true);
    }

    protected String generateCode(int id) {
        return "C" + id;
    }

    /**
  * Delete concept by name, code or id.
  *
  * @param root a Xml DOM Element holding data about the concept to delete.
  * @param permit a DTSPermission object used to validate the user.
  *
  * @return a String of Xml indicating if the concept was deleted.
  *
  * @since DTS 3.0
  */
    public String deleteConcept(Element root, DTSPermission permit) throws SQLException, XMLException, PermissionException {
        String column = root.getAttribute(COLUMN);
        String value = root.getAttribute(VALUE);
        String namespaceId = root.getAttribute(NAMESPACE_ID);
        checkPermission(permit, namespaceId);
        return deleteConcept(column, value, namespaceId, permit);
    }

    /**
  * Delete concept by column (name, code or id) with a given value in a certain namespace.
  *
  * @param column a String indicating the name of the column to delete the concept by.
  * @param value a String indicating the value in the column to delete the concept by.
  * @param namespaceId a String that is the id of the namespace in which the concept exists.
  * @param permit a DTSPermission object used to validate the user.
  *
  * @return a String of Xml indicating if the concept was deleted.
  *
  * @since DTS 3.0
  */
    public String deleteConcept(String column, String value, String namespaceId, DTSPermission permit) throws SQLException, XMLException {
        boolean conceptExists = conceptExists(column, value, namespaceId);
        if (conceptExists) {
            String statement = getDAO().getStatement(TABLE_KEY, "DELETE_BY_" + column.toUpperCase());
            statement = getDAO().getStatement(statement, 1, "'" + value + "'");
            boolean success = doTransaction(statement + namespaceId, stmt, Integer.parseInt(value), Integer.parseInt(namespaceId), permit, WFPlugin.ATTR_ITEM, WFPlugin.EDIT_DELETE);
            conceptExists = conceptExists(column, value, namespaceId);
        }
        String response = null;
        if (conceptExists) {
            response = getFalseResult();
        } else {
            response = getTrueResult();
        }
        return response;
    }

    private boolean conceptExists(String column, String value, String namespaceId) throws SQLException, XMLException {
        boolean found = false;
        ResultSet gids = null;
        String statement = getDAO().getStatement(TABLE_KEY, "FIND_BY_" + column.toUpperCase());
        statement = getDAO().getStatement(statement, 1, "'" + value + "'");
        try {
            gids = stmt.executeQuery(statement + namespaceId);
            while (gids.next()) {
                found = true;
                break;
            }
        } catch (SQLException e) {
            throw e;
        } finally {
            if (gids != null) {
                gids.close();
            }
        }
        return found;
    }

    /**
  * Update concept name or code by replacing old concept with a new one.
  *
  * @param root a Xml DOM Element holding data about the old and new concepts.
  * @param permit a DTSPermission object used to validate the user.
  *
  * @return a String of Xml with information about the new concept.
  *
  * @since DTS 3.0
  */
    public String updateConcept(Element root, DTSPermission permit) throws SQLException, XMLException, PermissionException, DTSValidationException {
        String oldId = root.getAttribute(ID);
        String oldNamespaceId = root.getAttribute(NAMESPACE_ID);
        NodeList children = root.getChildNodes();
        int len = children.getLength();
        Node node = children.item(0);
        Element asd = (Element) children.item(1);
        String code = DTSXMLFactory.getAttribute(node, CODE);
        String name = DTSXMLFactory.getAttribute(node, NAME);
        String namespaceId = DTSXMLFactory.getAttribute(node, NAMESPACE_ID);
        checkPermission(permit, namespaceId);
        name = DTSUtil.checkValue("Concept Name", name, DTSDataLimits.LEN_NAME_TERM);
        code = DTSUtil.checkValue("Concept Code", code, DTSDataLimits.LEN_CODE);
        updateSt.setString(1, code);
        updateSt.setString(2, name);
        updateSt.setString(3, name.toUpperCase());
        int oldIdint = Integer.parseInt(oldId);
        updateSt.setInt(4, oldIdint);
        int oldnamespaceIdInt = Integer.parseInt(oldNamespaceId);
        updateSt.setInt(5, oldnamespaceIdInt);
        boolean success = doTransaction(null, updateSt, oldIdint, oldnamespaceIdInt, permit, WFPlugin.ATTR_ITEM, WFPlugin.EDIT_UPDATE);
        if (!success) {
            boolean conceptExists = conceptExists(ID, oldId, oldNamespaceId);
            if (!conceptExists) {
                throw new DTSValidationException("Unable to update concept: id=" + oldId + ", namespaceId=" + oldNamespaceId + ". The concept doesn't exist in knowledgebase.");
            }
        }
        return findConcept("CODE", code, oldNamespaceId, asd, true, true);
    }

    private boolean doTransaction(String statement, Statement st, int id, int namespaceId, DTSPermission permit, char attrType, char editType) throws SQLException {
        conn.setAutoCommit(false);
        int defaultLevel = conn.getTransactionIsolation();
        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
        boolean success = false;
        int result = 0;
        try {
            WFPlugin wf = this.getConceptWF(permit);
            if (editType == WFPlugin.EDIT_DELETE) {
                wf.update(id, namespaceId, permit, attrType, editType);
                updateConceptRelatedWF(wf, permit, id, namespaceId);
            }
            if (statement == null) {
                result = ((PreparedStatement) st).executeUpdate();
            } else {
                result = st.executeUpdate(statement);
            }
            success = (result == 1) ? true : false;
            if (!success) {
                conn.rollback();
                return success;
            }
            if (editType != WFPlugin.EDIT_DELETE) {
                wf.update(id, namespaceId, permit, attrType, editType);
            }
            conn.commit();
            return success;
        } catch (SQLException e) {
            conn.rollback();
            throw e;
        } catch (Exception e) {
            conn.rollback();
            throw new SQLException("unable to update concept: id " + id + " namespaceId: " + namespaceId + " edit mode:" + editType);
        } finally {
            conn.setTransactionIsolation(defaultLevel);
            conn.setAutoCommit(true);
        }
    }

    /**
   * This method reports by adding affected concept entries to the audit panel.
   * A concept which is deleted may affect its associated concepts.
   * For now, only concepts associated to the deleted concept are logged.
   */
    private void updateConceptRelatedWF(WFPlugin wf, DTSPermission permit, int conceptId, int conceptNamespaceId) throws SQLException {
        ResultSet rs = null;
        try {
            updateConceptRelatedSt.setInt(1, conceptId);
            updateConceptRelatedSt.setInt(2, conceptNamespaceId);
            rs = updateConceptRelatedSt.executeQuery();
            HashMap list = new HashMap(5);
            while (rs.next()) {
                list.put(new Integer(rs.getInt(1)), new Integer(rs.getInt(2)));
            }
            deleteConceptRelatedSt.setLong(1, GidGenerator.getGID(conceptNamespaceId, conceptId));
            deleteConceptRelatedSt.executeUpdate();
            Iterator keys = list.keySet().iterator();
            while (keys.hasNext()) {
                Object key = keys.next();
                int cid = ((Integer) key).intValue();
                int cnspid = ((Integer) list.get(key)).intValue();
                wf.update(cid, cnspid, permit, WFPlugin.ATTR_ASSOCIATION, WFPlugin.EDIT_DELETE);
            }
        } finally {
            if (rs != null) {
                rs.close();
            }
        }
    }
}
