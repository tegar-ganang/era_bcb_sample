package org.torweg.pulse.invocation.lifecycle;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.hibernate.HibernateException;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import org.torweg.pulse.accesscontrol.attributes.AttributeRegistry;
import org.torweg.pulse.accesscontrol.attributes.BundleAttribute;
import org.torweg.pulse.bundle.Bundle;
import org.torweg.pulse.component.Component;
import org.torweg.pulse.service.PulseException;
import org.torweg.pulse.service.ServletConfig;
import org.torweg.pulse.service.request.LocaleManager;
import org.torweg.pulse.site.content.ContentRegistry;
import org.torweg.pulse.site.content.RegistryBundleNode;
import org.torweg.pulse.site.content.RegistryLocaleNode;
import org.torweg.pulse.site.map.Sitemap;
import org.torweg.pulse.site.map.SitemapNode;
import org.torweg.pulse.util.HibernateDataSourceImpl;
import org.torweg.pulse.util.entity.Node;
import org.torweg.pulse.util.xml.XMLConverter;

/**
 * utility class with startup and shutdown tasks of the {@code Lifecycle}.
 * 
 * @author Thomas Weber
 * @version $Revision: 2079 $
 */
public final class LifecycleHibernateTasks {

    /**
	 * the logger.
	 */
    private static final Logger LOGGER = Logger.getLogger(LifecycleHibernateTasks.class);

    /**
	 * hidden constructor.
	 */
    private LifecycleHibernateTasks() {
        super();
    }

    /**
	 * initialises the {@code ContentRegistry}, the {@code Sitemap} and the
	 * {@code AttributeRegistry}.
	 * <p>
	 * Builds a {@code ContentRegisty}, if no {@code ContentRegistry} is stored.
	 * Adds a {@code RegistryBundleNode} for each {@code Bundle} which has
	 * contents defined in its {@code bundle.xml} <em>and</em> that is not in
	 * the {@code ContentRegistry}.
	 * </p>
	 * 
	 * @param lc
	 *            the lifecycle
	 */
    protected static void initialiseRegistries(final Lifecycle lc) {
        Session s = lc.getHibernateDatasourceDirectly().createNewSession();
        Transaction tx = s.beginTransaction();
        try {
            ContentRegistry contentRegistry;
            Object contentRegistryObj = s.createQuery("from ContentRegistry cr").uniqueResult();
            if (contentRegistryObj == null) {
                LOGGER.info("First initialisation of ContentRegistry.");
                contentRegistry = new ContentRegistry();
                s.save(contentRegistry);
            } else {
                contentRegistry = (ContentRegistry) contentRegistryObj;
            }
            for (org.torweg.pulse.service.request.Locale rlocale : lc.getLocalesDirectly()) {
                Locale locale = LocaleManager.localeToLocale(rlocale);
                Object sitemapObj = s.createQuery("from Sitemap as sm where sm.locale=?").setString(0, locale.toString()).uniqueResult();
                if (sitemapObj == null) {
                    Sitemap sitemap = new Sitemap(locale, new SitemapNode("Autogenerated Node", locale));
                    s.saveOrUpdate(sitemap);
                    LOGGER.info("initialised Sitemap for locale '" + locale + "'.");
                }
            }
            AttributeRegistry attributeRegistry;
            Object registryObj = s.createQuery("from AttributeRegistry ar").uniqueResult();
            if (registryObj == null) {
                LOGGER.info("First initialisation of AttributeRegistry.");
                attributeRegistry = new AttributeRegistry();
                s.save(attributeRegistry);
            } else {
                attributeRegistry = (AttributeRegistry) registryObj;
            }
            for (Bundle bundle : lc.getBundlesDirectly().values()) {
                processBundleForContentRegistry(lc, s, contentRegistry, bundle);
                processBundleForAttributeRegistry(s, attributeRegistry, bundle);
            }
            tx.commit();
            LOGGER.info("Initialised registries.");
        } catch (HibernateException e) {
            LOGGER.error("Cannot initialise registries: ", e);
            tx.rollback();
        } finally {
            s.close();
        }
    }

    /**
	 * processes a {@code Bundle} for the initialisation of the
	 * {@code ContentRegistry}.
	 * 
	 * @param lc
	 *            the lifecycle
	 * @param s
	 *            the Hibernate<sup>TM</sup> session
	 * @param contentRegistry
	 *            the content registry
	 * @param bundle
	 *            the bundle
	 */
    private static void processBundleForContentRegistry(final Lifecycle lc, final Session s, final ContentRegistry contentRegistry, final Bundle bundle) {
        if ((!bundle.getContentTypes().isEmpty())) {
            boolean alreadyExists = false;
            for (RegistryBundleNode rbn : contentRegistry.getRootNodes()) {
                if (rbn.getName().equals(bundle.getName())) {
                    refreshExistingRegistryBundleNode(s, bundle, rbn, lc);
                    alreadyExists = true;
                }
            }
            if (!alreadyExists) {
                createMissingRegistryBundleNode(s, contentRegistry, bundle);
            }
        }
    }

    /**
	 * creates a missing {@code RegistryBundleNode} in the
	 * {@code ContentRegistry}.
	 * 
	 * @param s
	 *            the Hibernate<sup>TM</sup> session
	 * @param registry
	 *            the content registry
	 * @param bundle
	 *            the bundle
	 */
    private static void createMissingRegistryBundleNode(final Session s, final ContentRegistry registry, final Bundle bundle) {
        RegistryBundleNode rbn = new RegistryBundleNode(bundle);
        for (java.util.Locale loc : Lifecycle.getKnownLocales()) {
            RegistryLocaleNode rln = new RegistryLocaleNode(loc);
            rln.setBundle(bundle);
            rbn.addChild(rln);
        }
        registry.addBundleNode(rbn);
        s.update(registry);
        LOGGER.info("Added Bundle '" + bundle.getName() + "' to ContentRegistry.");
    }

    /**
	 * refreshes an existing {@code RegistryBundleNode} in the
	 * {@code ContentRegistry} and creates missing {@code RegistryLocaleNodes}.
	 * 
	 * @param s
	 *            the hiberante session
	 * @param bundle
	 *            the bundle
	 * @param rbn
	 *            the {@code RegistryBundleNode} to be refreshed
	 * @param lc
	 *            the lifecycle
	 * @return
	 */
    private static void refreshExistingRegistryBundleNode(final Session s, final Bundle bundle, final RegistryBundleNode rbn, final Lifecycle lc) {
        for (java.util.Locale loc : Lifecycle.convertLocaleList(lc.getLocalesDirectly(), false)) {
            boolean foundLocale = false;
            for (Object n : rbn.getChildren()) {
                RegistryLocaleNode rln = (RegistryLocaleNode) n;
                if (loc.equals(rln.getLocale())) {
                    foundLocale = true;
                }
            }
            if (!foundLocale) {
                RegistryLocaleNode rln = new RegistryLocaleNode(loc);
                rln.setBundle(bundle);
                rbn.addChild(rln);
                s.update(rbn);
                LOGGER.info("Added new RegistryLocaleNode for '" + loc.toString() + "' to ContentRegistry" + " in Bundle " + bundle.getName() + ".");
            }
        }
    }

    /**
	 * processes a {@code Bundle} for the initialisation of the
	 * {@code ContentRegistry}.
	 * 
	 * @param s
	 *            the Hibernate<sup>TM</sup> session
	 * @param attributeRegistry
	 *            the attribute registry
	 * @param bundle
	 *            the bundle
	 */
    private static void processBundleForAttributeRegistry(final Session s, final AttributeRegistry attributeRegistry, final Bundle bundle) {
        for (BundleAttribute a : attributeRegistry.getRootNodes()) {
            if (a.getBundle().getName().equals(bundle.getName())) {
                return;
            }
        }
        BundleAttribute ba = new BundleAttribute(true);
        ba.setBundle(bundle);
        attributeRegistry.addBundleNode(ba);
        s.update(attributeRegistry);
        LOGGER.info("Added Bundle '" + bundle.getName() + "' to AttributeRegistry.");
    }

    /**
	 * Initialises the HibernateDataSource.
	 * 
	 * @param lc
	 *            the lifecycle
	 */
    protected static void initialiseHibernate(final Lifecycle lc) {
        ServletConfig config = lc.getPulseConfiguration();
        ArrayList<Class<? extends Object>> annotatedClasses = new ArrayList<Class<? extends Object>>();
        for (Component component : lc.getComponentsDirectly()) {
            annotatedClasses.addAll(component.getHibernateClasses());
        }
        Element hibernateConfig = config.getHibernateConfiguration();
        File cacheConf = new File(lc.getPulseRootDir(), File.separator + "WEB-INF" + File.separator + "conf" + File.separator + "2ndLevelCache.xml");
        if (cacheConf.exists()) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Found configuration for 2nd level cache at " + cacheConf.getAbsolutePath());
            }
            initialiseHibernate2ndLevelCache(cacheConf, hibernateConfig, lc);
        } else {
            LOGGER.info("Not configured to use a 2nd level cache.");
        }
        if (!config.getHibernateSearchIndexBase().exists() && !config.getHibernateSearchIndexBase().mkdirs()) {
            LOGGER.warn("Could not create search index base at: " + config.getHibernateSearchIndexBase().getAbsolutePath());
        }
        lc.setHibernateDataSourceDirectly(new HibernateDataSourceImpl(XMLConverter.getW3CDocument(hibernateConfig), annotatedClasses, config.getHibernateJNDIName()));
        for (Bundle bundle : lc.getBundlesDirectly().values()) {
            addBundleToHibernate(bundle, lc);
            if (LOGGER.isTraceEnabled()) {
                LOGGER.trace("Hibernate: Processed bundle '" + bundle.getName() + "'.");
            }
        }
        executePostHibernateStartUpSQL(config, lc);
    }

    /**
	 * initialises the settings for Hibernate<sup>TM</sup>'s 2nd level cache.
	 * 
	 * @param cacheConfigFile
	 *            the cache configuration file
	 * @param hibernateConfig
	 *            the preparsed configuration from "pulse.xml"
	 * @param lc
	 *            the lifecycle
	 */
    @SuppressWarnings("unchecked")
    protected static void initialiseHibernate2ndLevelCache(final File cacheConfigFile, final Element hibernateConfig, final Lifecycle lc) {
        Element cacheConf = null;
        Element sessionFactoryConfig = hibernateConfig.getChild("session-factory");
        boolean useSecondLevelCache = false;
        @SuppressWarnings("unchecked") List<Element> properties = (List<Element>) sessionFactoryConfig.getChildren("property");
        for (Element prop : properties) {
            if ("hibernate.cache.use_second_level_cache".equals(prop.getAttributeValue("name")) && prop.getTextTrim().equals("true")) {
                useSecondLevelCache = true;
                break;
            }
        }
        if (!useSecondLevelCache) {
            LOGGER.info("Not using a second level cache for Hibernate");
            return;
        }
        try {
            cacheConf = new SAXBuilder().build(cacheConfigFile).getRootElement();
        } catch (Exception e) {
            throw new PulseException("Error parsing the 2nd level cache configuration.", e);
        }
        for (Element child : (List<Element>) cacheConf.getChildren()) {
            sessionFactoryConfig.addContent((Element) child.clone());
        }
        if (cacheConf.getAttribute("provider-configuration") != null) {
            LOGGER.info("copy cache provider" + " configuration to WEB-INF/classes/" + cacheConf.getAttributeValue("provider-configuration"));
            sessionFactoryConfig.addContent(new Element("property").setAttribute("name", "net.sf.ehcache.configurationResourceName").setText("/" + cacheConf.getAttributeValue("provider-configuration")));
            String confFileName = cacheConf.getAttributeValue("provider-configuration");
            File configFile = new File(lc.getPulseRootDir(), File.separator + "WEB-INF" + File.separator + "conf" + File.separator + confFileName);
            File destination = new File(lc.getPulseRootDir(), File.separator + "WEB-INF" + File.separator + "classes" + File.separator + confFileName);
            try {
                copyFile(configFile, destination);
            } catch (IOException e) {
                LOGGER.warn("Could not copy cache provider" + " configuration to WEB-INF/classes: " + e.getLocalizedMessage());
            }
        }
    }

    /**
	 * adds a {@code Bundle} to Hibernate<sup>TM</sup> or refreshes the Object
	 * with the persisted data.
	 * 
	 * @param bundle
	 *            the {@code Bundle} to be processed
	 * @param lc
	 *            the lifecycle
	 */
    protected static void addBundleToHibernate(final Bundle bundle, final Lifecycle lc) {
        Session session = lc.getHibernateDatasourceDirectly().createNewSession();
        Bundle check = (Bundle) session.createQuery("from Bundle where name=?").setString(0, bundle.getName()).uniqueResult();
        session.close();
        if (check == null) {
            session = lc.getHibernateDatasourceDirectly().createNewSession();
            Transaction tx = session.beginTransaction();
            try {
                session.saveOrUpdate(bundle);
                tx.commit();
            } catch (HibernateException e) {
                tx.rollback();
                throw e;
            } finally {
                session.close();
            }
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Bundle '" + bundle.getName() + "' persisted.");
            }
        } else {
            session = lc.getHibernateDatasourceDirectly().createNewSession();
            try {
                session.load(bundle, check.getId());
            } finally {
                session.close();
            }
        }
    }

    /**
	 * executes the post Hibernate<sup>TM</sup> startup custom SQL defined in
	 * pulse.xml.
	 * 
	 * @param config
	 *            the main configuration
	 * @param lc
	 *            the lifecycle
	 */
    @SuppressWarnings("unchecked")
    protected static void executePostHibernateStartUpSQL(final ServletConfig config, final Lifecycle lc) {
        Session s = lc.getHibernateDatasourceDirectly().createNewSession();
        Transaction tx = null;
        Level oldLevel = Logger.getLogger("org.hibernate.util.JDBCExceptionReporter").getLevel();
        try {
            Logger.getLogger("org.hibernate.util.JDBCExceptionReporter").setLevel(Level.OFF);
            for (Element statement : (List<Element>) config.getPostHibernateStartUpSQL().getChildren("statement")) {
                boolean ignoreErrors = false;
                String sql = statement.getText().trim();
                if (statement.getAttributeValue("ignoreErrors").equalsIgnoreCase("true")) {
                    ignoreErrors = true;
                }
                try {
                    tx = s.beginTransaction();
                    s.createSQLQuery(sql).executeUpdate();
                    tx.commit();
                } catch (Exception e) {
                    if (tx != null) {
                        tx.rollback();
                    }
                    if (!ignoreErrors) {
                        LOGGER.warn(sql + System.getProperty("line.separator") + e.getLocalizedMessage());
                    }
                }
            }
        } catch (Exception e) {
            throw new PulseException("Error: " + e.getLocalizedMessage(), e);
        } finally {
            s.close();
            Logger.getLogger("org.hibernate.util.JDBCExceptionReporter").setLevel(oldLevel);
        }
    }

    /**
	 * copies source to destination.
	 * 
	 * @param source
	 *            the source
	 * @param destination
	 *            the destination
	 * @throws IOException
	 *             on errors
	 */
    private static void copyFile(final File source, final File destination) throws IOException {
        FileInputStream in = new FileInputStream(source);
        FileOutputStream out = new FileOutputStream(destination);
        int c = in.read();
        while (c != -1) {
            out.write(c);
            c = in.read();
        }
        in.close();
        out.close();
    }
}
