package edu.mit.lcs.haystack.rdf;

import com.hp.hpl.jena.rdf.arp.ALiteral;
import com.hp.hpl.jena.rdf.arp.ARP;
import com.hp.hpl.jena.rdf.arp.AResource;
import com.hp.hpl.jena.rdf.arp.StatementHandler;
import edu.mit.lcs.haystack.Constants;
import edu.mit.lcs.haystack.core.CoreLoader;
import edu.mit.lcs.haystack.rdf.n3.IN3Engine;
import org.apache.xml.serialize.OutputFormat;
import org.apache.xml.serialize.XMLSerializer;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.AttributesImpl;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URL;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.TimeZone;

/**
 * Provides commonly-used RDF helper functions.
 * @author Dennis Quan
 */
public final class Utilities {

    static org.apache.log4j.Logger s_logger = org.apache.log4j.Logger.getLogger(Utilities.class);

    private static Random r = new Random();

    private static final Resource[] wildcards = new Resource[100];

    static {
        for (int i = 0; i < 100; i++) {
            wildcards[i] = new Resource(Constants.s_wildcard_namespace + i);
        }
    }

    public static final Resource[] xvals = generateWildcardResourceArray(1);

    public static final Resource[] xyvals = generateWildcardResourceArray(2);

    public static final Resource x = xyvals[0];

    public static final Resource y = xyvals[1];

    public static Double parseDouble(String str) {
        Double retVal = null;
        try {
            retVal = Double.valueOf(str);
        } catch (NumberFormatException e) {
        }
        return retVal;
    }

    public static String generateUniqueIdentifier() {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 15; i++) {
            int n = r.nextInt();
            n = (n < 0) ? -n : n;
            sb.append("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(n % 62));
        }
        return sb.toString();
    }

    public static Resource generateUniqueResource() {
        return new Resource("urn:" + generateUniqueIdentifier());
    }

    public static Resource generateUnknownResource() {
        return new Resource("urn:unknown:" + generateUniqueIdentifier());
    }

    /** generates the ith wildcard Resource, starting from zero. */
    public static Resource generateWildcardResource(int i) {
        return wildcards[i];
    }

    /** Generates an array of WildcardResources of length
     *  <code>c</code>. The wildcard at index <code>i-1</code> is
     *  identical to that generated by
     *  <code>generateWildcardResource(i) </code>. */
    public static Resource[] generateWildcardResourceArray(int c) {
        Resource[] a = new Resource[c];
        System.arraycopy(wildcards, 1, a, 0, c);
        return a;
    }

    /** 
	 * Encodes a list of Resources as a Literal.
	 */
    public static Literal encodeResourceList(List l) {
        Iterator i = l.iterator();
        StringBuffer sb = new StringBuffer();
        while (i.hasNext()) {
            Resource res = (Resource) i.next();
            sb.append(res.getURI());
            sb.append("\n");
        }
        return new Literal(sb.toString());
    }

    /**
	 * Decodes a string into a list of Resources.
	 */
    public static List decodeResourceList(String s) {
        BufferedReader br = new BufferedReader(new StringReader(s));
        List l = new ArrayList();
        String s0;
        try {
            while ((s0 = br.readLine()) != null) {
                s0 = s0.trim();
                if (s0.length() > 0) {
                    l.add(new Resource(s0));
                }
            }
        } catch (IOException ioe) {
        }
        return l;
    }

    /** Removes all references to <code>a</code> in <code>rdf</code>. */
    public static void shred(Resource a, IRDFContainer rdf) throws RDFException {
        rdf.remove(new Statement(a, x, y), xyvals);
        rdf.remove(new Statement(x, a, y), xyvals);
        rdf.remove(new Statement(x, y, a), xyvals);
    }

    /** Removes all statements in <code>statements</code> from <code>target</code> */
    public static void removeStatements(IRDFContainer target, IRDFContainer statements) throws RDFException {
        Iterator i = statements.iterator();
        while (i.hasNext()) {
            Statement s = (Statement) i.next();
            target.remove(s, new Resource[] {});
        }
    }

    public static Resource[] combineResourceArrays(Resource[] r1, Resource[] r2) {
        Set s = new HashSet();
        for (int i = 0; i < r1.length; i++) {
            s.add(r1[i]);
        }
        for (int i = 0; i < r2.length; i++) {
            s.add(r2[i]);
        }
        Resource[] r3 = new Resource[s.size()];
        s.toArray(r3);
        return r3;
    }

    public static boolean containsResource(Resource[] pool, RDFNode rdfn) {
        if (!(rdfn instanceof Resource)) {
            return false;
        }
        Resource res = (Resource) rdfn;
        for (int i = 0; i < pool.length; i++) {
            Resource r2 = pool[i];
            if (r2 == null) {
                if (res == null) {
                    return true;
                }
            } else if (r2.equals(res)) {
                return true;
            }
        }
        return false;
    }

    public static boolean containsRDFNode(RDFNode[] pool, RDFNode rdfn) {
        for (int i = 0; i < pool.length; i++) {
            RDFNode r2 = pool[i];
            if (r2 == null) {
                if (rdfn == null) {
                    return true;
                }
            } else if (r2.equals(rdfn)) {
                return true;
            }
        }
        return false;
    }

    public static int indexOfResource(Resource[] pool, RDFNode rdfn) {
        if (!(rdfn instanceof Resource)) {
            return -1;
        }
        Resource res = (Resource) rdfn;
        for (int i = 0; i < pool.length; i++) {
            Resource r2 = pool[i];
            if (r2 == null) {
                if (res == null) {
                    return i;
                }
            } else if (r2.equals(res)) {
                return i;
            }
        }
        return -1;
    }

    /**
	 * XML encodes the given string. 
	 */
    public static String xmlEncode(String s) {
        StringBuffer str = new StringBuffer();
        int len = (s != null) ? s.length() : 0;
        for (int i = 0; i < len; i++) {
            char ch = s.charAt(i);
            switch(ch) {
                case '<':
                    str.append("&lt;");
                    break;
                case '>':
                    str.append("&gt;");
                    break;
                case '&':
                    str.append("&amp;");
                    break;
                case '"':
                    str.append("&quot;");
                    break;
                case '\'':
                    str.append("&apos;");
                    break;
                case '\r':
                case '\n':
                    if (false) {
                        str.append("&#");
                        str.append(Integer.toString(ch));
                        str.append(';');
                        break;
                    }
                default:
                    str.append(ch);
            }
        }
        return str.toString();
    }

    /**
	 * XML decodes the given string. 
	 */
    public static String xmlDecode(String s) {
        StringBuffer str = new StringBuffer();
        int len = (s != null) ? s.length() : 0;
        for (int i = 0; i < len; i++) {
            char ch = s.charAt(i);
            if (ch != '&') {
                str.append(ch);
            } else {
                int lenLeft = len - i;
                if (lenLeft > 10) {
                    lenLeft = 10;
                }
                String str2 = s.substring(i + 1, i + lenLeft);
                int toSkip = 0;
                if (str2.startsWith("lt;")) {
                    toSkip = 3;
                    str.append('<');
                } else if (str2.startsWith("gt;")) {
                    toSkip = 3;
                    str.append('>');
                } else if (str2.startsWith("amp;")) {
                    toSkip = 4;
                    str.append('&');
                } else if (str2.startsWith("quot;")) {
                    toSkip = 5;
                    str.append('\"');
                } else if (str2.startsWith("apos;")) {
                    toSkip = 5;
                    str.append('\'');
                } else if (str2.startsWith("#")) {
                    int j = str2.indexOf(';');
                    if (j != -1) {
                        try {
                            char ch2 = (char) Integer.parseInt(str2.substring(1, j));
                            str.append(ch2);
                            toSkip = j + 1;
                        } catch (Exception e) {
                        }
                    }
                }
                if (toSkip > 0) {
                    i += toSkip;
                } else {
                    str.append(ch);
                }
            }
        }
        return str.toString();
    }

    public static void uninstallPackage(Resource res, IRDFContainer source) throws RDFException {
        Resource[] a = getResourceProperties(res, Constants.s_haystack_packageStatement, source);
        for (int i = 0; i < a.length; i++) {
            Statement s = source.getStatement(a[i]);
            if (s != null) {
                source.remove(s, new Resource[] {});
                source.remove(new Statement(res, Constants.s_haystack_packageStatement, a[i]), new Resource[] {});
            }
        }
        source.remove(new Statement(res, Constants.s_rdf_type, Constants.s_haystack_Package), new Resource[] {});
    }

    public static Class loadClass(Resource res, IRDFContainer source) throws Exception {
        if (res == null) {
            s_logger.error("loadClass called with null");
            return null;
        }
        Resource resClass = Utilities.getResourceProperty(res, Constants.s_haystack_javaImplementation, source);
        if (resClass == null) {
            s_logger.error("loadClass found no javaImplementation for " + res);
            return null;
        }
        String className = Utilities.getLiteralProperty(resClass, Constants.s_haystack_className, source);
        String pluginName = Utilities.getLiteralProperty(res, Constants.s_haystack_pluginName, source);
        Class result = (pluginName == null ? CoreLoader.loadClass(className) : CoreLoader.loadClass(className, pluginName));
        if (result == null) s_logger.error("Failed to load class " + className + (pluginName == null ? "" : " from plugin " + pluginName));
        return result;
    }

    /**
	 * Converts the contents of <code>cont</code> to a
	 * <code>String</code> of XML RDF.
	 */
    public static String generateRDF(IRDFContainer cont) throws RDFException {
        try {
            StringWriter sw = new StringWriter();
            generateRDF(cont, sw);
            return sw.getBuffer().toString();
        } catch (IOException ioe) {
            return null;
        }
    }

    /**
	 * Writes the contents of <code>cont</code> to the file
	 * <code>outfile</code> as XML RDF. 
	 * @return <code>true</code> if the write was successful, false otherwise.
	 */
    public static void generateRDF(IRDFContainer cont, Writer out) throws IOException, RDFException {
        try {
            OutputFormat of = new OutputFormat();
            of.setPreserveSpace(true);
            XMLSerializer xmls = new XMLSerializer(out, of);
            xmls.startDocument();
            xmls.startPrefixMapping("rdf", Constants.s_rdf_namespace);
            AttributesImpl ai = new AttributesImpl();
            xmls.startElement(Constants.s_rdf_namespace, "RDF", "", ai);
            Iterator i = cont.iterator();
            while (i.hasNext()) {
                Statement s = (Statement) i.next();
                s.generateRDF(xmls);
            }
            xmls.endElement(Constants.s_rdf_namespace, "RDF", "");
            xmls.endDocument();
        } catch (SAXException e) {
            throw new RDFException("Unknown XML format exception", e);
        }
    }

    public static boolean generateRDF(IRDFContainer cont, File outfile) {
        try {
            Writer out = new BufferedWriter(new FileWriter(outfile));
            generateRDF(cont, out);
            out.flush();
            out.close();
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public static String generateN3(IRDFContainer cont) throws RDFException {
        StringBuffer sb = new StringBuffer();
        Iterator i = cont.iterator();
        while (i.hasNext()) {
            Statement s = (Statement) i.next();
            sb.append(s.generateN3());
            sb.append("\n");
        }
        return sb.toString();
    }

    public static void generateN3(IRDFContainer cont, Writer w) throws RDFException, IOException {
        Iterator i = cont.iterator();
        while (i.hasNext()) {
            Statement s = (Statement) i.next();
            w.write(s.generateN3());
            w.write("\n");
        }
    }

    public static void generateAdenine(IRDFContainer cont, Writer w) throws RDFException, IOException {
        Iterator i = cont.iterator();
        w.write("add {\n");
        while (i.hasNext()) {
            Statement s = (Statement) i.next();
            w.write(s.generateAdenine());
            w.write("\n");
        }
        w.write("}\n");
    }

    /**
	 * Imports RDF into the specified RDF container.
	 */
    public static void parseRDF(URL url, IRDFContainer sink) throws RDFException {
        try {
            ARP arp = new ARP();
            arp.setStatementHandler(new StatementHandlerImpl(sink));
            InputStream is = url.openStream();
            arp.load(is, url.toExternalForm());
            is.close();
        } catch (IOException ioe) {
            throw new RDFException("I/O error.", ioe);
        } catch (org.xml.sax.SAXException saxe) {
            throw new RDFException("Malformed RDF.", saxe);
        }
    }

    public static void parseRDF(InputStream is, IRDFContainer sink) throws RDFException {
        try {
            ARP arp = new ARP();
            arp.setStatementHandler(new StatementHandlerImpl(sink));
            arp.load(is);
            is.close();
        } catch (IOException ioe) {
            throw new RDFException("I/O error.", ioe);
        } catch (org.xml.sax.SAXException saxe) {
            throw new RDFException("Malformed RDF.", saxe);
        } catch (Exception e) {
            throw new RDFException("Unexpected exception.", e);
        }
    }

    public static void parseRDF(String rdf, IRDFContainer sink) throws RDFException {
        try {
            ARP arp = new ARP();
            arp.setStatementHandler(new StatementHandlerImpl(sink));
            arp.load(new StringReader(rdf));
        } catch (IOException ioe) {
            throw new RDFException("I/O error.", ioe);
        } catch (org.xml.sax.SAXException saxe) {
            throw new RDFException("Malformed RDF.", saxe);
        }
    }

    public static void parseN3(String n3, IRDFContainer sink) throws RDFException {
        try {
            IN3Engine n3e = (IN3Engine) CoreLoader.loadClass("edu.mit.lcs.haystack.jython.notation3$N3Engine").newInstance();
            ARP arp = new ARP();
            arp.setStatementHandler(new StatementHandlerImpl(sink));
            String str = n3e.N3ToRDF(n3, "urn:" + generateUniqueIdentifier());
            arp.load(new StringReader(str));
        } catch (IOException ioe) {
            throw new RDFException("I/O error.", ioe);
        } catch (org.xml.sax.SAXException saxe) {
            throw new RDFException("Malformed RDF.", saxe);
        } catch (Exception e) {
            throw new RDFException("Unknown error.", e);
        }
    }

    public static void parseN3(InputStream is, IRDFContainer sink) throws RDFException {
        try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            String str;
            StringBuffer sb = new StringBuffer();
            while ((str = reader.readLine()) != null) {
                sb.append(str + "\n");
            }
            parseN3(sb.toString(), sink);
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }

    public static RDFNode getIndirectProperty(Resource subject, Resource predicate, Resource predicate2, IRDFContainer container) {
        try {
            RDFNode[] rdfn = container.queryExtract(new Statement[] { new Statement(subject, predicate, generateWildcardResource(1)), new Statement(generateWildcardResource(1), predicate2, generateWildcardResource(2)) }, new Resource[] { generateWildcardResource(2) }, new Resource[] { generateWildcardResource(1) });
            if (rdfn != null) {
                return rdfn[0];
            }
        } catch (Exception e) {
            return null;
        }
        return null;
    }

    public static RDFNode getIndirectProperty(Resource subject, Resource predicate, Resource predicate2, Resource predicate3, IRDFContainer container) {
        try {
            RDFNode[] rdfn = container.queryExtract(new Statement[] { new Statement(subject, predicate, generateWildcardResource(3)), new Statement(generateWildcardResource(3), predicate2, generateWildcardResource(2)), new Statement(generateWildcardResource(2), predicate3, generateWildcardResource(1)) }, generateWildcardResourceArray(1), generateWildcardResourceArray(3));
            if (rdfn != null) {
                return rdfn[0];
            }
        } catch (Exception e) {
            return null;
        }
        return null;
    }

    public static Set getIndirectProperties(Resource subject, Resource predicate, Resource predicate2, IRDFContainer container) {
        try {
            Set s = container.query(new Statement[] { new Statement(subject, predicate, generateWildcardResource(1)), new Statement(generateWildcardResource(1), predicate2, generateWildcardResource(2)) }, new Resource[] { generateWildcardResource(2) }, new Resource[] { generateWildcardResource(1) });
            return extractFirstItems(s);
        } catch (Exception e) {
            return null;
        }
    }

    public static Resource getResourcePropertyOfType(Resource subject, Resource predicate, Resource type, IRDFContainer container) {
        try {
            RDFNode[] rdfn = container.queryExtract(new Statement[] { new Statement(subject, predicate, generateWildcardResource(1)), new Statement(generateWildcardResource(1), Constants.s_rdf_type, type) }, new Resource[] { generateWildcardResource(1) }, new Resource[] { generateWildcardResource(1) });
            if (rdfn != null) {
                return (Resource) rdfn[0];
            }
        } catch (Exception e) {
            return null;
        }
        return null;
    }

    public static String getLiteralProperty(Resource subject, Resource predicate, IRDFContainer container) {
        try {
            return ((Literal) container.extract(subject, predicate, null)).getContent();
        } catch (Exception e) {
            return null;
        }
    }

    public static boolean checkBooleanProperty(Resource subject, Resource predicate, IRDFContainer container) {
        return checkBooleanProperty(subject, predicate, container, false);
    }

    public static boolean checkBooleanProperty(Resource subject, Resource predicate, IRDFContainer container, boolean defaultValue) {
        try {
            return "true".equals(((Literal) container.extract(subject, predicate, null)).getContent());
        } catch (Exception e) {
            return defaultValue;
        }
    }

    public static String getLabel(Resource res, IRDFContainer container) {
        String str = getLiteralProperty(res, Constants.s_rdfs_label, container);
        if (str != null) {
            return str;
        } else {
            str = getLiteralProperty(res, Constants.s_dc_title, container);
            if (str != null) {
                return str;
            } else {
                return res.getURI();
            }
        }
    }

    public static RDFNode getProperty(Resource subject, Resource predicate, IRDFContainer container) {
        try {
            return container.extract(subject, predicate, null);
        } catch (Exception e) {
            return null;
        }
    }

    public static Resource getResourceProperty(Resource subject, Resource predicate, IRDFContainer container) {
        try {
            return (Resource) container.extract(subject, predicate, null);
        } catch (Exception e) {
            return null;
        }
    }

    public static Resource getResourceSubject(Resource predicate, Resource object, IRDFContainer container) {
        try {
            return (Resource) container.extract(null, predicate, object);
        } catch (Exception e) {
            return null;
        }
    }

    public static Resource[] getResourceProperties(Resource subject, Resource predicate, IRDFContainer container) {
        try {
            Set results = container.query(new Statement[] { new Statement(subject, predicate, Utilities.generateWildcardResource(1)) }, Utilities.generateWildcardResourceArray(1), Utilities.generateWildcardResourceArray(1));
            Resource[] a = new Resource[results.size()];
            Iterator i = results.iterator();
            int j = 0;
            while (i.hasNext()) {
                try {
                    a[j++] = (Resource) ((RDFNode[]) i.next())[0];
                } catch (Exception e) {
                }
            }
            return a;
        } catch (Exception e) {
            return new Resource[0];
        }
    }

    public static RDFNode[] getProperties(Resource subject, Resource predicate, IRDFContainer container) {
        try {
            Set results = container.query(new Statement[] { new Statement(subject, predicate, Utilities.generateWildcardResource(1)) }, new Resource[] { Utilities.generateWildcardResource(1) }, new Resource[] {});
            RDFNode[] a = new RDFNode[results.size()];
            Iterator i = results.iterator();
            int j = 0;
            while (i.hasNext()) {
                a[j++] = ((RDFNode[]) i.next())[0];
            }
            return a;
        } catch (Exception e) {
            return new RDFNode[0];
        }
    }

    public static Resource[] getResourceSubjects(Resource predicate, RDFNode object, IRDFContainer container) {
        try {
            Set results = container.query(new Statement[] { new Statement(Utilities.generateWildcardResource(1), predicate, object) }, new Resource[] { Utilities.generateWildcardResource(1) }, new Resource[] {});
            Resource[] a = new Resource[results.size()];
            Iterator i = results.iterator();
            int j = 0;
            while (i.hasNext()) {
                try {
                    a[j++] = (Resource) ((RDFNode[]) i.next())[0];
                } catch (Exception e) {
                }
            }
            return a;
        } catch (Exception e) {
            return new Resource[0];
        }
    }

    public static boolean isType(Resource subject, Resource type, IRDFContainer container) {
        try {
            boolean b = container.contains(new Statement(subject, Constants.s_rdf_type, type));
            return b;
        } catch (Exception e) {
            return false;
        }
    }

    public static boolean isSubType(Resource subject, Resource type, IRDFContainer container) {
        try {
            boolean b = container.queryExtract(new Statement[] { new Statement(subject, Constants.s_rdf_type, generateWildcardResource(1)), new Statement(generateWildcardResource(1), Constants.s_rdfs_subClassOf, type) }, generateWildcardResourceArray(1), generateWildcardResourceArray(1)) != null;
            return b;
        } catch (Exception e) {
            return false;
        }
    }

    /** Returns all Resources in the store with <a
         href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">rdf
         type</a> <code>type</code>. */
    public static Set getObjects(IRDFContainer store, Resource type) throws RDFException {
        Statement s = new Statement(x, Constants.s_rdf_type, type);
        Iterator qresults = store.query(s, xvals).iterator();
        Set results = new HashSet();
        while (qresults.hasNext()) results.add((Resource) ((RDFNode[]) qresults.next())[0]);
        return results;
    }

    /** Returns all Properties of the specified Resource as a Set of
	 *  arrays of type <code>RDFNode[2]</code>. */
    public static Set getProperties(Resource resource, IRDFContainer store) {
        try {
            Statement s = new Statement(resource, x, y);
            return store.query(s, xyvals);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /** Returns a set of Resources that are members of a 
        <a href="http://haystack.lcs.mit.edu/schemata/haystack#Collection">
        Haystack Collection</a>. */
    public static Set getMembers(IRDFContainer store, Resource collection) throws RDFException {
        Statement[] s = { new Statement(collection, Constants.s_haystack_member, x) };
        Iterator qresults = store.query(s, xvals, xvals).iterator();
        Set results = new HashSet();
        while (qresults.hasNext()) results.add((Resource) ((RDFNode[]) qresults.next())[0]);
        return results;
    }

    /** Returns a set of Resources that are members of a 
        <a href="http://haystack.lcs.mit.edu/schemata/haystack#Collection">
        Haystack Collection</a> and have 
        <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">rdf type</a>
         <code>type</code>. */
    public static Set getMembers(IRDFContainer store, Resource collection, Resource type) throws RDFException {
        Statement[] s = { new Statement(collection, Constants.s_haystack_member, x), new Statement(x, Constants.s_rdf_type, type) };
        Iterator qresults = store.query(s, xvals, xvals).iterator();
        Set results = new HashSet();
        while (qresults.hasNext()) results.add((Resource) ((RDFNode[]) qresults.next())[0]);
        return results;
    }

    /**
	 * Extracts the namespace prefix out of a URI.
	 */
    public static String guessNamespace(String uri) {
        int l = getNamespaceEnd(uri);
        return l > 1 ? uri.substring(0, l) : "";
    }

    /**
	 * Delivers the name out of the URI (without the namespace prefix).
	 */
    public static String guessName(String uri) {
        return uri.substring(getNamespaceEnd(uri));
    }

    /**
	 * Returns the position of the namespace end.
	 */
    static int getNamespaceEnd(String uri) {
        int l = uri.length() - 1;
        do {
            char c = uri.charAt(l);
            if (c == '#' || c == ':' || c == '/') {
                break;
            }
            l--;
        } while (l >= 0);
        l++;
        return l;
    }

    /**
	 * Returns the number of statements in an IRDFContainer.  Returns
	 * -1 in the event of an RDFException.
	 */
    public static int getSize(IRDFContainer source) {
        Resource[] vars = { wildcards[0], wildcards[1], wildcards[2] };
        Statement query = new Statement(wildcards[0], wildcards[1], wildcards[2]);
        try {
            return source.query(new Statement[] { query }, vars, vars).size();
        } catch (RDFException e) {
            return -1;
        }
    }

    /**
	 * Prints all the statements in an IRDFContainer to System.out,
	 * or any resulting RDFExceptions.
	 */
    public static void printStatements(IRDFContainer source) {
        Resource[] vars = { wildcards[0], wildcards[1], wildcards[2] };
        Statement query = new Statement(wildcards[0], wildcards[1], wildcards[2]);
        try {
            Set results = source.query(new Statement[] { query }, vars, vars);
            Iterator iter = results.iterator();
            while (iter.hasNext()) {
                RDFNode[] vals = (RDFNode[]) iter.next();
                System.out.println(new Statement((Resource) vals[0], (Resource) vals[1], vals[2]));
            }
        } catch (RDFException e) {
            System.out.println(e);
        }
    }

    public static void printData(Resource r, IRDFContainer source) {
        if (r == null) {
            System.err.println("Resource is null");
        } else {
            try {
                System.err.println("Resource " + r);
                Set set = source.query(new Statement(r, Utilities.generateWildcardResource(1), Utilities.generateWildcardResource(2)), Utilities.generateWildcardResourceArray(2));
                Iterator i = set.iterator();
                while (i.hasNext()) {
                    RDFNode[] nodes = (RDFNode[]) i.next();
                    System.err.println("         " + nodes[0] + " : " + nodes[1]);
                }
            } catch (RDFException e1) {
                e1.printStackTrace();
            }
        }
    }

    static final SimpleDateFormat s_xsdDateFormatter = new SimpleDateFormat("yyyy-MM-dd");

    static final SimpleDateFormat s_standardDateTimeFormatter = new SimpleDateFormat("EEE MMM d HH:mm:ss z yyyy");

    static final SimpleDateFormat s_standardDateFormatter = new SimpleDateFormat("EEE MMM d yyyy");

    static final SimpleDateFormat s_standardTimeFormatter = new SimpleDateFormat("HH:mm:ss");

    static {
        s_standardDateTimeFormatter.setLenient(true);
        s_standardDateFormatter.setLenient(true);
        s_standardTimeFormatter.setLenient(true);
    }

    public static Date parseDateTime(Literal l) {
        return parseDateTime(l.getContent());
    }

    public static Date parseDate(Literal l) {
        return parseDate(l.getContent());
    }

    public static Date parseTime(Literal l) {
        return parseTime(l.getContent());
    }

    public static Date parseDateTime(String s) {
        try {
            return s_standardDateTimeFormatter.parse(s);
        } catch (ParseException e) {
            try {
                return DateFormat.getDateTimeInstance().parse(s);
            } catch (ParseException e2) {
                try {
                    return new Date(Date.parse(s));
                } catch (Exception e3) {
                    int i = s.indexOf('T');
                    if (i != -1) {
                        String datePart = s.substring(0, i);
                        String timePart = s.substring(i + 1);
                        Time time = new Time(timePart);
                        try {
                            Date date = s_xsdDateFormatter.parse(datePart);
                            Calendar c = time.getAsCalendar();
                            Calendar c2 = Calendar.getInstance();
                            c2.setTime(date);
                            c.set(Calendar.DATE, c2.get(Calendar.DATE));
                            c.set(Calendar.MONTH, c2.get(Calendar.MONTH));
                            c.set(Calendar.YEAR, c2.get(Calendar.YEAR));
                            return c.getTime();
                        } catch (ParseException e1) {
                            return null;
                        }
                    }
                    return null;
                }
            }
        }
    }

    public static Date parseTime(String s) {
        try {
            return s_standardTimeFormatter.parse(s);
        } catch (ParseException e) {
            try {
                return DateFormat.getTimeInstance().parse(s);
            } catch (ParseException e2) {
                return null;
            }
        }
    }

    public static final TimeZone s_timeZone = TimeZone.getDefault();

    public static Date parseDate(String s) {
        Date d;
        try {
            d = s_standardDateFormatter.parse(s);
        } catch (ParseException e) {
            try {
                d = DateFormat.getTimeInstance().parse(s);
            } catch (ParseException e2) {
                return null;
            }
        }
        Calendar c = Calendar.getInstance(s_timeZone);
        c.setTime(d);
        c.set(Calendar.SECOND, 0);
        c.set(Calendar.MILLISECOND, 0);
        c.set(Calendar.MINUTE, 0);
        c.set(Calendar.HOUR_OF_DAY, 0);
        return c.getTime();
    }

    public static Literal generateDateTime(Date d) {
        return new Literal(s_standardDateTimeFormatter.format(d));
    }

    public static Literal generateDate(Date d) {
        return new Literal(s_standardDateFormatter.format(d));
    }

    public static Literal generateDate(Calendar d) {
        return new Literal(s_standardDateFormatter.format(d.getTime()));
    }

    public static Literal generateTime(Date d) {
        return new Literal(s_standardTimeFormatter.format(d));
    }

    public static String toUpperCaseFirst(String inStr) {
        char[] inCh = inStr.toCharArray();
        boolean bUpCaseNextChar = true;
        for (int i = 0; i < inCh.length; i++) {
            if (Character.isWhitespace(inCh[i])) {
                bUpCaseNextChar = true;
            } else if (bUpCaseNextChar) {
                inCh[i] = Character.toUpperCase(inCh[i]);
                bUpCaseNextChar = false;
            }
        }
        return new String(inCh);
    }

    /**
	 * Computes the MD5 message digest of an <code>InputStream</code>
	 * and returns it as a hexidecimal String. The caller is responsible
	 * for calling the <code>close()</code> method of
	 * <code>message</code>. 
	 * @return A <code>String</code> that is 32
	 * characters long consisting of digits and the lower case alphabetic characters <code>a-f</code>.
	 */
    public static String computeMD5(java.io.InputStream message) throws IOException {
        int ch;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        while ((ch = message.read()) != -1) {
            out.write(ch);
        }
        out.close();
        return computeMD5(out.toByteArray());
    }

    /**
	 * Computes the MD5 message digest of a <code>String</code> and
	 * returns it as a hexidecimal String. Since Java strings are
	 * Unicode characters, the string is first encoded into UTF-8, which
	 * defines a unique octet sequence for the string. The returned
	 * <code>String</code> is 32 characters long and alphabetic
	 * characters <code>a-f</code> are lower-case.
	 */
    public static String computeMD5(java.lang.String message) {
        try {
            return computeMD5(message.getBytes("UTF8"));
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
	 * Computes the MD5 message digest of a <code>Byte[]</code> and
	 * returns it as a hexidecimal String. The returned
	 * <code>String</code> is 32 characters long and alphabetic
	 * characters <code>a-f</code> are lower-case.
	 */
    public static String computeMD5(byte[] message) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.reset();
            md5.update(message);
            byte[] digest = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < digest.length; i++) {
                if ((0xff & digest[i]) < 0x10) sb.append('0');
                sb.append(Integer.toHexString(0xff & digest[i]));
            }
            return (sb.toString());
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }

    /** Converts a string into a canonical form for the purpose
	 * embedding into URIs.  Permissible characters are defined in
	 * section 2.2 of RFC 2141,
	 * <a href="http://www.ietf.org/rfc/rfc2141.txt">URN Syntax</a> */
    public static String toURI(String input) {
        try {
            byte[] bytes = input.getBytes("UTF8");
            StringBuffer sb = new StringBuffer(2 * input.length());
            for (int i = 0; i < bytes.length; i++) {
                byte c = bytes[i];
                if ((('a' <= c) && (c <= 'z')) || (('@' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= ';')) || (('\'' <= c) && (c <= '.')) || (c == '$') || (c == '=') || (c == '_') || (c == '!')) {
                    sb.append((char) c);
                } else {
                    sb.append(((0xff & bytes[i]) < 0x10) ? "%0" : "%");
                    sb.append(Integer.toHexString(0xff & bytes[i]).toUpperCase());
                }
            }
            return sb.toString();
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /** Converts a string into a canonical form for the purpose
	 * embedding into RDF Literals.  Permissible characters are valid
	 * XML characters, which is everything greater than   in addition 
	 * to: 	 or "\t", 
 or "\n", and  or "\r". */
    public static String toLiteral(String input) {
        boolean good = true;
        int len = input.length();
        for (int i = 0; i < len; i++) {
            int c = (int) input.charAt(i);
            if (c < 0x0020 && c != 0x0009 && c != 0x000a && c != 0x000d) good = false;
        }
        if (good) return input;
        StringBuffer sb = new StringBuffer(len);
        for (int i = 0; i < len; i++) {
            char c = input.charAt(i);
            if (c >= 0x0020 || c == 0x0009 || c == 0x000a || c == 0x000d) sb.append(c);
        }
        return sb.toString();
    }

    public static Resource pathToURI(String path, IRDFContainer source) {
        if (path.length() >= 3 && path.charAt(1) == ':' && (path.charAt(2) == '\\' || path.charAt(2) == '/')) {
            String url = getURLFromShortcutFile(path, source);
            if (url == null) {
                url = "file://localhost/" + path.replace('\\', '/');
            }
            addTitle(url, path, source);
            return new Resource(url);
        } else if (path.startsWith("\\\\")) {
            String url = getURLFromShortcutFile(path, source);
            if (url == null) {
                url = "file:" + path.replace('\\', '/');
            }
            addTitle(url, path, source);
            return new Resource(url);
        } else {
            return new Resource(path);
        }
    }

    public static String getURLFromShortcutFile(String filePath, IRDFContainer source) {
        if (!filePath.endsWith(".url")) {
            return null;
        }
        String result = null;
        try {
            FileInputStream fis = new FileInputStream(filePath);
            InputStreamReader isr = new InputStreamReader(fis);
            BufferedReader br = new BufferedReader(isr);
            try {
                while (true) {
                    String s = br.readLine();
                    if (s.startsWith("URL=")) {
                        result = s.substring(4);
                        break;
                    }
                }
            } catch (IOException e) {
            }
            br.close();
            isr.close();
            fis.close();
        } catch (Exception e) {
        }
        if (result != null) {
            addTitle(result, filePath, source);
        }
        return result;
    }

    protected static void addTitle(String uri, String filePath, IRDFContainer source) {
        int start = filePath.lastIndexOf('\\');
        start = start >= 0 ? start : filePath.lastIndexOf('/');
        start = start >= 0 ? start + 1 : 0;
        int end = filePath.lastIndexOf('.');
        end = end >= 0 ? end : filePath.length();
        String title = filePath.substring(start, end);
        try {
            if (source.extract(new Resource(uri), Constants.s_dc_title, null) == null) {
                source.add(new Statement(new Resource(uri), Constants.s_dc_title, new Literal(title)));
            }
        } catch (RDFException e) {
        }
    }

    public static Set extractFirstItems(Set tuples) {
        Set results = new HashSet();
        Iterator i = tuples.iterator();
        while (i.hasNext()) {
            Object tuple = i.next();
            if (tuple instanceof Object[]) {
                if (((Object[]) tuple).length > 0) {
                    results.add(((Object[]) tuple)[0]);
                }
            } else {
                results.add(tuple);
            }
        }
        return results;
    }

    public static Set makeSetUnique(Set inp) {
        Set results = new HashSet();
        Iterator inpIt = inp.iterator();
        while (inpIt.hasNext()) {
            RDFNode[] inpTuple = (RDFNode[]) inpIt.next();
            boolean addTuple = true;
            Iterator resIt = results.iterator();
            while (resIt.hasNext()) {
                RDFNode[] resTuple = (RDFNode[]) resIt.next();
                for (int ndx = 0; ndx < resTuple.length; ndx++) {
                    if (!resTuple[ndx].equals(inpTuple[ndx])) {
                        break;
                    }
                    if (ndx == resTuple.length - 1) {
                        addTuple = false;
                    }
                }
            }
            if (addTuple) {
                results.add(inpTuple);
            }
        }
        return results;
    }

    public static int getUniqueResourceCount(Set tuples, int existNdx) {
        HashSet uniqueSet = new HashSet(tuples.size());
        Iterator inpIt = tuples.iterator();
        while (inpIt.hasNext()) {
            RDFNode[] tuple = (RDFNode[]) inpIt.next();
            uniqueSet.add(tuple[existNdx]);
        }
        return uniqueSet.size();
    }

    public static HashMap getTypeHierarchy(Set types, IRDFContainer source) {
        HashMap map = new HashMap();
        HashSet subTypes = new HashSet();
        Iterator i = types.iterator();
        while (i.hasNext()) {
            Resource type = (Resource) i.next();
            Resource[] superTypes = Utilities.getResourceProperties(type, Constants.s_rdfs_subClassOf, source);
            for (int j = 0; j < superTypes.length; j++) {
                if (types.contains(superTypes[j])) {
                    HashSet currentSubtypes = (HashSet) map.get(superTypes[j]);
                    if (currentSubtypes == null) {
                        currentSubtypes = new HashSet();
                        map.put(superTypes[j], currentSubtypes);
                    }
                    currentSubtypes.add(type);
                    subTypes.add(type);
                }
            }
        }
        types.removeAll(subTypes);
        return map;
    }

    public static List getTypePriorityList(Resource[] types, IRDFContainer source) {
        HashMap subTypesMemo = new HashMap();
        Collection currentTypes = Arrays.asList(types);
        HashSet baseTypes = new HashSet();
        baseTypes.addAll(currentTypes);
        while (subTypesMemo.size() < 100 && currentTypes.size() > 0) {
            HashSet newCurrentTypes = new HashSet();
            Iterator i = currentTypes.iterator();
            while (i.hasNext()) {
                Resource type = (Resource) i.next();
                if (subTypesMemo.containsKey(type)) {
                    if (baseTypes.contains(type)) {
                        baseTypes.remove(type);
                    }
                } else {
                    List subTypes = Arrays.asList(Utilities.getResourceProperties(type, Constants.s_rdfs_subClassOf, source));
                    subTypesMemo.put(type, subTypes);
                    newCurrentTypes.addAll(subTypes);
                }
            }
            currentTypes = newCurrentTypes;
        }
        LinkedList results = new LinkedList();
        currentTypes = baseTypes;
        while (currentTypes.size() > 0) {
            Iterator i = currentTypes.iterator();
            HashSet newCurrentTypes = new HashSet();
            while (i.hasNext()) {
                Resource type = (Resource) i.next();
                Collection subTypes = (Collection) subTypesMemo.get(type);
                if (subTypes != null) {
                    newCurrentTypes.addAll(subTypes);
                }
            }
            results.addAll(currentTypes);
            currentTypes = newCurrentTypes;
        }
        if (!results.contains(Constants.s_daml_Thing)) {
            results.add(Constants.s_daml_Thing);
        }
        return results;
    }

    public static void copyBasicInformation(Resource subject, IRDFContainer source, IRDFContainer target) throws RDFException {
        RDFNode[] values = getProperties(subject, Constants.s_dc_title, source);
        for (int i = 0; i < values.length; i++) {
            target.add(new Statement(subject, Constants.s_dc_title, values[i]));
        }
        values = getProperties(subject, Constants.s_rdf_type, source);
        for (int i = 0; i < values.length; i++) {
            target.add(new Statement(subject, Constants.s_rdf_type, values[i]));
        }
    }

    public static Set extractInformation(Resource subject, IRDFContainer source, IRDFContainer target) throws RDFException {
        HashSet endNodes = new HashSet();
        HashSet visitedNodes = new HashSet();
        extractInformationHelper(subject, visitedNodes, endNodes, source, target);
        return endNodes;
    }

    static void extractInformationHelper(Resource subject, Set visitedNodes, Set endNodes, IRDFContainer source, IRDFContainer target) throws RDFException {
        if (visitedNodes.contains(subject)) {
            return;
        }
        visitedNodes.add(subject);
        Set results = source.query(new Statement(subject, Utilities.generateWildcardResource(1), Utilities.generateWildcardResource(2)), Utilities.generateWildcardResourceArray(2));
        Iterator i = results.iterator();
        while (i.hasNext()) {
            RDFNode[] datum = (RDFNode[]) i.next();
            if (datum[1] instanceof Resource) {
                Resource obj = (Resource) datum[1];
                Resource pred = (Resource) datum[0];
                if (isType(pred, Constants.s_haystack_ProprietalProperty, source) || isType(pred, Constants.s_haystack_ContainmentProperty, source)) {
                    extractInformationHelper(obj, visitedNodes, endNodes, source, target);
                }
                if (isType(pred, Constants.s_haystack_RelationalProperty, source) && !visitedNodes.contains(obj)) {
                    endNodes.add(obj);
                }
            }
            target.add(new Statement(subject, (Resource) datum[0], datum[1]));
        }
    }

    /**
	 * Extracts a rdf:List and returns the resulting list of resources.
	 * @param rest The first pair of the list
	 * @param container The container of RDF
	 * @return A List containing all resources in the list or null if list structure is invalid
	 */
    public static List extractRDFList(Resource rest, IRDFContainer container) {
        List lst = new LinkedList();
        Resource rdfNil = new Resource(Constants.s_rdf_namespace + "nil"), rdfList = new Resource(Constants.s_rdf_namespace + "List"), rdfFirst = new Resource(Constants.s_rdf_namespace + "first"), rdfRest = new Resource(Constants.s_rdf_namespace + "rest");
        while (!rest.equals(rdfNil)) {
            if (rest == null || !isType(rest, rdfList, container)) return null;
            Resource first = getResourceProperty(rest, rdfFirst, container);
            if (first == null) return null;
            lst.add(first);
            rest = getResourceProperty(rest, rdfRest, container);
        }
        return lst;
    }

    /**
	 * Extracts a daml:List and returns the resulting list of resources.
	 * @param rest The first pair of the list
	 * @param container The container of RDF
	 * @return A List containing all resources in the list or null if list structure is invalid
	 */
    public static List extractDAMLList(Resource rest, IRDFContainer container) {
        List lst = new LinkedList();
        while (!rest.equals(Constants.s_daml_nil)) {
            if (rest == null || !isType(rest, Constants.s_daml_List, container)) return null;
            Resource first = getResourceProperty(rest, Constants.s_daml_first, container);
            if (first == null) return null;
            lst.add(first);
            rest = getResourceProperty(rest, Constants.s_daml_rest, container);
        }
        return lst;
    }

    /**
	 * Extracts a daml:List or rdf:List and returns List of resources.
	 * @param rest First pair of list
	 * @param container RDF container
	 * @return List of resources contained in list or null if invalid input list
	 */
    public static List extractList(Resource rest, IRDFContainer container) {
        if (isType(rest, Constants.s_daml_List, container)) return extractDAMLList(rest, container); else return extractRDFList(rest, container);
    }
}

class StatementHandlerImpl implements StatementHandler {

    IRDFContainer sink;

    String m_unique = Utilities.generateUniqueIdentifier();

    StatementHandlerImpl(IRDFContainer sink) {
        if (sink == null) {
            throw new IllegalArgumentException();
        }
        this.sink = sink;
    }

    Resource translate(AResource res) {
        if (res.isAnonymous()) {
            return new Resource("urn:" + m_unique + ":" + res.getAnonymousID());
        } else {
            return new Resource(res.getURI());
        }
    }

    public void statement(AResource subj, AResource pred, AResource obj) {
        try {
            sink.add(new Statement(translate(subj), translate(pred), translate(obj)));
        } catch (RDFException e) {
        }
    }

    public void statement(AResource subj, AResource pred, ALiteral lit) {
        try {
            sink.add(new Statement(translate(subj), translate(pred), new Literal(Utilities.xmlDecode(lit.toString()))));
        } catch (RDFException e) {
        }
    }
}
