package com.framedobjects.dashwell.utils.webservice;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.axis.types.URI.MalformedURIException;
import org.apache.log4j.Logger;
import org.jcows.model.vc.VCMapper;
import wsl.fw.exception.MdnException;
import wsl.fw.util.Config;
import java.lang.reflect.Method;

/**
 * All functionality that somehow need to interact with {@link java.lang.Class Class} 
 * object are gathered in this class. This means that pretty much everything herein
 * has something to do with <strong>Reflection</strong>.<br/>
 * <code>ClassHelper</code> provides the methods that construct new instances for the
 * classes and methods that we use for invoking the web services. Furthermore it provides
 * the methods for constructing parameter lists that are needed for the operations
 * of the web service.  
 */
public final class ClassHelper {

    private static final Logger LOGGER = Logger.getLogger(ClassHelper.class);

    private URLClassLoader m_jarLoader;

    private TypeMapper m_vcMapper;

    public ClassHelper(URLClassLoader jarLoader) throws MdnException {
        m_jarLoader = jarLoader;
        this.m_vcMapper = TypeMapper.getInstance();
    }

    /**
   * Returns true if the specified {@link java.lang.Class Class} implements 
   * the specified interface.
   * 
   * @param cl the {@link java.lang.Class Class} object.
   * @param toFind the name of the potential Interface.
   * @return true if the specified {@link java.lang.Class Class} implementes the
   *         specified interface, false otherwise. 
   * @throws MdnException
   */
    public boolean hasInterface(Class cl, String toFind) throws MdnException {
        for (Class c : cl.getInterfaces()) try {
            if (c.equals(Class.forName(toFind))) return true;
        } catch (ClassNotFoundException e) {
            throw new MdnException(Config.getProp("error.ClassNotFoundException"), e);
        }
        return false;
    }

    /**
   * Returns true if the {@link java.lang.Class Class} extends the specified superclass.
   * 
   * @param cl the {@link java.lang.Class Class} object.
   * @param toFind the name of the maybe superclass
   * @return true if the specified {@link java.lang.Class Class} extends the
   *         specified class.
   * @throws MdnException
   */
    public boolean hasSuperclass(Class cl, String toFind) throws MdnException {
        Class superclass = cl.getSuperclass();
        while (superclass != null) {
            try {
                if (superclass.equals(Class.forName(toFind))) return true;
            } catch (ClassNotFoundException e) {
                throw new MdnException(Config.getProp("error.ClassNotFoundException"), e);
            }
            cl = superclass;
            superclass = cl.getSuperclass();
        }
        return false;
    }

    /**
   * Returns an array of strings representing the parameter names 
   * (as they appear in the method declaration). The names are being
   * extracted from the method definition imported from the
   * source file of the specified Class. The source files are taken
   * from the jar file generated for the current web service. This means
   * that only classes are supported that belong to the web service itself, i.e.
   * are classes generated by the wsdl2java parser. Additionally we should 
   * support the axis types too as those classes are supported too (besides the
   * standard Java types). But as there are 30 classes each having 2-4
   * constructors we don't support that here (we don't have the sources 
   * available and don't want to have to switch between about 120 cases 
   * in this method).
   * 
   * @param cl the {@link java.lang.Class Class} which contains the specified method.
   * @param methodName a String value, the name of the method.
   * @param paramTypes an array of strings, the names of the 
   *        parameters of the specified method.
   * @return an array of strings containing the parameter names.
   */
    public String[] getParamNames(Class cl, String methodName, String[] paramTypes) throws MdnException {
        LOGGER.debug("Getting Parameter Names of Method '" + methodName + "'...");
        StringBuffer regex = new StringBuffer(".*");
        regex.append(methodName);
        regex.append("\\s*\\(");
        for (String param : paramTypes) {
            regex.append("\\s*");
            regex.append(param.replace("[", "\\[").replace("]", "\\]"));
            regex.append(" ([_\\w]+)\\s*,");
        }
        String[] paramNames = new String[paramTypes.length];
        for (int i = 0; i < paramNames.length; ++i) paramNames[i] = paramTypes[i];
        regex.delete(regex.length() - 1, regex.length());
        regex.append(".*");
        LOGGER.debug("Regex: " + regex + "<");
        Pattern pattern = Pattern.compile(regex.toString(), Pattern.MULTILINE | Pattern.DOTALL);
        String javaFile = cl.getName().replaceAll("\\.", "/") + ".java";
        LOGGER.debug("Javafile: " + javaFile);
        File file = new File(m_jarLoader.getURLs()[0].getFile() + "!/" + javaFile);
        InputStream in = null;
        try {
            URL url = file.toURI().toURL();
            url = new URL("jar", url.getHost(), url.toString());
            URLConnection conn = url.openConnection();
            conn.setDefaultUseCaches(false);
            in = url.openStream();
        } catch (IOException e) {
            return paramNames;
        }
        StringBuffer content = new StringBuffer();
        if (in != null) {
            try {
                byte[] buf = new byte[0xFFFF];
                int len;
                while ((len = in.read(buf)) > 0) {
                    content.append(new String(buf, 0, len));
                }
                in.close();
            } catch (IOException e) {
                throw new MdnException(Config.getProp("error.IOException") + Config.getProp("error.noSuchFileInWSJarfile"), e);
            }
            Matcher matcher = pattern.matcher(content.toString());
            if (matcher.matches()) {
                for (int i = 0; i < paramNames.length; ++i) {
                    paramNames[i] = matcher.group(i + 1);
                    LOGGER.debug("Parameter name: " + matcher.group(i + 1));
                }
                return paramNames;
            }
        }
        return paramNames;
    }

    /**
   * Returns a list containing {@link ParamListItem}s 
   * with the items extracted from a the fields of a class.
   * Returns a list with default values for the request.
   * 
   * @param arguments an array of {@link java.lang.Class Class} objects.
   * @param labels an array of strings.
   * @param values an array of {@link java.lang.Object Object}s.
   * @return a list containing paramListItems.
   * @throws MdnException
   */
    public List<ParamListItem> getParamListFromFields(Class[] arguments, String[] labels, Object[] values) throws MdnException {
        List<ParamListItem> list = new ArrayList<ParamListItem>(values.length);
        for (int i = 0; i < values.length; ++i) {
            ParamListItem param = getParamListItemFromFields(arguments[i], labels[i], values[i]);
            list.add(param);
        }
        return resultParamListItems;
    }

    private List<ParamListItem> resultParamListItems;

    public void restartParamListItems() {
        this.resultParamListItems = new ArrayList<ParamListItem>();
    }

    private List<WebServiceResultRow> rows = new ArrayList<WebServiceResultRow>();

    public List<WebServiceResultRow> getParamListItemsAsRow() {
        return rows;
    }

    public void restartParamListItemsAsRow() {
        this.rows = new ArrayList<WebServiceResultRow>();
    }

    /**
   * Returns a {@link ParamListItem} 
   * with the values extracted from the fields of a class.
   * This methods extracts with <strong>Reflection</strong> all instance
   * fields from the specified {@link java.lang.Class Class} and adds its
   * names and values to the list.
   * 
   * @param cl a {@link java.lang.Class Class} object to be mapped 
   *        to its corresponding <strong>Visual Component</strong> type.
   * @param label the label of the component.
   * @param value the value of the component.
   * @return the new {@link ParamListItem}
   * @throws MdnException
   */
    public ParamListItem getParamListItemFromFieldsOld(Class cl, String label, Object value) throws MdnException {
        boolean isArray = cl.isArray();
        if (isArray) {
            cl = cl.getComponentType();
        }
        Map<String, String> mapping = m_vcMapper.getMapping(cl.getName());
        return null;
    }

    public ParamListItem getParamListItemFromFields(Class cl, String label, Object value) throws MdnException {
        boolean isArray = cl.isArray();
        if (isArray) {
            cl = cl.getComponentType();
        }
        Map<String, String> mapping = m_vcMapper.getMapping(cl.getName());
        if (mapping.get(VCMapper.ELEMENTNAME_ITEMTYPE).equals(VCMapper.ITEMTYPE_FIELD)) {
            ParamListItem param = new ParamListItem(mapping.get(VCMapper.ATTRIBUTENAME_DATATYPE), cl.isPrimitive(), label, value, isArray);
            resultParamListItems.add(param);
            return new ParamListItem(mapping.get(VCMapper.ATTRIBUTENAME_DATATYPE), cl.isPrimitive(), label, value, isArray);
        } else if (mapping.get(VCMapper.ELEMENTNAME_ITEMTYPE).equals(VCMapper.ITEMTYPE_CONTAINER)) {
            System.out.println(">>>>> REGISTERDE OBJECT JAVA TYPE >>>> ");
            String parentlable = "";
            Vector<Class> types = new Vector<Class>();
            Vector<String> labels = new Vector<String>();
            Vector<Object> values = new Vector<Object>();
            Class valueObjectClass = value.getClass();
            if (valueObjectClass.isArray()) {
                Object[] resultArray = (Object[]) value;
                for (int a = 0; a < resultArray.length; a++) {
                    Object valueItem = resultArray[a];
                    WebServiceResultRow row = new WebServiceResultRow();
                    row.setPrentObj(valueItem);
                    row.setRowIndex(a);
                    parentlable = valueItem.getClass().getSimpleName();
                    Field[] fields = cl.getDeclaredFields();
                    for (int j = 0; j < fields.length; j++) {
                        Field field = fields[j];
                        if ((field.getModifiers() & Modifier.STATIC) == 0 && !field.getName().startsWith("__")) {
                            String fieldName = field.getName();
                            try {
                                Method[] valueMethods = valueItem.getClass().getMethods();
                                for (int i = 0; i < valueMethods.length; i++) {
                                    Method valueMethod = valueMethods[i];
                                    String methodName = valueMethod.getName();
                                    if (methodName.equalsIgnoreCase("get" + fieldName)) {
                                        Object fValue = valueMethod.invoke(valueItem, new Object[0]);
                                        values.add(fValue);
                                        types.add(field.getType());
                                        labels.add(parentlable + "." + field.getName());
                                        Map<String, String> fieldMapping = m_vcMapper.getMapping(field.getType().getName());
                                        ParamListItem paramItem = new ParamListItem(fieldMapping.get(VCMapper.ATTRIBUTENAME_DATATYPE), field.getClass().isPrimitive(), parentlable + "." + field.getName(), fValue, field.getClass().isArray());
                                        row.addParamItem(paramItem);
                                    }
                                }
                            } catch (SecurityException e) {
                                e.printStackTrace();
                            } catch (IllegalArgumentException e) {
                                e.printStackTrace();
                            } catch (IllegalAccessException e) {
                                e.printStackTrace();
                            } catch (InvocationTargetException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                    rows.add(row);
                }
                return new ParamListItem(getParamListFromFields(types.toArray(new Class[0]), labels.toArray(new String[0]), values.toArray(new Object[0])), label, cl);
            } else {
                parentlable = cl.getSimpleName();
                Field[] fields = cl.getDeclaredFields();
                for (int j = 0; j < fields.length; j++) {
                    Field field = fields[j];
                    if ((field.getModifiers() & Modifier.STATIC) == 0 && !field.getName().startsWith("__")) {
                        String fieldName = field.getName();
                        try {
                            Method[] valueMethods = cl.getMethods();
                            for (int i = 0; i < valueMethods.length; i++) {
                                Method valueMethod = valueMethods[i];
                                String methodName = valueMethod.getName();
                                if (methodName.equalsIgnoreCase("get" + fieldName)) {
                                    Object fValue = valueMethod.invoke(value, new Object[0]);
                                    values.add(fValue);
                                    types.add(field.getType());
                                    labels.add(parentlable + "." + field.getName());
                                }
                            }
                        } catch (SecurityException e) {
                            e.printStackTrace();
                        } catch (IllegalArgumentException e) {
                            e.printStackTrace();
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        } catch (InvocationTargetException e) {
                            e.printStackTrace();
                        }
                    }
                }
                return new ParamListItem(getParamListFromFields(types.toArray(new Class[0]), labels.toArray(new String[0]), values.toArray(new Object[0])), label, cl);
            }
        }
        return null;
    }

    public ParamListItem getParamListItemFromFields22(Class cl, String label, Object value) throws MdnException {
        boolean isArray = cl.isArray();
        if (isArray) {
            cl = cl.getComponentType();
        }
        Map<String, String> mapping = m_vcMapper.getMapping(cl.getName());
        if (mapping.get(VCMapper.ELEMENTNAME_ITEMTYPE).equals(VCMapper.ITEMTYPE_FIELD)) {
            return new ParamListItem(mapping.get(VCMapper.ATTRIBUTENAME_DATATYPE), cl.isPrimitive(), label, value, isArray);
        } else if (mapping.get(VCMapper.ELEMENTNAME_ITEMTYPE).equals(VCMapper.ITEMTYPE_CONTAINER)) {
            Vector<Class> types = new Vector<Class>();
            Vector<String> labels = new Vector<String>();
            Vector<Object> values = new Vector<Object>();
            values.add(value);
            types.add(cl);
            labels.add(cl.getName());
            return new ParamListItem(getParamListFromFields(types.toArray(new Class[0]), labels.toArray(new String[0]), values.toArray(new Object[0])), label, cl);
        }
        return null;
    }

    /**
   * Returns a list containing {@link ParamListItem ParamListItem}s 
   * with the items extracted from a constructor.
   * Returns a list with default values for the request.
   * 
   * @param arguments an array of {@link java.lang.Class Class} objects.
   * @param labels an array of strings.
   * @return a list containing {@link ParamListItem ParamListItem}s.
   * @throws MdnException
   */
    public List<ParamListItem> getParamListFromConstructor(Class[] arguments, String[] labels) throws MdnException {
        List<ParamListItem> list = new ArrayList<ParamListItem>(arguments.length);
        for (int i = 0; i < arguments.length; ++i) {
            list.add(getParamListItemFromConstructor(arguments[i], labels[i]));
        }
        return list;
    }

    /**
   * Returns a {@link ParamListItem} 
   * with the values extracted from a constructor. 
   * This method extracts with <strong>Reflection</strong> the parameters
   * from a constructor and adds its names to the list.
   * 
   * @param cl a {@link java.lang.Class Class} object to be mapped 
   *        to its corresponding <strong>Visual Component</strong> type.
   * @param label the label of the component.
   * @return a {@link ParamListItem}.
   * @throws MdnException
   */
    public ParamListItem getParamListItemFromConstructor(Class cl, String label) throws MdnException {
        boolean isArray = cl.isArray();
        if (isArray) {
            cl = cl.getComponentType();
        }
        Map<String, String> mapping = m_vcMapper.getMapping(cl.getName());
        if (mapping.get(TypeMapper.ELEMENTNAME_ITEMTYPE).equals(TypeMapper.ITEMTYPE_FIELD)) {
            String value = mapping.get(TypeMapper.ELEMENTNAME_DEFAULTVALUE);
            return new ParamListItem(mapping.get(TypeMapper.ATTRIBUTENAME_DATATYPE), cl.isPrimitive(), label, (isArray) ? new Object[] { value } : value, isArray);
        } else if (mapping.get(TypeMapper.ELEMENTNAME_ITEMTYPE).equals(TypeMapper.ITEMTYPE_CONTAINER)) {
            Constructor[] constructors = cl.getDeclaredConstructors();
            int constructorIndex = getConstructorIndex(cl, constructors);
            Class[] params = constructors[constructorIndex].getParameterTypes();
            String[] paramTypes = new String[params.length];
            for (int i = 0; i < params.length; ++i) paramTypes[i] = params[i].getName();
            String[] labels = getParamNames(cl, cl.getSimpleName(), paramTypes);
            return new ParamListItem(getParamListFromConstructor(params, labels), label, cl);
        }
        return null;
    }

    public int inputArgValueIndex;

    public void setInputArgValueIndex(int inputArgValueIndex) {
        this.inputArgValueIndex = inputArgValueIndex;
    }

    public int getInputArgValueIndex() {
        return inputArgValueIndex;
    }

    public List inputValueList;

    public void setInputValueList(List inputValueList) {
        this.inputValueList = inputValueList;
    }

    public List getInputValueList() {
        return inputValueList;
    }

    /**
   * Constructs an argument list from a list containing 
   * {@link ParamListItem ParamListItem}s
   * used for "actually" invoking a method.
   * 
   * @param list the list containing the {@link ParamListItem ParamListItem}s.
   * @return a list containing the values
   */
    public Object[] constructArguments(List<ParamListItem> list, List values) throws MdnException {
        Object[] args = new Object[list.size()];
        ArrayList<Object> tempArray = new ArrayList(values);
        for (int i = 0; i < args.length; i++) {
            ParamListItem paramListItem = list.get(i);
            switch(paramListItem.getItemtype()) {
                case ParamListItem.ITEMTYPE_FIELD:
                    String dataType = paramListItem.getDatatype();
                    System.out.println("input lable == " + paramListItem.getLabel());
                    Object value = getInputValueList().get(0);
                    System.out.println(i + " value == " + value);
                    Object argValue = setArgValue(dataType, value);
                    args[i] = argValue;
                    tempArray.remove(value);
                    setInputValueList(tempArray);
                    break;
                case ParamListItem.ITEMTYPE_ARRAY:
                    args[i] = paramListItem.getValue();
                    System.out.println("array :: " + i + " value = " + args[i]);
                    break;
                case ParamListItem.ITEMTYPE_CONTAINER:
                    Class cl = paramListItem.getContainerComponentType();
                    tempArray = new ArrayList(getInputValueList());
                    Object[] containerArgs = constructArguments(paramListItem.getList(), getInputValueList());
                    args[i] = getNewInstance(cl, containerArgs);
                    break;
            }
        }
        return args;
    }

    /**
   * Constructs an argument list from a list containing 
   * {@link ParamListItem ParamListItem}s
   * used for "actually" invoking a method.
   * 
   * @param list the list containing the {@link ParamListItem ParamListItem}s.
   * @return an array containing the values
   */
    public Object[] constructArguments(List<ParamListItem> list, Map valuesMap) throws MdnException {
        Object[] args = new Object[list.size()];
        for (int i = 0; i < args.length; ++i) {
            ParamListItem paramListItem = list.get(i);
            switch(paramListItem.getItemtype()) {
                case ParamListItem.ITEMTYPE_FIELD:
                    String dataType = paramListItem.getDatatype();
                    System.out.println("param lable == " + paramListItem.getLabel());
                    Object valObj = valuesMap.get(paramListItem.getLabel());
                    System.out.println(i + " values[i] == " + valObj);
                    Object argValue = setArgValue(dataType, valObj);
                    args[i] = argValue;
                    break;
                case ParamListItem.ITEMTYPE_ARRAY:
                    args[i] = paramListItem.getValue();
                    System.out.println("arg value = " + args[i]);
                    break;
                case ParamListItem.ITEMTYPE_CONTAINER:
                    Class cl = paramListItem.getContainerComponentType();
                    Object[] containerArgs = constructArguments(paramListItem.getList(), valuesMap);
                    args[i] = getNewInstance(cl, containerArgs);
                    break;
            }
        }
        return args;
    }

    private Object setArgValue(String dataType, Object value) {
        if (dataType.equalsIgnoreCase("string")) return value.toString(); else if (dataType.equalsIgnoreCase("int")) return Integer.parseInt(value.toString()); else if (dataType.equals("Integer")) return Integer.valueOf(value.toString()); else if (dataType.equalsIgnoreCase("boolean")) return Boolean.getBoolean(value.toString()); else if (dataType.equalsIgnoreCase("byte")) return Byte.valueOf(value.toString()); else if (dataType.equalsIgnoreCase("short")) return Short.valueOf(value.toString()); else if (dataType.equals("Short")) return Short.valueOf(value.toString()); else if (dataType.equals("short")) return Short.parseShort(value.toString()); else if (dataType.equals("Long")) return Long.valueOf(value.toString()); else if (dataType.equals("long")) return Long.parseLong(value.toString()); else if (dataType.equals("Float")) return Float.valueOf(value.toString()); else if (dataType.equals("float")) return Float.parseFloat(value.toString()); else if (dataType.equals("Double")) return Double.valueOf(value.toString()); else if (dataType.equals("double")) return Double.parseDouble(value.toString()); else if (dataType.equals("date")) {
            System.out.println("??? Argument type is Date");
            return new Date(value.toString());
        } else if (dataType.equals("timeInstant")) {
            System.out.println("??? Argument type is Date");
            return new Date(value.toString());
        }
        System.out.println("!!!!!!!!!!!!!!!!Wrong argument value!!!!!!!!!!!!!!!!");
        return "NodefinitionType";
    }

    /**
   * Constructs a default argument list for the current settings (i.e. for the
   * currently set operation of the web service).<br/>
   * This method is used for constructing a list for a dummy request.
   * 
   * @return an array of {@link java.lang.Object Object}s corresponding to the argument list
   * @throws MdnException
   */
    public Object[] constructArguments(Class[] arguments) throws MdnException {
        Object[] args = new Object[arguments.length];
        for (int i = 0; i < args.length; ++i) {
            args[i] = getNewInstance(arguments[i]);
        }
        return args;
    }

    /**
   * Creates a new instance of a {@link java.lang.Class Class} with a defined set of 
   * arguments. <br/>
   * This method gets the appropriate constructor and 
   * invokes it with the arguments. 
   * 
   * @param cl the {@link java.lang.Class Class} object to be instantiated.
   * @param arguments the argument array containing. 
   * @return a new instance of the specified class.
   * @throws MdnException
   */
    public Object getNewInstance(Class cl, Object[] arguments) throws MdnException {
        try {
            Constructor[] constructors = cl.getDeclaredConstructors();
            int constructorIndex = getConstructorIndex(cl, constructors);
            constructors[constructorIndex].setAccessible(true);
            return constructors[constructorIndex].newInstance(arguments);
        } catch (SecurityException e) {
            throw new MdnException(Config.getProp("error.SecurityException"), e);
        } catch (IllegalAccessException e) {
            throw new MdnException(Config.getProp("error.IllegalAccessException"), e);
        } catch (InstantiationException e) {
            throw new MdnException(Config.getProp("error.InstantiationException"), e);
        } catch (InvocationTargetException e) {
            throw new MdnException(Config.getProp("error.InvocationTargetException"), e);
        } catch (IllegalArgumentException e) {
            throw new MdnException(Config.getProp("error.IllegalArgumentException"), e);
        }
    }

    /**
   * Creates a new instance of a {@link java.lang.Class Class}.<br/>
   * Recursively treats complex classes (i.e. constructors with multiple and non
   * Java class arguments). This method creates for each argument an instance
   * with a defined default value.
   * 
   * @param cl the {@link java.lang.Class Class} to be instantiated.
   * @return a new instance of the class.
   * @throws MdnException
   */
    public Object getNewInstance(Class cl) throws MdnException {
        int defaultNumValue = 1;
        try {
            Constructor[] constructors = cl.getDeclaredConstructors();
            for (Constructor c : constructors) c.setAccessible(true);
            if (cl.isPrimitive()) {
                if (cl.equals(boolean.class)) return false;
                if (cl.equals(char.class)) return ' ';
                if (cl.equals(byte.class)) return (byte) defaultNumValue;
                if (cl.equals(short.class)) return (short) defaultNumValue;
                if (cl.equals(long.class)) return (long) defaultNumValue;
                if (cl.equals(float.class)) return (float) defaultNumValue;
                if (cl.equals(double.class)) return (double) defaultNumValue;
                return defaultNumValue;
            }
            if (cl.isArray()) {
                return Array.newInstance(cl.getComponentType(), 1);
            }
            if (constructors.length == 0) return cl.newInstance();
            if (constructors.length == 1 && constructors[0].getParameterTypes().length == 0) return cl.newInstance();
            if (cl.equals(String.class)) return "1";
            if (cl.equals(Date.class)) return new Date();
            if (cl.equals(Calendar.class)) return new GregorianCalendar();
            if (cl.equals(BigInteger.class)) return BigInteger.valueOf(defaultNumValue);
            if (cl.equals(BigDecimal.class)) return new BigDecimal(defaultNumValue);
            if (cl.equals(Boolean.class)) return new Boolean(false);
            if (cl.equals(Byte.class)) return new Byte((byte) defaultNumValue);
            if (cl.equals(Short.class)) return new Short((short) defaultNumValue);
            if (cl.equals(Integer.class)) return new Integer(defaultNumValue);
            if (cl.equals(Long.class)) return new Long(defaultNumValue);
            if (cl.equals(Float.class)) return new Float(defaultNumValue);
            if (cl.equals(Double.class)) return new Double(defaultNumValue);
            if (cl.equals(org.apache.axis.types.NegativeInteger.class)) {
                byte[] arr = { -1 };
                return new org.apache.axis.types.NegativeInteger(arr);
            }
            if (cl.equals(org.apache.axis.types.PositiveInteger.class)) {
                byte[] arr = { 1 };
                return new org.apache.axis.types.PositiveInteger(arr);
            }
            if (cl.equals(org.apache.axis.types.UnsignedLong.class)) return new org.apache.axis.types.UnsignedLong(defaultNumValue);
            if (cl.equals(org.apache.axis.types.URI.class)) try {
                return new org.apache.axis.types.URI("http://www.example.com");
            } catch (MalformedURIException e) {
            }
            ;
            int constructorsIndex = getConstructorIndex(cl, constructors);
            Class parameterTypes[] = constructors[constructorsIndex].getParameterTypes();
            Object[] args = new Object[parameterTypes.length];
            for (int j = 0; j < parameterTypes.length; ++j) {
                args[j] = getNewInstance(parameterTypes[j]);
            }
            return constructors[constructorsIndex].newInstance(args);
        } catch (IllegalAccessException e) {
            throw new MdnException(Config.getProp("error.IllegalAccessException"), e);
        } catch (InstantiationException e) {
            throw new MdnException(Config.getProp("error.InstantiationException"), e);
        } catch (InvocationTargetException e) {
            throw new MdnException(Config.getProp("error.InvocationTargetException"), e);
        } catch (IllegalArgumentException e) {
            throw new MdnException(Config.getProp("error.IllegalArgumentException"), e);
        }
    }

    /**
   * Returns the index of the constructor be be used for the instantiation of
   * the {@link java.lang.Class Class}.
   * 
   * @param cl the {@link java.lang.Class Class} to be instantiated.
   * @param constructors all the class's constructors.
   * @return an the index of the constructor in the constructor array
   * @throws MdnException
   */
    public int getConstructorIndex(Class cl, Constructor[] constructors) throws MdnException {
        if (constructors[0].getParameterTypes().length > 0) return getConstructorIndex(cl, constructors, 0);
        if (constructors.length > 1) return getConstructorIndex(cl, constructors, 1);
        return getConstructorIndex(cl, constructors, 0);
    }

    /**
   * Checks if the desired index points to a constructor that may be used
   * for instantiation.<br/>
   * It checks if the desired constructor does not contain the class itself
   * as a parameter, which would lead to an infinite loop.
   * 
   * @param cl the {@link java.lang.Class Class} to be instantiated.
   * @param constructors all the class's constuctors.
   * @param index the desired constructor's index.
   * @return the index of the constructor in the constructor array.
   * @throws MdnException
   */
    public int getConstructorIndex(Class cl, Constructor[] constructors, int index) throws MdnException {
        if (index > constructors.length) throw new MdnException(Config.getProp("error.noAppropriateConstructorFound"));
        for (Class param : constructors[index].getParameterTypes()) {
            if (param.equals(cl)) {
                return getConstructorIndex(cl, constructors, ++index);
            }
        }
        return index;
    }

    public TypeMapper getTypeMapper() {
        return m_vcMapper;
    }
}
