package com.umc.gui.content.config;

import java.awt.Cursor;
import java.awt.Insets;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.ConnectException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.ExecutionException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
import javax.swing.BorderFactory;
import javax.swing.GroupLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.SwingWorker;
import javax.swing.GroupLayout.Alignment;
import javax.swing.LayoutStyle.ComponentPlacement;
import javax.swing.border.TitledBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.apache.log4j.Logger;
import com.umc.beans.Component;
import com.umc.beans.Update;
import com.umc.collector.Publisher;
import com.umc.dao.DataAccessFactory;
import com.umc.dao.UMCDataAccessInterface;
import com.umc.gui.GuiController;
import com.umc.gui.models.UpdateTableModel;
import com.umc.helper.UMCConstants;
import com.umc.helper.UMCLanguage;
import com.umc.helper.UMCUtils;

/**
 *
 * @author Administrator
 */
public class UpdatePanel extends javax.swing.JPanel {

    private static final long serialVersionUID = 6268481023475270709L;

    /**Logger*/
    private static Logger log = Logger.getLogger("com.umc.file");

    public static final String ID = "UPDATE";

    private UMCDataAccessInterface dao = null;

    private JButton btnInstall;

    private JButton btnUpdate;

    private JScrollPane jScrollPane1;

    private JScrollPane jScrollPane2;

    private JPanel panelOnline;

    private JPanel panelUpdate;

    private JTable tableOnline;

    private JTable tableUpdate;

    private List<String> tags;

    private JButton btnReload;

    private JCheckBox chkBoxAutoupdate;

    private JProgressBar progressInstall;

    private JProgressBar progressUpdate;

    private DecimalFormat sizeFormater;

    FormListener formListener;

    private UpdateTableModel tableUpdateModel;

    private UpdateTableModel tableOnlineModel;

    private DownloadTask downloadTask;

    /** Creates new form UpdatePanel */
    public UpdatePanel() {
        initComponents();
        initContent();
    }

    private void initContent() {
        tags = Arrays.asList(UMCLanguage.getText("UpdatePanel.tags").split(","));
        InitUpdateList update = new InitUpdateList();
        update.execute();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {
        panelUpdate = new JPanel();
        jScrollPane1 = new JScrollPane();
        tableUpdate = new JTable();
        tableUpdate.setAutoCreateRowSorter(true);
        btnUpdate = new JButton();
        panelOnline = new JPanel();
        jScrollPane2 = new JScrollPane();
        tableOnline = new JTable();
        tableOnline.setAutoCreateRowSorter(true);
        btnInstall = new JButton();
        chkBoxAutoupdate = new JCheckBox();
        chkBoxAutoupdate.setSelected(true);
        btnReload = new JButton();
        progressInstall = new JProgressBar();
        progressUpdate = new JProgressBar();
        sizeFormater = new DecimalFormat(" [.##KB]");
        progressInstall.setMinimum(0);
        progressInstall.setMaximum(100);
        progressInstall.setValue(0);
        progressInstall.setStringPainted(true);
        List<String> columnsUpdate = new ArrayList<String>();
        columnsUpdate.add("Typ");
        columnsUpdate.add("Name");
        columnsUpdate.add("Installed Version");
        columnsUpdate.add("Available Version");
        List<String> columnsOnline = new ArrayList<String>();
        columnsOnline.add("Typ");
        columnsOnline.add("Name");
        columnsOnline.add("Installed Version");
        columnsOnline.add("Available Version");
        try {
            tableUpdateModel = new UpdateTableModel(columnsUpdate);
            tableOnlineModel = new UpdateTableModel(columnsOnline);
        } catch (Exception e) {
            log.error("UpdateTableError: " + e);
        }
        tableUpdate.setModel(tableUpdateModel);
        tableOnline.setModel(tableOnlineModel);
        formListener = new FormListener();
        tableOnline.getSelectionModel().addListSelectionListener(formListener);
        tableUpdate.getSelectionModel().addListSelectionListener(formListener);
        panelUpdate.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), UMCLanguage.getText("UpdatePanel.panelUpdate.border.title"), TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.TOP));
        jScrollPane1.setViewportView(tableUpdate);
        btnUpdate.setText(UMCLanguage.getText("UpdatePanel.btnUpdate.text"));
        btnUpdate.setEnabled(false);
        btnUpdate.addActionListener(formListener);
        GroupLayout panelUpdateLayout = new GroupLayout(panelUpdate);
        panelUpdate.setLayout(panelUpdateLayout);
        panelUpdateLayout.setHorizontalGroup(panelUpdateLayout.createParallelGroup(Alignment.LEADING).addGroup(Alignment.TRAILING, panelUpdateLayout.createSequentialGroup().addContainerGap().addGroup(panelUpdateLayout.createParallelGroup(Alignment.TRAILING).addGroup(panelUpdateLayout.createSequentialGroup().addComponent(progressUpdate, GroupLayout.DEFAULT_SIZE, 463, Short.MAX_VALUE).addPreferredGap(ComponentPlacement.UNRELATED).addComponent(btnUpdate, GroupLayout.PREFERRED_SIZE, 88, GroupLayout.PREFERRED_SIZE)).addComponent(jScrollPane1, GroupLayout.DEFAULT_SIZE, 561, Short.MAX_VALUE)).addContainerGap()));
        panelUpdateLayout.setVerticalGroup(panelUpdateLayout.createParallelGroup(Alignment.LEADING).addGroup(Alignment.TRAILING, panelUpdateLayout.createSequentialGroup().addComponent(jScrollPane1, GroupLayout.DEFAULT_SIZE, 135, Short.MAX_VALUE).addGroup(panelUpdateLayout.createParallelGroup(Alignment.LEADING).addGroup(panelUpdateLayout.createSequentialGroup().addPreferredGap(ComponentPlacement.RELATED).addComponent(btnUpdate)).addGroup(panelUpdateLayout.createSequentialGroup().addGap(10, 10, 10).addComponent(progressUpdate, GroupLayout.PREFERRED_SIZE, 19, GroupLayout.PREFERRED_SIZE))).addContainerGap()));
        panelOnline.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), UMCLanguage.getText("UpdatePanel.panelOnline.border.title"), TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.TOP));
        jScrollPane2.setViewportView(tableOnline);
        btnInstall.setText(UMCLanguage.getText("UpdatePanel.btnInstall.text"));
        btnInstall.setEnabled(false);
        btnInstall.addActionListener(formListener);
        GroupLayout panelOnlineLayout = new GroupLayout(panelOnline);
        panelOnline.setLayout(panelOnlineLayout);
        panelOnlineLayout.setHorizontalGroup(panelOnlineLayout.createParallelGroup(Alignment.LEADING).addGroup(Alignment.TRAILING, panelOnlineLayout.createSequentialGroup().addContainerGap().addGroup(panelOnlineLayout.createParallelGroup(Alignment.TRAILING).addComponent(jScrollPane2, Alignment.LEADING, GroupLayout.DEFAULT_SIZE, 561, Short.MAX_VALUE).addGroup(panelOnlineLayout.createSequentialGroup().addComponent(progressInstall, GroupLayout.DEFAULT_SIZE, 466, Short.MAX_VALUE).addGap(10, 10, 10).addComponent(btnInstall))).addContainerGap()));
        panelOnlineLayout.setVerticalGroup(panelOnlineLayout.createParallelGroup(Alignment.LEADING).addGroup(Alignment.TRAILING, panelOnlineLayout.createSequentialGroup().addComponent(jScrollPane2, GroupLayout.DEFAULT_SIZE, 134, Short.MAX_VALUE).addGroup(panelOnlineLayout.createParallelGroup(Alignment.LEADING).addGroup(panelOnlineLayout.createSequentialGroup().addPreferredGap(ComponentPlacement.RELATED).addComponent(btnInstall)).addGroup(panelOnlineLayout.createSequentialGroup().addGap(10, 10, 10).addComponent(progressInstall, GroupLayout.PREFERRED_SIZE, 19, GroupLayout.PREFERRED_SIZE))).addContainerGap()));
        chkBoxAutoupdate.setText(UMCLanguage.getText("UpdatePanel.chkBoxAutoupdate.text"));
        chkBoxAutoupdate.addActionListener(formListener);
        btnReload.setIcon(new ImageIcon(getClass().getResource("/com/umc/gui/resources/reload.png")));
        btnReload.setMargin(new Insets(0, 0, 0, 0));
        btnReload.addActionListener(formListener);
        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(layout.createParallelGroup(Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(Alignment.LEADING).addComponent(panelUpdate, Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addGroup(layout.createSequentialGroup().addComponent(chkBoxAutoupdate).addPreferredGap(ComponentPlacement.RELATED, 395, Short.MAX_VALUE).addComponent(btnReload)).addComponent(panelOnline, Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)).addContainerGap()));
        layout.setVerticalGroup(layout.createParallelGroup(Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(Alignment.LEADING).addComponent(chkBoxAutoupdate).addComponent(btnReload)).addPreferredGap(ComponentPlacement.RELATED).addComponent(panelUpdate, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addPreferredGap(ComponentPlacement.RELATED).addComponent(panelOnline, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addContainerGap()));
    }

    private class FormListener implements ActionListener, ListSelectionListener, PropertyChangeListener {

        FormListener() {
        }

        public void actionPerformed(ActionEvent evt) {
            if (evt.getSource() == btnInstall) {
                btnInstall.setEnabled(false);
                setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                downloadTask = new DownloadTask();
                downloadTask.addPropertyChangeListener(formListener);
                downloadTask.execute();
            } else if (evt.getSource() == btnUpdate) {
                UpdatePanel.this.btnUpdateActionPerformed(evt);
            } else if (evt.getSource() == chkBoxAutoupdate) {
                UpdatePanel.this.chkBoxAutoupdateActionPerformed(evt);
            } else if (evt.getSource() == btnReload) {
                UpdatePanel.this.btnReloadActionPerformed(evt);
            }
        }

        @Override
        public void valueChanged(ListSelectionEvent evt) {
            if (evt.getSource() == tableUpdate.getSelectionModel() && evt.getValueIsAdjusting()) {
                UpdatePanel.this.tableUpdateValueChanged(evt);
            } else if (evt.getSource() == tableOnline.getSelectionModel() && evt.getValueIsAdjusting()) {
                UpdatePanel.this.tableOnlineValueChanged(evt);
            }
        }

        @Override
        public void propertyChange(PropertyChangeEvent evt) {
            if (evt.getPropertyName() == "FILE") {
                progressInstall.setValue(0);
                progressInstall.setString("Downloading: " + (String) evt.getNewValue());
            } else if (evt.getPropertyName() == "INSTALL") {
                progressInstall.setValue(0);
                progressInstall.setString("Installing: " + (String) evt.getNewValue());
            }
        }
    }

    private void btnUpdateActionPerformed(ActionEvent evt) {
    }

    private void chkBoxAutoupdateActionPerformed(ActionEvent evt) {
    }

    private void btnReloadActionPerformed(ActionEvent evt) {
    }

    private void tableUpdateValueChanged(ListSelectionEvent evt) {
        if (tableUpdate.getSelectedRow() == -1) {
            btnUpdate.setEnabled(false);
        } else {
            btnUpdate.setEnabled(true);
        }
    }

    private void tableOnlineValueChanged(ListSelectionEvent evt) {
        int viewRow = tableOnline.getSelectedRow();
        if (viewRow < 0) {
            btnInstall.setEnabled(false);
        } else {
            btnInstall.setEnabled(true);
        }
    }

    public boolean matchFilter(String tag) {
        if (tags.contains(tag)) return true;
        return false;
    }

    private class DownloadTask extends SwingWorker<String, Integer> {

        public DownloadTask() {
            progressInstall.setValue(0);
            dao = DataAccessFactory.getUMCDataSourceAccessor(DataAccessFactory.DB_TYPE_SQLITE, Publisher.getInstance().getParamDBDriverconnect() + Publisher.getInstance().getParamDBName(), Publisher.getInstance().getParamDBDriver(), Publisher.getInstance().getParamDBUser(), Publisher.getInstance().getParamDBPwd());
        }

        @Override
        public String doInBackground() {
            boolean skinsDownloaded = false;
            dao = DataAccessFactory.getUMCDataSourceAccessor(DataAccessFactory.DB_TYPE_SQLITE, Publisher.getInstance().getParamDBDriverconnect() + Publisher.getInstance().getParamDBName(), Publisher.getInstance().getParamDBDriver(), Publisher.getInstance().getParamDBUser(), Publisher.getInstance().getParamDBPwd());
            File downloadDir = new File(UMCConstants.APP_DIR + UMCConstants.fileSeparator + "downloads");
            if (!downloadDir.exists()) {
                if (!downloadDir.mkdir()) {
                    log.error("Could not create download folder '" + downloadDir.getAbsolutePath() + "' - create this directory and try again! ");
                }
            }
            if (downloadDir.exists()) {
                int[] i = tableOnline.getSelectedRows();
                for (int a = 0; a < i.length; a++) {
                    Update update = tableOnlineModel.getUpdate(i[a]);
                    if (update.getType().equals(Update.TYPE_SKIN)) skinsDownloaded = true;
                    if (UMCConstants.debug) log.debug("Starting to download UMC " + update.getType() + ": " + update.getDescription() + " - Version " + update.getVersionAvailable() + " from " + update.getDownloadURL());
                    try {
                        int bytesRead = 0, bytesWrite = 0;
                        double totalBytes = 0;
                        URL url = new URL(update.getDownloadURL());
                        URLConnection urlC = url.openConnection();
                        urlC.setConnectTimeout(10000);
                        totalBytes = urlC.getContentLength();
                        firePropertyChange("FILE", null, update.getName() + " " + sizeFormater.format(totalBytes / 1024));
                        InputStream is = url.openStream();
                        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(UMCConstants.APP_DIR + UMCConstants.fileSeparator + "downloads" + UMCConstants.fileSeparator + update.getDownloadURL().substring(update.getDownloadURL().lastIndexOf("/"), update.getDownloadURL().length())));
                        byte[] buf = new byte[1024 * 8];
                        while ((bytesRead = is.read(buf)) != -1) {
                            bos.write(buf, 0, bytesRead);
                            bytesWrite += bytesRead;
                            publish(new Double(bytesWrite / totalBytes * 100).intValue());
                        }
                        is.close();
                        bos.close();
                        String zip = UMCConstants.APP_DIR + UMCConstants.fileSeparator + "downloads" + UMCConstants.fileSeparator + update.getDownloadURL().substring(update.getDownloadURL().lastIndexOf("/"), update.getDownloadURL().length());
                        String destDir = "";
                        if (update.getType().equals(Update.TYPE_SKIN)) {
                            destDir = UMCConstants.APP_DIR + UMCConstants.fileSeparator + "resources" + UMCConstants.fileSeparator + "Skins" + UMCConstants.fileSeparator + update.getName();
                        } else if (update.getType().equals(Update.TYPE_PLUGIN_MOVIEDB)) {
                            destDir = UMCConstants.APP_DIR + UMCConstants.fileSeparator + "plugins" + UMCConstants.fileSeparator + "moviedb" + UMCConstants.fileSeparator + update.getName();
                        } else if (update.getType().equals(Update.TYPE_PLUGIN_MOVIESCANNER) || update.getType().equals(Update.TYPE_PLUGIN_SERIESCANNER) || update.getType().equals(Update.TYPE_PLUGIN_MUSICSCANNER) || update.getType().equals(Update.TYPE_PLUGIN_PHOTOSCANNER)) {
                            destDir = UMCConstants.APP_DIR + UMCConstants.fileSeparator + "plugins" + UMCConstants.fileSeparator + "scanner" + UMCConstants.fileSeparator + update.getName();
                        } else if (update.getType().equals(Update.TYPE_PLUGIN_GUI)) {
                            destDir = UMCConstants.APP_DIR + UMCConstants.fileSeparator + "plugins" + UMCConstants.fileSeparator + "gui" + UMCConstants.fileSeparator + update.getName();
                        } else {
                            return "Download type could not be identified -> disgarding package";
                        }
                        File f = new File(destDir);
                        if (!f.exists()) {
                            f.mkdir();
                        }
                        ZipFile zipFile = new ZipFile(zip);
                        firePropertyChange("INSTALL", null, update.getName() + " - " + zipFile.size() + " files");
                        Enumeration entries = zipFile.entries();
                        int count = 0;
                        int maxSize = zipFile.size();
                        byte[] buffer = new byte[16384];
                        int len;
                        while (entries.hasMoreElements()) {
                            ZipEntry entry = (ZipEntry) entries.nextElement();
                            String entryFileName = entry.getName();
                            int lastIndex = entryFileName.lastIndexOf('/');
                            String internalPathToEntry = entryFileName.substring(0, lastIndex + 1);
                            File dir = new File(destDir, internalPathToEntry);
                            if (!dir.exists()) {
                                dir.mkdirs();
                            }
                            if (!entry.isDirectory()) {
                                count++;
                                publish(new Double((count / maxSize) * 100).intValue());
                                bos = new BufferedOutputStream(new FileOutputStream(new File(destDir, entryFileName)));
                                BufferedInputStream bis = new BufferedInputStream(zipFile.getInputStream(entry));
                                while ((len = bis.read(buffer)) > 0) {
                                    bos.write(buffer, 0, len);
                                }
                                bos.flush();
                                bos.close();
                                bis.close();
                            }
                        }
                        if (update.getType().equals(Update.TYPE_SKIN)) {
                            dao.registerSkin(update.getName(), update.getVersionAvailable());
                        } else if (update.getType().equals(Update.TYPE_PLUGIN_MOVIEDB)) {
                            dao.registerPlugin(update.getName(), update.getVersionAvailable());
                        } else if (update.getType().equals(Update.TYPE_PLUGIN_MOVIESCANNER) || update.getType().equals(Update.TYPE_PLUGIN_SERIESCANNER) || update.getType().equals(Update.TYPE_PLUGIN_MUSICSCANNER) || update.getType().equals(Update.TYPE_PLUGIN_PHOTOSCANNER)) {
                            dao.registerPlugin(update.getName(), update.getVersionAvailable());
                        } else if (update.getType().equals(Update.TYPE_PLUGIN_GUI)) {
                            dao.registerPlugin(update.getName(), update.getVersionAvailable());
                        }
                        tableOnlineModel.removeUpdate(i[a]);
                        tableOnline.updateUI();
                    } catch (MalformedURLException e) {
                        log.error(e);
                        return "MalformedURLException";
                    } catch (IOException e) {
                        log.error(e);
                        return "IO Error";
                    } catch (Exception e) {
                        log.error(e);
                        return "Installation Error";
                    }
                }
            } else {
                return "Error";
            }
            if (skinsDownloaded) {
                Publisher.getInstance().findAllSkins();
                Publisher.getInstance().refreshParams();
                Publisher.getInstance().createFrontendDirectoryStructure();
            }
            return "OK";
        }

        @Override
        public void done() {
            try {
                GuiController.getInstance().getConfigPanel().resetSkinPanel();
                String status = get();
                Toolkit.getDefaultToolkit().beep();
                btnInstall.setEnabled(false);
                setCursor(null);
                JOptionPane.showMessageDialog(GuiController.getInstance().getMainframe(), status, "Download", JOptionPane.INFORMATION_MESSAGE);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }

        protected void process(java.util.List<Integer> progressList) {
            progressInstall.setValue(progressList.get(progressList.size() - 1));
        }
    }

    private class InitUpdateList extends SwingWorker<ArrayList<?>, Void> {

        private LinkedList<Update> allAvailableUpdates = new LinkedList<Update>();

        private LinkedList<Update> allAvailableComponents = new LinkedList<Update>();

        @Override
        protected ArrayList<?> doInBackground() throws Exception {
            dao = DataAccessFactory.getUMCDataSourceAccessor(DataAccessFactory.DB_TYPE_SQLITE, Publisher.getInstance().getParamDBDriverconnect() + Publisher.getInstance().getParamDBName(), Publisher.getInstance().getParamDBDriver(), Publisher.getInstance().getParamDBUser(), Publisher.getInstance().getParamDBPwd());
            if (UMCConstants.updatecheck) {
                Publisher.getInstance().setUpdateAvailable(isDatabaseUpdateAvailable());
                getInstalledComponents();
                getAvailableSkinVersions();
                getAvailablePluginVersions();
            }
            return null;
        }

        @Override
        protected void done() {
            for (Update update : allAvailableUpdates) {
                tableUpdateModel.addUpdate(update);
            }
            for (Update update : allAvailableComponents) {
                tableOnlineModel.addUpdate(update);
            }
        }

        /**
		 * Checks if an database update is available.
		 * If an update is availabe 'true' will be returned. 
		 * Else 'false'.
		 * 
		 * @return true/false
		 */
        private boolean isDatabaseUpdateAvailable() {
            if (UMCConstants.debug) log.debug("[Update] Checking for new update...");
            String downloadURL = exists(UMCConstants.updateDatabaseURL);
            if (downloadURL == null) return false;
            InputStream in = null;
            long milis = System.currentTimeMillis();
            try {
                URL u = new URL(downloadURL);
                URLConnection con = u.openConnection();
                con.setConnectTimeout(15000);
                con.setReadTimeout(15000);
                con.setUseCaches(true);
                in = u.openStream();
                getDatabaseUpdatesFromStream(in);
                if (allAvailableUpdates.size() > 0) return true;
                return false;
            } catch (SocketTimeoutException exc) {
                log.error("'Database Update' timeout: " + exc);
                return false;
            } catch (Exception e) {
                log.error("'Database-Update' failed: " + e);
                return false;
            } finally {
                try {
                    if (in != null) in.close();
                } catch (IOException e) {
                }
            }
        }

        private String exists(String URLName) {
            String url = URLName;
            try {
                HttpURLConnection.setFollowRedirects(false);
                HttpURLConnection con = (HttpURLConnection) new URL(url).openConnection();
                con.setRequestMethod("HEAD");
                con.setConnectTimeout(10000);
                con.setReadTimeout(10000);
                if (con.getResponseCode() == HttpURLConnection.HTTP_MOVED_TEMP) {
                    url = con.getHeaderField("Location");
                    con = (HttpURLConnection) new URL(url).openConnection();
                    con.setConnectTimeout(10000);
                    con.setReadTimeout(10000);
                    con.setRequestMethod("HEAD");
                }
                if (con.getResponseCode() == HttpURLConnection.HTTP_OK) return url;
                return null;
            } catch (SocketTimeoutException exc) {
                log.error("SocketTimeout: " + url);
                return null;
            } catch (ConnectException ce) {
                log.error("ConnectionTimeout: " + url);
                return null;
            } catch (Exception e) {
                log.error("Check URL " + url + ": " + e);
                return null;
            }
        }

        /**
		 * 
		 * @param is
		 * @throws IOException
		 */
        private void getDatabaseUpdatesFromStream(InputStream is) throws IOException {
            if (is != null) {
                String line;
                double patchVersion = 0;
                String patchType = "";
                String patchDescription = "";
                String patchSQL = "";
                Connection con = null;
                try {
                    Class.forName("org.sqlite.JDBC");
                    con = DriverManager.getConnection("jdbc:sqlite:database/umc.db", "", "");
                    double dbVersion = -1;
                    PreparedStatement pre_stmt = con.prepareStatement("SELECT * FROM DB_VERSION WHERE ID_MODUL = 0");
                    ResultSet rs = pre_stmt.executeQuery();
                    if (rs.next()) {
                        dbVersion = rs.getDouble("VERSION");
                    }
                    double nextPatchVersion = dbVersion + 1;
                    boolean collectSQL = false;
                    BufferedReader reader = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                    while ((line = reader.readLine()) != null) {
                        if (line.startsWith("[")) {
                            Pattern p = Pattern.compile("\\[.*\\]");
                            Matcher m = p.matcher(line);
                            m.find();
                            String value = m.group();
                            value = value.substring(1, value.length() - 1);
                            int i = 1;
                            Scanner sc = new Scanner(value).useDelimiter("\\|");
                            while (sc.hasNext()) {
                                if (i == 1) patchVersion = Double.parseDouble(sc.next());
                                if (i == 2) patchType = sc.next();
                                if (i == 3) patchDescription = sc.next();
                                if (i == 4) patchSQL = sc.next();
                                i++;
                            }
                            if (patchVersion == nextPatchVersion) {
                                collectSQL = true;
                                nextPatchVersion++;
                            } else {
                                collectSQL = false;
                            }
                            if (collectSQL) {
                                if (line.endsWith(";")) line = line.substring(0, line.length() - 1);
                                Update update = new Update();
                                update.setVersionInstalled(-999);
                                update.setVersionAvailable(patchVersion);
                                update.setDescription(patchDescription);
                                update.setType(Update.TYPE_DATABSE);
                                allAvailableUpdates.add(update);
                            }
                        }
                    }
                } catch (SQLException exc) {
                    log.error("Could not determine database updates", exc);
                } catch (ClassNotFoundException exc) {
                    log.error("Could not determine database updates", exc);
                } finally {
                    is.close();
                    try {
                        con.close();
                    } catch (SQLException exc) {
                    }
                }
            } else {
            }
        }

        /**
		 * Ermittelt die online verfügbaren Skins/Frontends.
		 * @param is
		 * @throws IOException
		 */
        private void getAvailableSkinVersions() throws IOException {
            URL u = new URL(UMCConstants.onlineSkinVersions);
            URLConnection con = u.openConnection();
            con.setConnectTimeout(15000);
            con.setReadTimeout(15000);
            con.setUseCaches(true);
            InputStream is = u.openStream();
            if (is != null) {
                String line;
                try {
                    double skinVersion = 0;
                    String skinName = "";
                    String skinDownloadLink = "";
                    BufferedReader reader = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                    while ((line = reader.readLine()) != null && !line.startsWith("#")) {
                        int i = 1;
                        Scanner sc = new Scanner(line).useDelimiter("\\|");
                        while (sc.hasNext()) {
                            if (i == 1) skinName = sc.next();
                            if (i == 2) skinVersion = Double.parseDouble(sc.next());
                            if (i == 3) skinDownloadLink = sc.next();
                            i++;
                        }
                        double v = dao.getSkinVersion(skinName);
                        if (v < skinVersion) {
                            Update update = new Update();
                            update.setVersionInstalled(v);
                            update.setVersionAvailable(skinVersion);
                            update.setName(skinName);
                            update.setDownloadURL(skinDownloadLink);
                            update.setType(Update.TYPE_SKIN);
                            allAvailableComponents.add(update);
                        }
                    }
                } catch (Exception exc) {
                    log.error(exc);
                } finally {
                    is.close();
                }
            } else {
            }
        }

        /**
		 * Ermittelt alle installierten Komponenten
		 * @throws IOException
		 */
        private void getInstalledComponents() throws IOException {
            if (dao == null) dao = DataAccessFactory.getUMCDataSourceAccessor(DataAccessFactory.DB_TYPE_SQLITE, Publisher.getInstance().getParamDBDriverconnect() + Publisher.getInstance().getParamDBName(), Publisher.getInstance().getParamDBDriver(), Publisher.getInstance().getParamDBUser(), Publisher.getInstance().getParamDBPwd());
            for (Component c : dao.getAllInstalledComponents()) {
                Update update = new Update();
                update.setVersionInstalled(c.getVersionInstalled());
                update.setName(c.getName());
                update.setType(c.getType());
                allAvailableUpdates.add(update);
            }
        }

        /**
		 * Ermittelt die online verfügbaren  Plugins.
		 * 
		 * @param is
		 * @throws IOException
		 */
        private void getAvailablePluginVersions() throws IOException {
            URL u = new URL(UMCConstants.onlinePluginVersions);
            URLConnection con = u.openConnection();
            con.setConnectTimeout(15000);
            con.setReadTimeout(15000);
            con.setUseCaches(true);
            InputStream is = u.openStream();
            if (is != null) {
                String line;
                try {
                    double pluginVersion = 0;
                    String pluginName = "";
                    String pluginDownloadLink = "";
                    String pluginType = "";
                    BufferedReader reader = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                    while ((line = reader.readLine()) != null && !line.startsWith("#")) {
                        int i = 1;
                        Scanner sc = new Scanner(line).useDelimiter("\\|");
                        while (sc.hasNext()) {
                            if (i == 1) pluginType = sc.next();
                            if (i == 2) pluginName = sc.next();
                            if (i == 3) pluginVersion = Double.parseDouble(sc.next());
                            if (i == 4) pluginDownloadLink = sc.next();
                            i++;
                        }
                        double v = dao.getPluginVersion(pluginName);
                        if (v < pluginVersion) {
                            Update update = new Update();
                            update.setVersionInstalled(v);
                            update.setVersionAvailable(pluginVersion);
                            update.setName(pluginName);
                            update.setDownloadURL(pluginDownloadLink);
                            update.setType(pluginType);
                            allAvailableComponents.add(update);
                        }
                    }
                } catch (Exception exc) {
                    log.error(exc);
                } finally {
                    is.close();
                }
            } else {
            }
        }
    }
}
