package org.rendersnake.servlet;

import static org.rendersnake.HtmlAttributesFactory.border;
import static org.rendersnake.HtmlAttributesFactory.href;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServletRequest;
import org.rendersnake.HtmlCanvas;
import org.rendersnake.Renderable;
import org.rendersnake.ext.servlet.FormHandler;

/**
 * URIMappingResolver is a RequestToComponentResolver that initializes the uri-to-class mappings 
 * by reading all occurrences of the properties file [rendersnake-uri-mappings.properties].
 * 
 * This file can be generated by the Page Annotation processor. (see rendersnake-annotations.jar)
 * 
 * @author ernest.micklei
 */
@Deprecated
public class URIMappingResolver implements RequestToComponentResolver {

    private static final Logger LOG = Logger.getLogger("org.rendersnake.annotation");

    static final String CONFIG_PROPERTIES = "rendersnake-uri-mappings.properties";

    private Map<String, Class<?>> uriToClassMap = new HashMap<String, Class<?>>();

    /**
     * If the receiver cannot detect the component from the HttpRequest then
     * pass the resolving to the <em>nextResolver</em> unless null.
     */
    private RequestToComponentResolver nextResolver;

    public Renderable renderComponentForRequest(HttpServletRequest request) {
        String uri = "";
        String info = request.getPathInfo();
        if (null != info && info.length() > 0) {
            uri = info.substring(1);
        } else {
            return null;
        }
        try {
            Class<?> theClass = uriToClassMap.get(uri);
            if (null == theClass) {
                if (nextResolver == null) return null; else {
                    if (LOG.isLoggable(Level.FINE)) {
                        LOG.fine("[URIMappingResolver.renderComponentForRequest] no mapping for [" + uri + "] trying next resolver");
                    }
                    return this.nextResolver.renderComponentForRequest(request);
                }
            }
            return (Renderable) (theClass.newInstance());
        } catch (InstantiationException ex) {
            throw new RuntimeException("[URIMappingResolver.renderComponentForRequest] InstantiationException: " + ex.getMessage(), ex);
        } catch (IllegalAccessException ex) {
            throw new RuntimeException("[URIMappingResolver.renderComponentForRequest] IllegalAccessException: " + ex.getMessage(), ex);
        }
    }

    public FormHandler formHandlerForRequest(HttpServletRequest request) {
        String uri = request.getPathInfo().substring(1);
        try {
            Class<?> theClass = uriToClassMap.get(uri);
            if (null == theClass) {
                if (nextResolver == null) throw new RuntimeException("[URIMappingResolver.formHandlerForRequest] No annotation mapping"); else {
                    if (LOG.isLoggable(Level.FINE)) {
                        LOG.fine("[URIMappingResolver.formHandlerForRequest] no mapping for [" + uri + "] trying next resolver");
                    }
                    return this.nextResolver.formHandlerForRequest(request);
                }
            }
            return (FormHandler) (theClass.newInstance());
        } catch (InstantiationException ex) {
            throw new RuntimeException("[URIMappingResolver.formHandlerForRequest] InstantiationException: " + ex.getMessage(), ex);
        } catch (IllegalAccessException ex) {
            throw new RuntimeException("[URIMappingResolver.formHandlerForRequest] IllegalAccessException: " + ex.getMessage(), ex);
        }
    }

    public String requestPathForComponentClass(Class<? extends Renderable> componentClass) {
        for (Map.Entry<String, Class<?>> each : uriToClassMap.entrySet()) {
            if (componentClass == each.getValue()) {
                return each.getKey();
            }
        }
        if (nextResolver == null) throw new RuntimeException("[URIMappingResolver.requestPathForComponentClass] no mapping"); else return this.nextResolver.requestPathForComponentClass(componentClass);
    }

    public void renderOn(HtmlCanvas html) throws IOException {
        Set<String> set = uriToClassMap.keySet();
        String[] keys = (String[]) (set.toArray(new String[set.size()]));
        Arrays.sort(keys);
        html.h2().write(this.getClass().getName())._h2();
        html.table(border("1px").cellpadding("4px"));
        for (String each : keys) {
            html.tr().td().a(href(each)).write(each)._a()._td().td().write(uriToClassMap.get(each).toString())._td()._tr();
        }
        html._table();
    }

    public void init(ServletConfig config) {
        LOG.info("[org.rendersnake.annotation.URIMappingResolver.init] Reading mapping file");
        try {
            Properties configuration = new Properties();
            Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(CONFIG_PROPERTIES);
            while (urls.hasMoreElements()) {
                InputStream is = urls.nextElement().openStream();
                configuration.load(is);
                is.close();
            }
            for (Object each : configuration.keySet()) {
                String key = (String) each;
                this.tryAddMapping(configuration, key);
            }
        } catch (Exception ex) {
            throw new RuntimeException("[URIMappingResolver.init(config)] failed", ex);
        }
        LOG.info("[URIMappingResolver.init] mappings loaded:" + uriToClassMap.size());
    }

    private void tryAddMapping(Properties configuration, String key) {
        try {
            Class<?> componentClass = Class.forName(configuration.getProperty(key));
            LOG.fine("[URIMappingResolver.init] add mapping from [" + key + "] to class [" + configuration.getProperty(key) + "]");
            uriToClassMap.put(key, componentClass);
        } catch (ClassNotFoundException ex) {
            LOG.severe("[URIMappingResolver.init] Class not found [" + configuration.getProperty(key) + "]");
        }
    }

    public RequestToComponentResolver getNextResolver() {
        return nextResolver;
    }

    public RequestToComponentResolver setNextResolver(RequestToComponentResolver resolver) {
        return this.nextResolver = resolver;
    }
}
