package prajna.semantic.writer;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Text;
import prajna.data.*;
import prajna.util.Graph;
import prajna.util.Grid;
import prajna.util.Tree;

/**
 * Utility class for writing DataRecords to a Solr instance.
 * 
 * @author <a href="http://www.ganae.com/edswing">Edward Swing</a>
 */
public class SolrUpdater implements SemanticWriter {

    private static DocumentBuilder docBuild;

    private static Transformer transformer;

    private String baseUrl;

    private Document doc;

    private int writeLimit = 1000;

    private boolean debug = false;

    private SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");

    private Writer outWriter;

    static {
        try {
            docBuild = DocumentBuilderFactory.newInstance().newDocumentBuilder();
            transformer = TransformerFactory.newInstance().newTransformer();
            transformer.setOutputProperty("omit-xml-declaration", "yes");
        } catch (Exception exc) {
            System.err.println("Cannot initialize SolrUpdater:");
            exc.printStackTrace();
        }
    }

    /**
     * Create an instance of a SolrUpdater for the specified URL
     * 
     * @param solrUrl The update URL for the solr instance
     */
    public SolrUpdater(String solrUrl) {
        baseUrl = solrUrl;
    }

    /**
     * Add a set of values for a particular field to the record element. This
     * should not be used for the time field.
     * 
     * @param recElem The element representing the record
     * @param field the field name. This should be a name of a field in the
     *            Solr schema
     * @param vals the set of values for the field
     */
    private void addFieldToElement(Element recElem, String field, Set<?> vals) {
        if (!field.startsWith("__")) {
            for (Object val : vals) {
                Element fieldElem = doc.createElement("field");
                fieldElem.setAttribute("name", field);
                Text txtNode = doc.createTextNode(val.toString());
                fieldElem.appendChild(txtNode);
                recElem.appendChild(fieldElem);
            }
        }
    }

    /**
     * Add the time field values to the record element. This method writes the
     * start time of the time span in the field value. The end time is ignored.
     * 
     * @param recElem The element representing the record
     * @param field the field name. This should be a name of a field in the
     *            Solr schema
     * @param vals the set of timespans for the field
     */
    private void addTimeToElement(Element recElem, String field, Set<TimeSpan> vals) {
        if (!field.startsWith("__")) {
            for (TimeSpan val : vals) {
                Element fieldElem = doc.createElement("field");
                fieldElem.setAttribute("name", field);
                Text txtNode = doc.createTextNode(format.format(val.getStartDate()));
                fieldElem.appendChild(txtNode);
                recElem.appendChild(fieldElem);
            }
        }
    }

    /**
     * Clear any stored settings and data
     */
    public void clear() {
    }

    /**
     * Close this writer. This method sends a commit and an optimize request to
     * the Solr server
     */
    public void close() {
        try {
            writeCommand("<commit/>");
            writeCommand("<optimize/>");
            if (outWriter != null) {
                outWriter.flush();
                outWriter.close();
            }
        } catch (IOException exc) {
            exc.printStackTrace();
        }
    }

    /**
     * Get the content type generated by this writer. This should return a mime
     * type, suitable for web-based data. For the SolrUpdater, the content type
     * is text/xml, which is the content type of the response from the Solr
     * server.
     * 
     * @return text/xml
     */
    public String getContentType() {
        return "text/xml";
    }

    /**
     * Post the data to the Solr instance. This method posts the current
     * document to the solr instance.
     * 
     * @throws IOException if there is a problem executing the request
     */
    private void postData() throws IOException {
        try {
            URL url = new URL(baseUrl);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("POST");
            conn.setDoOutput(true);
            conn.setDoInput(true);
            conn.setUseCaches(false);
            conn.setAllowUserInteraction(false);
            conn.setRequestProperty("Content-type", "text/xml; charset=UTF-8");
            OutputStreamWriter solrWriter = new OutputStreamWriter(conn.getOutputStream());
            transformer.transform(new DOMSource(doc), new StreamResult(solrWriter));
            solrWriter.flush();
            solrWriter.close();
            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line = null;
            while ((line = rd.readLine()) != null) {
                if (debug) {
                    System.out.println(line);
                }
                if (outWriter != null) {
                    outWriter.write(line);
                    outWriter.write('\n');
                }
            }
            rd.close();
        } catch (TransformerException exc) {
            exc.printStackTrace();
        }
    }

    /**
     * write the data to the Solr instance
     * 
     * @param records the collection of records
     * @param isUpdate whether this is an update of existing records
     * @throws IOException if there is a problem executing the request
     */
    private void sendData(Collection<DataRecord> records, boolean isUpdate) throws IOException {
        if (debug) {
            System.out.println("About to start update: " + records.size() + " records at " + new Date());
        }
        doc = docBuild.newDocument();
        Element addElem = isUpdate ? doc.createElement("update") : doc.createElement("add");
        doc.appendChild(addElem);
        int cnt = 0;
        for (DataRecord rec : records) {
            Element recElem = doc.createElement("doc");
            addElem.appendChild(recElem);
            Set<String> fields = rec.getEnumFieldNames();
            for (String field : fields) {
                Set<String> vals = rec.getEnumValues(field);
                addFieldToElement(recElem, field, vals);
            }
            fields = rec.getIntFieldNames();
            for (String field : fields) {
                Set<Integer> vals = rec.getIntValues(field);
                addFieldToElement(recElem, field, vals);
            }
            fields = rec.getLocationFieldNames();
            for (String field : fields) {
                Set<Location> vals = rec.getLocationValues(field);
                addFieldToElement(recElem, field, vals);
            }
            fields = rec.getMeasureFieldNames();
            for (String field : fields) {
                Set<Measure> vals = rec.getMeasureValues(field);
                addFieldToElement(recElem, field, vals);
            }
            fields = rec.getTextFieldNames();
            for (String field : fields) {
                Set<String> vals = rec.getTextValues(field);
                addFieldToElement(recElem, field, vals);
            }
            fields = rec.getTimeFieldNames();
            for (String field : fields) {
                Set<TimeSpan> vals = rec.getTimeValues(field);
                addTimeToElement(recElem, field, vals);
            }
            cnt++;
            if (writeLimit > 0 && cnt <= writeLimit) {
                postData();
                doc = docBuild.newDocument();
                addElem = doc.createElement("add");
                doc.appendChild(addElem);
                cnt = 0;
            }
        }
    }

    /**
     * Set the debug flag
     * 
     * @param flag the debug flag
     */
    public void setDebug(boolean flag) {
        debug = flag;
    }

    /**
     * Set the destination for this writer. This method sets the base Solr URL
     * for this writer
     * 
     * @param destination the destination for this writer.
     */
    public void setDestination(String destination) {
        baseUrl = destination;
    }

    /**
     * Set the time zone for Date-Time values entered into Solr
     * 
     * @param zone the time zone
     */
    public void setTimeZone(TimeZone zone) {
        format.setTimeZone(zone);
    }

    /**
     * Set the maximum number of records written to the server. The default is
     * 1000.
     * 
     * @param limit the maximum number of records written with a single call
     */
    public void setWriteLimit(int limit) {
        writeLimit = limit;
    }

    /**
     * Sets the internal writer, specifying the output destination.
     * 
     * @param writer the new internal writer
     */
    public void setWriter(Writer writer) {
        outWriter = writer;
    }

    /**
     * Update the solr instance with the set of records. This executes an
     * Update request on the Solr server
     * 
     * @param records the set of records
     * @throws IOException if there is a problem executing the request
     */
    public void updateData(Collection<DataRecord> records) throws IOException {
        sendData(records, true);
    }

    /**
     * Write a command to the solr instance. This writes a simple command, such
     * as commit or optimize.
     * 
     * @param cmd the command to write
     * @throws IOException if there is a problem executing the request
     */
    public void writeCommand(String cmd) throws IOException {
        if (debug) {
            System.out.println("About to write command: " + cmd + " to " + baseUrl);
        }
        URL url = new URL(baseUrl);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setDoOutput(true);
        conn.setDoInput(true);
        conn.setUseCaches(false);
        conn.setAllowUserInteraction(false);
        conn.setRequestProperty("Content-type", "text/xml; charset=UTF-8");
        OutputStreamWriter solrWriter = new OutputStreamWriter(conn.getOutputStream());
        solrWriter.write(cmd, 0, cmd.length());
        solrWriter.flush();
        solrWriter.close();
        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        String line = null;
        while ((line = rd.readLine()) != null) {
            if (debug) {
                System.out.println(line);
            }
            if (outWriter != null) {
                outWriter.write(line);
                outWriter.write('\n');
            }
        }
        rd.close();
    }

    /**
     * Write the collection of records to the Solr instance. This method writes
     * the records, and pushes them to the Solr server with an ADD request.
     * 
     * @param records The collection of records to write
     * @throws IOException if there is a problem executing the request
     */
    public void writeData(Collection<DataRecord> records) throws IOException {
        sendData(records, false);
    }

    /**
     * Write graph data. This method simply calls writeData() with the nodeSet
     * and edgeSet.
     * 
     * @param graph the graph
     */
    public void writeGraph(Graph<DataRecord, DataRecord> graph) {
        try {
            writeData(graph.getNodeSet());
            writeData(graph.getEdgeSet());
        } catch (IOException exc) {
            throw new RuntimeException("Cannot write graph data: ", exc);
        }
    }

    /**
     * Write Grid data
     * 
     * @param grid the grid
     */
    public void writeGrid(Grid<DataRecord> grid) {
        try {
            writeData(grid.getAllValues());
        } catch (IOException exc) {
            throw new RuntimeException("Cannot write grid data: ", exc);
        }
    }

    /**
     * Write tree data
     * 
     * @param tree the tree data
     */
    public void writeTree(Tree<DataRecord> tree) {
        HashSet<DataRecord> recs = new HashSet<DataRecord>();
        for (Iterator<DataRecord> iter = tree.breadthFirstIterator(); iter.hasNext(); ) {
            DataRecord rec = iter.next();
            recs.add(rec);
        }
        try {
            writeData(recs);
        } catch (IOException exc) {
            throw new RuntimeException("Cannot write tree data: ", exc);
        }
    }

    /**
     * Utility main method for this class. This main method simply closes a
     * SolrUpdater instance, which sends a <b>commit</b> and an <b>optimize</b>
     * command to the server
     * 
     * @param args command line arguments. The first argument should be the
     *            address of the Solr server
     * @throws IOException if there is a problem writing to the server
     */
    public static void main(String[] args) throws IOException {
        if (args.length > 0) {
            SolrUpdater updater = new SolrUpdater(args[0]);
            updater.setDebug(true);
            if (args.length > 1) {
                System.out.println("Running " + args[1]);
                updater.writeCommand(args[1]);
            } else {
                updater.close();
            }
        }
    }
}
