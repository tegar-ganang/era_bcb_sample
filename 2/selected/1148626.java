package org.jopen.aws.s3;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSession;
import net.iharder.Base64;
import org.jopen.aws.AWSCredential;
import org.jopen.aws.AWSParameter;
import org.jopen.aws.AWSParameters;
import org.jopen.aws.AWSURLSecurity;
import org.jopen.aws.HttpVerb;
import org.jopen.aws.IAWSConstants;

/**
 * Implements an operation factory for Amazon's S3 storage service. The main purpose of an instance is to generate the
 * <code>HttpURLConnection</code> for a specific S3 operation, including the signing for authentication.
 * 
 * @author Tom Dilatush
 */
public class S3OperationFactory implements IAWSConstants {

    /**
     * HMAC/SHA1 Algorithm per RFC 2104.
     */
    private static final String HMAC_SHA1_ALGORITHM = "HmacSHA1";

    private AWSCredential mCredential;

    private S3URLStyle mStyle;

    private AWSURLSecurity mSecurity;

    private Logger mLogger;

    /**
	 * Creates a new instance of this class with the given characteristics.
	 * 
	 * @param pCredential The <code>AWSCredential</code> for operations generated by this factory.
	 * @param pStyle The <code>S3URLStyle</code> for operations generated by this factory.
	 * @param pSecurity The <code>AWSURLSecurity</code> mode for operations generated by this factory.
	 */
    public S3OperationFactory(AWSCredential pCredential, S3URLStyle pStyle, AWSURLSecurity pSecurity) {
        mCredential = pCredential;
        mStyle = pStyle;
        mSecurity = pSecurity;
        mLogger = Logger.getLogger(getClass().getCanonicalName());
    }

    /**
	 * Creates a new instance of this class with the given credential, secure protocol (HTTPS), and the
	 * sub-domain URL style.
	 * 
	 * @param pCredential The <code>AWSCredential</code> for operations generated by this factory.
	 */
    public S3OperationFactory(AWSCredential pCredential) {
        this(pCredential, S3URLStyle.Subdomain, AWSURLSecurity.Secure);
    }

    /**
	 * Executes the S3 command specified by the given parameters, using the AWS/S3 REST API. 
	 * 
	 * @param pBucket The <code>S3Bucket</code> for this command, or <code>null</code> if there is no bucket.
	 * @param pObject The <code>S3Object</code> for this command, or <code>null</code> if there is no object.
	 * @param pOpParams The <code>S3OperationParameters</code> for this command, or <code>null</code> to use the default
	 * operation parameters.
	 * @return The <code>HttpURLConnection</code> instance for the command, ready to have its input or output streams 
	 * @throws S3Exception on any problem.
	 */
    public HttpURLConnection execute(S3Bucket pBucket, S3Object pObject, S3OperationParameters pOpParams) throws S3Exception {
        S3OperationParameters opParams = pOpParams;
        if (opParams == null) opParams = new S3OperationParameters();
        HttpURLConnection result = null;
        URL url = getURL(pBucket, pObject, opParams.getQueryParameters());
        mLogger.log(Level.FINEST, "URL: " + url.toString());
        opParams.addDateHeader();
        switch(mStyle) {
            case Path:
                opParams.addHostHeader(BASE_DOMAIN);
                break;
            case Subdomain:
                if (pBucket == null) opParams.addHostHeader(BASE_DOMAIN); else opParams.addHostHeader(pBucket.getName() + "." + BASE_DOMAIN);
                break;
            case VirtualHost:
                if (pBucket == null) opParams.addHostHeader(BASE_DOMAIN); else opParams.addHostHeader(pBucket.getName());
                break;
        }
        if (opParams.isSign()) {
            StringBuilder sb = new StringBuilder();
            sb.append(opParams.getVerb().toString());
            sb.append(NEWLINE);
            sb.append(posHeader(MD5, opParams.getRequestHeaders()));
            sb.append(posHeader(TYPE, opParams.getRequestHeaders()));
            if (opParams.getQueryParameters().has(EXPIRES)) {
                sb.append(opParams.getQueryParameters().get(EXPIRES).getValue());
                sb.append(NEWLINE);
            } else {
                sb.append(posHeader(DATE, opParams.getRequestHeaders()));
            }
            sb.append(canonicalizeAmazonHeaders(opParams.getRequestHeaders()));
            try {
                sb.append("/");
                if (pBucket != null) {
                    sb.append(URLEncoder.encode(pBucket.getName(), URL_ENCODING));
                    sb.append("/");
                    if (pObject != null) {
                        sb.append(URLEncoder.encode(pObject.getKey(), URL_ENCODING));
                    }
                }
                sb.append(opParams.getQueryParameters().getAmazonSubresources().toQueryString());
                String signThis = sb.toString();
                mLogger.log(Level.FINEST, "String being signed: " + signThis);
                String sig = encode(mCredential.getMSecretAccessKey(), signThis, false);
                sb = new StringBuilder();
                sb.append("AWS ");
                sb.append(mCredential.getMAccessKeyID());
                sb.append(":");
                sb.append(sig);
                opParams.addAuthorizationHeader(sb.toString());
            } catch (UnsupportedEncodingException e) {
                throw new S3Exception("URL encoding not supported: " + URL_ENCODING, e);
            }
        }
        try {
            killHostVerifier();
            URLConnection urlConn = url.openConnection();
            if (!(urlConn instanceof HttpURLConnection)) throw new S3Exception("URLConnection is not instance of HttpURLConnection!");
            result = (HttpURLConnection) urlConn;
            result.setRequestMethod(opParams.getVerb().toString());
            mLogger.log(Level.FINEST, "HTTP Operation: " + opParams.getVerb().toString());
            if (opParams.getVerb() == HttpVerb.PUT) {
                result.setDoOutput(true);
            }
            result.setRequestProperty(TYPE, "");
            for (AWSParameter param : opParams.getRequestHeaders()) {
                result.setRequestProperty(param.getName(), param.getValue());
                mLogger.log(Level.FINEST, "Header " + param.getName() + ": " + param.getValue());
            }
        } catch (IOException e) {
            throw new S3Exception("Problem opening connection to URL: " + url.toString(), e);
        }
        return result;
    }

    /**
	 * Disables hostname verification during HTTPS certificate validation.  This is necessary for anytime
	 * the bucket name is part of the domain name, as the Amazon certificate is only good for the base domain
	 * name.
	 */
    private void killHostVerifier() {
        HostnameVerifier hv = new HostnameVerifier() {

            public boolean verify(@SuppressWarnings("unused") String urlHostName, @SuppressWarnings("unused") SSLSession session) {
                return true;
            }
        };
        HttpsURLConnection.setDefaultHostnameVerifier(hv);
    }

    private String encode(String awsSecretAccessKey, String canonicalString, boolean urlencode) throws S3Exception {
        SecretKeySpec signingKey = new SecretKeySpec(awsSecretAccessKey.getBytes(), HMAC_SHA1_ALGORITHM);
        Mac mac = null;
        try {
            mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Could not find sha1 algorithm", e);
        }
        try {
            mac.init(signingKey);
        } catch (InvalidKeyException e) {
            throw new RuntimeException("Could not initialize the MAC algorithm", e);
        }
        String b64 = Base64.encodeBytes(mac.doFinal(canonicalString.getBytes()));
        if (urlencode) {
            try {
                b64 = URLEncoder.encode(b64, URL_ENCODING);
            } catch (UnsupportedEncodingException e) {
                throw new S3Exception("URL encoding not supported: " + URL_ENCODING, e);
            }
        }
        return b64;
    }

    private String canonicalizeAmazonHeaders(AWSParameters pHeaders) {
        StringBuilder sb = new StringBuilder();
        List<AWSParameter> amazons = pHeaders.getAmazons();
        Collections.sort(amazons);
        String lastName = "";
        for (int i = 0; i < amazons.size(); i++) {
            if (sb.length() > 0) sb.append(NEWLINE);
            AWSParameter thisParam = amazons.get(i);
            String thisName = thisParam.getName().toLowerCase();
            if (lastName.equals(thisName)) {
                sb.append(",");
                sb.append(thisParam.getValue());
            } else {
                sb.append(thisName);
                sb.append(":");
                sb.append(thisParam.getValue());
            }
        }
        if (sb.length() > 0) sb.append(NEWLINE);
        return sb.toString();
    }

    private String posHeader(String pName, AWSParameters pHeaders) {
        String result = NEWLINE;
        List<AWSParameter> params = pHeaders.getByName(pName);
        if (params.size() > 0) result = params.get(0).getValue() + NEWLINE;
        return result;
    }

    public URL getURL(S3Bucket pBucket, S3Object pObject, AWSParameters pParams) throws S3Exception {
        URL url = null;
        StringBuilder urlStr = null;
        try {
            urlStr = new StringBuilder();
            if (mSecurity == AWSURLSecurity.Insecure) urlStr.append(INSECURE_PREFIX); else urlStr.append(SECURE_PREFIX);
            if ((pBucket != null) && ((mStyle == S3URLStyle.Subdomain) || (mStyle == S3URLStyle.VirtualHost))) urlStr.append(pBucket.getName());
            if ((mStyle == S3URLStyle.Subdomain) || ((pBucket == null) && (mStyle == S3URLStyle.VirtualHost))) {
                if (pBucket != null) urlStr.append(".");
                urlStr.append(BASE_DOMAIN);
            }
            if ((pBucket != null) && (mStyle == S3URLStyle.Path)) {
                urlStr.append("/");
                urlStr.append(URLEncoder.encode(pBucket.getName(), URL_ENCODING));
            }
            urlStr.append("/");
            if (pObject != null) urlStr.append(URLEncoder.encode(pObject.getKey(), URL_ENCODING));
            if (pParams != null) urlStr.append(pParams.toQueryString());
            url = new URL(urlStr.toString());
        } catch (UnsupportedEncodingException e) {
            throw new S3Exception("URL encoding not supported: " + URL_ENCODING, e);
        } catch (MalformedURLException e) {
            throw new S3Exception("Something wrong with the URL: " + urlStr, e);
        }
        return url;
    }

    public AWSCredential getCredential() {
        return mCredential;
    }

    public void setCredential(AWSCredential pCredential) {
        mCredential = pCredential;
    }

    public AWSURLSecurity getSecurity() {
        return mSecurity;
    }

    public void setSecurity(AWSURLSecurity pSecurity) {
        mSecurity = pSecurity;
    }

    public S3URLStyle getStyle() {
        return mStyle;
    }

    public void setStyle(S3URLStyle pStyle) {
        mStyle = pStyle;
    }
}
