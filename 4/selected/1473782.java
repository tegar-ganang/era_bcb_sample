package gov.lanl.JavaButton;

import com.ibutton.oc.*;
import com.ibutton.oc.CommandAPDU;
import opencard.core.terminal.*;
import com.ibutton.opt.jibletselect.Selector;
import java.io.*;

/**Implements the host services for the Java Button from Dallas Semiconductor.
	 * Built by filling in the template generated by IB_IDE...
	 * @author Jim George
	 * @version $Revision: 111 $ $Date: 2000-10-12 18:24:32 -0400 (Thu, 12 Oct 2000) $
	 */
public class OpenEMedKS_Host implements JibMultiListener {

    public static final byte OPENEMEDKS_CLA = (byte) 0x80;

    public static final byte OPENEMEDKS_INS_ERASE = (byte) 0;

    public static final byte OPENEMEDKS_INS_SET_SIZE = (byte) 1;

    public static final byte OPENEMEDKS_INS_GET_SIZE = (byte) 2;

    public static final byte OPENEMEDKS_INS_SAVE_FIRST = (byte) 3;

    public static final byte OPENEMEDKS_INS_SAVE_NEXT = (byte) 4;

    public static final byte OPENEMEDKS_INS_GET_FIRST = (byte) 5;

    public static final byte OPENEMEDKS_INS_GET_NEXT = (byte) 6;

    public static final byte CMD_CLA = (byte) 0xD0;

    public static final byte CMD_INS = (byte) 0x95;

    public static final byte CMD_INFO_P1 = (byte) 0x01;

    public static final byte CMD_FREERAM_P2 = (byte) 0x01;

    public static final byte CMD_GETEGC_P2 = (byte) 0x02;

    public static final byte CMD_GETAGC_P2 = (byte) 0x03;

    public static final byte CMD_ADMIN_P1 = (byte) 0x00;

    public static final byte CMD_SETEGC_P2 = (byte) 0x02;

    public static final byte CMD_SETAGC_P2 = (byte) 0x03;

    /**Has a master pin of zero length, and and enable byte*/
    public static final byte[] MP_DATA_ENABLE = new byte[] { (byte) 0x00, (byte) 0x01 };

    private int MAX_SEND_LENGTH = 240;

    /**Index of next byte of data to send*/
    private int nextPos = 0;

    /**Controls output for debugging*/
    private boolean verbose;

    protected JibMultiFactory factory;

    private String appletName;

    private String appletPath;

    /**
     * Sets up the listener for iButton inserted and iButton
     * removed events.
     *
     * @param appletPath  the path to the applet that should
     *                    be loaded into the iButtons.
     * @param appletName  the name of the applet that should
     *                    be loaded into the iButtons.
     */
    public OpenEMedKS_Host(String appletPath, String appletName, boolean verbose) {
        this.appletName = appletName;
        this.appletPath = appletPath;
        this.verbose = verbose;
        factory = new JibMultiFactory();
        factory.addJiBListener(this);
        try {
            factory.startPolling(true);
        } catch (CardTerminalException cte) {
            cte.printStackTrace();
        }
    }

    /**Set the verbose flag to control debugging output
       * @param verbose is the new value
       */
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    /**
     * Adds the specified iButton listener to receive
     * iButton inserted and removed events.
     *
     * @param l  the listener.
     */
    public void addJiBListener(JibMultiListener l) {
        factory.addJiBListener(l);
    }

    /**
     * Removes the specified iButton listener so that
     * the listener no longer receives iButton inserted
     * and removed events.
     *
     * @param l  the listener.
     */
    public void removeJiBListener(JibMultiListener l) {
        factory.removeJiBListener(l);
    }

    /**
     * Called when an iButton gets inserted.
     *
     * @param event  the insertion event.
     */
    public void iButtonInserted(JibMultiEvent event) {
        String password = "";
        factory.setSlot(event.getSlotID());
        try {
            Selector appletSelector = new Selector(false);
            if (appletSelector.select(appletPath, appletName + ".jib", appletName, event.getChannel(), password)) {
            } else {
                int sw = appletSelector.getLastStatusWord();
                System.out.println("Applet load failed: " + Integer.toHexString(sw));
                System.out.println("Reason : " + decodeSW(sw));
            }
        } catch (CardTerminalException cte) {
            System.err.println("ERROR:  CardTerminalException occurred while communicating with iButton.");
        } catch (FileNotFoundException fnfe) {
            System.err.println("Unable to find file: " + appletName + ".jib");
        } catch (IOException ioe) {
            System.err.println("Unable to read file: " + appletName + ".jib");
        } catch (Exception e) {
            System.err.println("Exception in iButtonInserted:");
            e.printStackTrace();
        }
    }

    /**
     * Called when an iButton is removed.
     *
     * @param event  the removal event.
     */
    public void iButtonRemoved(JibMultiEvent event) {
        try {
        } catch (Exception e) {
            System.err.println("Exception in iButtonRemoved:");
            e.printStackTrace();
        }
    }

    /**
     * Will interpret a status word into a string describing
     * the meaning of that status word..
     *
     * @param sw  the status word to decode.
     *
     * @return the string describing the status.
     */
    private String decodeSW(int sw) {
        if (verbose) System.out.print(Integer.toHexString(sw) + " - ");
        switch(sw) {
            case 0x6100:
                return "Response Bytes Remaining";
            case 0x6301:
                return "Success Packet";
            case 0x6400:
                return "Insufficient Memory";
            case 0x6681:
                return "Bad Master PIN";
            case 0x6700:
                return "Wrong Length";
            case 0x6901:
                return "Invalid AID Length";
            case 0x6902:
                return "\r\nInvalid API Version\r\n" + "-------------------\r\n" + "This error occurred because the applet (.jib file) was not built\r\n" + "for this kind of Java Powered iButton.\r\n\r\n" + "To correct this error from iB-IDE, go to the COMPILE menu and\r\n" + "select OPTIONS.  Choose the correct version of Java Powered\r\n" + "iButton from the drop down box under \"Target iButton Firmware\".\r\n" + "Alternatively, if you have the iButton attached that you are\r\n" + "building for, you can press the AUTO DETECT button.  Otherwise\r\n" + "you will need to get the Firmware version using APDU Sender\r\n" + "(press F4 to start APDU Sender and select Read Firmware Version\r\n" + "String from the list of commands, then hit GO).\r\n\r\n";
            case 0x6903:
                return "Invalid Password";
            case 0x6904:
                return "Invalid Signature Length";
            case 0x6905:
                return "Hash Corruption";
            case 0x6906:
                return "Hash Failure";
            case 0x6982:
                return "Invalid Signature";
            case 0x6984:
                return "Data Invalid";
            case 0x6985:
                return "Conditions Of Use Not Satisfied";
            case 0x6A80:
                return "Wrong Data";
            case 0x6A81:
                return "Function Not Supported";
            case 0x6A82:
                return "Unable to Select Applet";
            case 0x6A84:
                return "Class Length Overrun";
            case 0x6A86:
                return "Invalid Loader Command";
            case 0x6A87:
                return "Incomplete Packet";
            case 0x6B00:
                return "Incorrect Parameters (P1,P2)";
            case 0x6C00:
                return "Correct Expected Length";
            case 0x6D00:
                return "INS Value Not Supported";
            case 0x6F00:
                StringBuffer sb = new StringBuffer("Uncaught Exception: ");
                try {
                    ResponseAPDU res = factory.getLastError();
                    int err = 0x0ff & res.data()[0];
                    sb.append("Last Error reported as 0x");
                    if (err < 16) sb.append('0');
                    sb.append(Integer.toHexString(err));
                } catch (Exception e) {
                    sb.append("Could not getLastError!");
                }
                return sb.toString();
            case 0x8450:
                return "Unable to Find Applet";
            case 0x8453:
                return "Unable to Select Applet";
            case 0x9000:
                return "Success";
            default:
                StringBuffer unrec = new StringBuffer("Unrecognized SW ");
                if (sw < 0x1000) unrec.append('0');
                if (sw < 0x100) unrec.append('0');
                if (sw < 0x10) unrec.append('0');
                unrec.append(Integer.toHexString(sw));
                return unrec.toString();
        }
    }

    public int getFreeMem() throws CardTerminalException {
        ResponseAPDU response;
        response = factory.sendAPDU(new CommandAPDU((byte) CMD_CLA, (byte) CMD_INS, (byte) CMD_INFO_P1, (byte) CMD_FREERAM_P2, null, (byte) 0));
        String responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr + "  " + response.data().length + " bytes returned");
        byte[] retData = new byte[4];
        for (int i = 0; i < retData.length; i++) retData[i] = (byte) 0;
        int len = response.data().length;
        for (int i = 0; i < len; i++) retData[retData.length - 1 - i] = response.data()[i];
        return intFromByteArray(retData, 0);
    }

    public byte[] getGcs() throws CardTerminalException {
        ResponseAPDU response;
        byte[] retData = new byte[] { (byte) 0, (byte) 0 };
        response = factory.sendAPDU(new CommandAPDU((byte) CMD_CLA, (byte) CMD_INS, (byte) CMD_INFO_P1, (byte) CMD_GETEGC_P2, null, (byte) 0));
        String responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr + "  " + response.data().length + " bytes returned");
        retData[0] = response.data()[0];
        response = factory.sendAPDU(new CommandAPDU((byte) CMD_CLA, (byte) CMD_INS, (byte) CMD_INFO_P1, (byte) CMD_GETAGC_P2, null, (byte) 0));
        responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr + "  " + response.data().length + " bytes returned");
        retData[1] = response.data()[0];
        return retData;
    }

    public void setGcs() throws CardTerminalException {
        ResponseAPDU response;
        response = factory.sendAPDU(new CommandAPDU((byte) CMD_CLA, (byte) CMD_INS, (byte) CMD_ADMIN_P1, (byte) CMD_SETEGC_P2, MP_DATA_ENABLE, (byte) 0));
        String responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr + " for setting EGC");
        response = factory.sendAPDU(new CommandAPDU((byte) CMD_CLA, (byte) CMD_INS, (byte) CMD_ADMIN_P1, (byte) CMD_SETAGC_P2, MP_DATA_ENABLE, (byte) 0));
        responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr + " for setting AGC");
    }

    public void set_sizeDispatch(int dataSize) throws CardTerminalException {
        ResponseAPDU response;
        byte[] desiredSize = new byte[4];
        intToByteArray(desiredSize, 0, dataSize);
        response = factory.sendAPDU(new CommandAPDU((byte) OPENEMEDKS_CLA, (byte) OPENEMEDKS_INS_SET_SIZE, (byte) 0x0, (byte) 0x0, desiredSize, (byte) 0));
        String responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr);
    }

    public void set_sizeDispatch(int dataSize, int slotNumber) throws CardTerminalException {
        factory.setSlot(slotNumber);
        set_sizeDispatch(dataSize);
    }

    public int get_sizeDispatch() throws CardTerminalException, Exception {
        ResponseAPDU response;
        response = factory.sendAPDU(new CommandAPDU((byte) OPENEMEDKS_CLA, (byte) OPENEMEDKS_INS_GET_SIZE, (byte) 0x0, (byte) 0x0, null, (byte) 0));
        String responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr);
        if (response.sw() == 0x9000) {
            int sizeData = intFromByteArray(response.data(), 0);
            return sizeData;
        } else throw new Exception("No size returned from button");
    }

    public int get_sizeDispatch(int slotNumber) throws CardTerminalException, Exception {
        factory.setSlot(slotNumber);
        return get_sizeDispatch();
    }

    void doSendSaveAPDU(byte[] saveData, byte cmd) throws CardTerminalException {
        ResponseAPDU response;
        int numToSend;
        if ((saveData.length - nextPos) > MAX_SEND_LENGTH) numToSend = MAX_SEND_LENGTH; else numToSend = saveData.length - nextPos;
        byte[] dataToSend = new byte[numToSend];
        for (int i = 0; i < numToSend; i++) dataToSend[i] = saveData[i + nextPos];
        nextPos = nextPos + numToSend;
        response = factory.sendAPDU(new CommandAPDU((byte) OPENEMEDKS_CLA, cmd, (byte) 0x0, (byte) 0x0, dataToSend, (byte) 0));
        String responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr + " for " + numToSend + " bytes");
    }

    public void save_firstDispatch(byte[] saveData) throws CardTerminalException {
        nextPos = 0;
        doSendSaveAPDU(saveData, (byte) OPENEMEDKS_INS_SAVE_FIRST);
    }

    public void save_firstDispatch(byte[] saveData, int slotNumber) throws CardTerminalException {
        factory.setSlot(slotNumber);
        save_firstDispatch(saveData);
    }

    public void save_nextDispatch(byte[] saveData) throws CardTerminalException {
        doSendSaveAPDU(saveData, (byte) OPENEMEDKS_INS_SAVE_NEXT);
    }

    public void save_nextDispatch(byte[] saveData, int slotNumber) throws CardTerminalException {
        factory.setSlot(slotNumber);
        save_nextDispatch(saveData);
    }

    /**Set the size on the button and transfer all of the data
      * to the java button
      * @param endData is the data to send
      * @exception CartTerminalException for an error from the button
      * @exception Exception for data buffer sizing problems
      */
    public void sendByteBuffer(byte[] sendData) throws CardTerminalException, Exception {
        nextPos = 0;
        set_sizeDispatch(sendData.length);
        save_firstDispatch(sendData);
        while (nextPos < sendData.length) save_nextDispatch(sendData);
    }

    /**Gets the data from the java button for both get_first
       * and get next
       * @param getData is the byte array to hold the received data
       * starting at nextPos
       * @param cmd is the command, either get_first or get_next..
       * @exception CartTerminalException for an error from the button
       * @exception Exception for data buffer sizing problems
       */
    void doSendGetAPDU(byte[] getData, byte cmd) throws CardTerminalException, Exception {
        ResponseAPDU response;
        response = factory.sendAPDU(new CommandAPDU((byte) OPENEMEDKS_CLA, cmd, (byte) 0x0, (byte) 0x0, null, (byte) 0));
        String responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr + " for " + response.data().length + " bytes");
        int numToMove;
        if ((getData.length - nextPos) < response.data().length) throw new Exception("Data overrun");
        for (int i = 0; i < response.data().length; i++) getData[i + nextPos] = response.data()[i];
        nextPos = nextPos + response.data().length;
    }

    public void get_firstDispatch(byte[] getData) throws CardTerminalException, Exception {
        nextPos = 0;
        doSendGetAPDU(getData, (byte) OPENEMEDKS_INS_GET_FIRST);
    }

    public void get_firstDispatch(byte[] getData, int slotNumber) throws CardTerminalException, Exception {
        factory.setSlot(slotNumber);
        get_firstDispatch(getData);
    }

    public void get_nextDispatch(byte[] getData) throws CardTerminalException, Exception {
        doSendGetAPDU(getData, (byte) OPENEMEDKS_INS_GET_NEXT);
    }

    public void get_nextDispatch(byte[] getData, int slotNumber) throws CardTerminalException, Exception {
        factory.setSlot(slotNumber);
        get_nextDispatch(getData);
    }

    /**Get the data from the java button and return it.
       * @return a byte array with the data from the java button
       * @exception CartTerminalException for an error from the button
       * @exception Exception for data buffer sizing problems
       */
    public byte[] getByteBuffer() throws CardTerminalException, Exception {
        nextPos = 0;
        int bufSize = get_sizeDispatch();
        byte[] bufData = new byte[bufSize];
        get_firstDispatch(bufData);
        while (nextPos < bufSize) get_nextDispatch(bufData);
        return bufData;
    }

    public void eraseDispatch() throws CardTerminalException {
        ResponseAPDU response;
        response = factory.sendAPDU(new CommandAPDU((byte) OPENEMEDKS_CLA, (byte) OPENEMEDKS_INS_ERASE, (byte) 0x0, (byte) 0x0, null, (byte) 0));
        String responseStr = decodeSW(response.sw());
        if (verbose) System.out.println(responseStr);
    }

    public void eraseDispatch(int slotNumber) throws CardTerminalException {
        factory.setSlot(slotNumber);
        eraseDispatch();
    }

    public static int intFromByteArray(byte[] inArray, int start) {
        return (((int) inArray[start] << 24) & 0xFF000000 | ((int) inArray[start + 1] << 16) & 0x00FF0000 | ((int) inArray[start + 2] << 8) & 0x0000FF00 | ((int) inArray[start + 3]) & 0x000000FF);
    }

    public static void intToByteArray(byte[] outArray, int start, int value) {
        outArray[start] = (byte) ((value & 0xFF000000) >>> 24);
        outArray[start + 1] = (byte) ((value & 0x00FF0000) >>> 16);
        outArray[start + 2] = (byte) ((value & 0x0000FF00) >>> 8);
        outArray[start + 3] = (byte) (value & 0x000000FF);
    }
}
