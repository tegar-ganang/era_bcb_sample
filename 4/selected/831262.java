package gov.nasa.jpf.tools.visualize;

import gov.nasa.jpf.Config;
import gov.nasa.jpf.JPF;
import gov.nasa.jpf.jvm.choice.sc.SCEventGenerator;
import gov.nasa.jpf.sc.State;
import gov.nasa.jpf.search.Search;
import gov.nasa.jpf.tools.ChoiceTracker;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Observable;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This is the model of the Visualize GUI.  The main component contained
 * and controlled by the model is the VisualSimStateMachine. Notifies any Views 
 * of changes based on the Observer design pattern.  
 * 
 * The following objects are passed with notifications to observers:
 * An Notification enum constant, for animation related messages.
 * A Status enum constant, for updates on permissions.
 * A String, which indicates an error and holds an error message.
 * 
 * 
 * @author Carl Albach
 *
 */
public class VisualModel extends Observable {

    static final int MIN_ANIMATION_SPEED = 2000;

    static final int MAX_ANIMATION_SPEED = 200;

    static final int TIMER_INIT_DELAY = 50;

    static final String NEW_LINE = System.getProperty("line.separator");

    private VisualSimStateMachine stateMachine;

    private PrintStream machineLog;

    private Config selectedConfig;

    private ArrayList<String> erroneousPaths;

    private int animationSpeed;

    /**
	 *  Passed to observers to specify what needs to be updated in the GUI.  Not
	 *  REALLY necessary to send such specific notifications, but it saves some 
	 *  unnecessary redrawing of the diagram, which may be expensive.
	 */
    static enum Notification {

        DIAGRAM_INIT, CLEAR, NEW_ERRORS, TERMINATE
    }

    /**
	 * Status gives information about permissions of the current model.
	 */
    static enum Status {

        INITIAL, ARGS_CHOSEN, ERRORS_GENERATED, ANIMATING, FINISHED
    }

    private Status status;

    /**
	 * Creates a new model with uninitialized JPF args and a status of INITIAL.
	 */
    public VisualModel() {
        erroneousPaths = new ArrayList<String>();
        animationSpeed = (MIN_ANIMATION_SPEED - MAX_ANIMATION_SPEED) / 2;
        status = Status.INITIAL;
        cleanTemp();
    }

    /**
	 * 
	 * Setter for selectedArgs. Also initializes the diagram.
	 * 
	 * @param args Contains JPF args separated by new lines.
	 */
    public void setSelectedArgs(String args) {
        clearAnimation();
        erroneousPaths.clear();
        stateMachine = new VisualSimStateMachine(machineLog);
        Scanner s = new Scanner(args);
        scanArgs(s);
        Config smConfig = JPF.createConfig(selectedConfig.getTargetArgParameters());
        if (!stateMachine.initializeMachine(smConfig)) {
            error("Error initializing StateMachine");
        } else if (!stateMachine.hasMasterState()) {
            error("Could not locate a masterState");
        } else {
            updateStatus(Status.ARGS_CHOSEN);
            initDiagram();
            setChanged();
            notifyObservers(Notification.NEW_ERRORS);
            clearChanged();
        }
    }

    /**
	 * Helper method to scan arguments and set the selected args.
	 * 
	 * @param s Scanner for text containing JPF args separated by new lines.
	 */
    private void scanArgs(Scanner s) {
        ArrayList<String> argsArray = new ArrayList<String>();
        do {
            String next = s.nextLine();
            if (!next.trim().equals("")) argsArray.add(next);
        } while (s.hasNextLine());
        selectedConfig = JPF.createConfig(argsArray.toArray(new String[argsArray.size()]));
    }

    /**
	 * Setter for animationSpeed.
	 * 
	 * @param animationSpeed Should be a value between ANIMATION_MAX, and ANIMATION_MIN
	 */
    public void setSpeed(int animationSpeed) {
        this.animationSpeed = animationSpeed;
    }

    /**
	 * The View should use this method to stream state machine logging to the target of
	 * its choice.
	 * 
	 * @param log PrintStream to write logging info to.
	 */
    public void setMachineOut(PrintStream log) {
        machineLog = log;
    }

    /**
	 * Getter for animationSpeed
	 * @return the speed of animation in millisec
	 */
    public int getSpeed() {
        return animationSpeed;
    }

    /**
	 * Get the current status of the model.  Used to determine permissions.
	 * 
	 * @return the current status.
	 */
    public Status getStatus() {
        return status;
    }

    /**
	 * Gets the number of errors generated by the latest JPF run.
	 * 
	 * @return Number of errors generated.
	 */
    public int getNumErrors() {
        return erroneousPaths.size();
    }

    /**
	 * @return a list of the currently active states of the state machine.
	 */
    public List<State> getActiveStates() {
        return stateMachine.getCurrentActiveStates();
    }

    /**
	 * @return a map from state to state of the transitions which occurred during the
	 * last step.
	 */
    public Map<State, State> getTransitions() {
        return stateMachine.getTransitions();
    }

    /**
	 * @return the master state of the current state machine.
	 */
    public State getMasterState() {
        return stateMachine.getMasterState();
    }

    /**
	 * Call this upon termination of the program.
	 */
    public void dispose() {
        if (choiceTrace != null) choiceTrace.delete();
    }

    File choiceTrace;

    /**
	 * Precondition: A JPF run must have already occurred and produced at least
	 * one property violation. Should not be used in status INITIAL or ARGS_CHOSEN.
	 * 
	 * Writes a temporary script file which holds the choice trace of the given
	 * erroneous event sequence.  In the specified arguments, this script then 
	 * replaces any script file that may have been specified and the StateMachine
	 * is initialized.  Diagram is initialized in the view.
	 * 
	 * @param errorNumber - This number corresponds to the error as found and labeled
	 * by the JPF run.
	 * 
	 */
    public void initializeVisualStateMachine(int errorNumber) {
        if (erroneousPaths.isEmpty()) return;
        if (choiceTrace != null) {
            choiceTrace.delete();
        }
        clearAnimation();
        BufferedWriter bw;
        try {
            choiceTrace = File.createTempFile("tempScript", ".es");
            choiceTrace.deleteOnExit();
            bw = new BufferedWriter(new FileWriter(choiceTrace));
        } catch (IOException e) {
            error("Problem writing to or creating script file.", e);
            return;
        }
        Scanner scan = new Scanner(erroneousPaths.get(errorNumber));
        try {
            for (String x = ""; scan.hasNextLine(); x = scan.nextLine()) bw.write(x + NEW_LINE);
            bw.close();
        } catch (IOException e) {
            error("Problem writing to script file.", e);
            return;
        }
        if (!stateMachine.hasMasterState()) {
            error("No state machine specified in JPF arguments.");
            return;
        }
        stateMachine = new VisualSimStateMachine(machineLog);
        Config errorConfig = JPF.createConfig(selectedConfig.getTargetArgParameters());
        errorConfig.setProperty("sc.script", choiceTrace.getPath());
        if (!stateMachine.initializeMachine(errorConfig)) {
            error("Problem initializing the StateMachine.");
        }
        choiceTrace.delete();
        updateStatus(Status.ERRORS_GENERATED);
        initDiagram();
    }

    /**
	 * Creates or saves a JPF run configuration file to the specified location.
	 * 
	 * @param name The name of the file.
	 * @param text The text containing the JPF arguments.
	 */
    public boolean saveConfigFile(String fileName, String text) {
        File config = new File(fileName);
        if (!config.exists()) {
            try {
                config.createNewFile();
            } catch (IOException e) {
                error("Error creating file.", e);
                return false;
            }
        }
        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(config, false));
            writer.write(text);
            writer.close();
        } catch (IOException e) {
            error("Error saving to file.", e);
            return false;
        }
        return true;
    }

    /**
	 * Redirects the output of the ChoiceTracker and sends it to a StringWriter.
	 * The state of the StringWriter is stored after every propertyViolation,
	 * and then the StringWriter's StringBuffer is cleared (manually).  This is
	 * a work-around to keep the original functionality of ChoiceTracker as
	 * intact as possible.
	 */
    private class VisualListener extends ChoiceTracker {

        StringWriter sw;

        public VisualListener(JPF jpf, String fileName) {
            super(jpf, fileName, SCEventGenerator.class);
            sw = new StringWriter();
            super.pw = new PrintWriter(sw);
        }

        public void propertyViolated(Search search) {
            super.propertyViolated(search);
            pw.flush();
            if (sw.getBuffer().length() > 0) {
                erroneousPaths.add(sw.toString());
                sw.getBuffer().delete(0, sw.getBuffer().length() - 1);
            }
        }
    }

    /**
	 * Precondition : Not in status INITIAL
	 * 
	 * Runs JPF given the selected arguments.
	 */
    public void runJPF() {
        if (status == Status.INITIAL) wrongStatus();
        updateStatus(Status.ARGS_CHOSEN);
        clearAnimation();
        String fileName = "";
        try {
            fileName = File.createTempFile("choice", "trace").getPath();
        } catch (IOException e) {
            error("Coudldn't create temp file", e);
            return;
        }
        erroneousPaths.clear();
        JPF jpf = new JPF(selectedConfig);
        jpf.addListener(new VisualListener(jpf, fileName));
        jpf.run();
        setChanged();
        notifyObservers(Notification.NEW_ERRORS);
        clearChanged();
        if (!erroneousPaths.isEmpty()) {
            updateStatus(Status.ERRORS_GENERATED);
            initializeVisualStateMachine(0);
        }
    }

    /**
	 * Precondition : VisualModel has ERRORS_GENERATED status.
	 * 
	 * Begins animation.  Allows access to methods controlling animation and
	 * ensures that the current state is visible.
	 */
    public boolean startAnimation() {
        if (status != Status.ERRORS_GENERATED) wrongStatus();
        updateStatus(Status.ANIMATING);
        return true;
    }

    /**
	 * Preconditions : status is ANIMATING or ERRORS_GENERATED
	 * 
	 * Performs one step through the stateMachine. If no more stepping is permitted
	 * the animation is terminated.
	 */
    public boolean step() {
        if (status == Status.ERRORS_GENERATED) {
            return startAnimation();
        }
        if (status != Status.ANIMATING) wrongStatus();
        if (!stateMachine.manualStep()) {
            terminateRun();
            return false;
        } else {
            return true;
        }
    }

    private void updateStatus(Status s) {
        status = s;
        setChanged();
        notifyObservers(s);
        clearChanged();
    }

    private void initDiagram() {
        setChanged();
        notifyObservers(Notification.DIAGRAM_INIT);
        clearChanged();
    }

    /**
	 * Resets the diagram and errors. Sends a message to the view to
	 * clear the diagram, JPFoutput and errors. 
	 */
    private void clearAnimation() {
        setChanged();
        notifyObservers(Notification.CLEAR);
        clearChanged();
    }

    /**
	 * Ends the StateMachine run.
	 */
    private void terminateRun() {
        updateStatus(Status.FINISHED);
        if (choiceTrace != null) {
            choiceTrace.delete();
        }
        setChanged();
        notifyObservers(Notification.TERMINATE);
        clearChanged();
    }

    /**
	 * Precondition: ANIMATING
	 * 
	 * Stops automatic animation.
	 */
    public void pauseAnimation() {
        if (status != Status.ANIMATING) wrongStatus();
    }

    /**Precondition: ANIMATING
	 * 
	 * Starts automatic animation.
	 */
    public void playAnimation() {
        if (status != Status.ANIMATING) wrongStatus();
    }

    public static void cleanTemp() {
        File temp = new File(System.getProperty("java.io.tmpdir"));
        File[] files = temp.listFiles(new FilenameFilter() {

            private Pattern p = Pattern.compile("^(choice\\d+trace)|(tempScript\\d+.es)|(scdiagram\\d+(dot|plain))$");

            public boolean accept(File file, String name) {
                Matcher m = p.matcher(name);
                return m.matches();
            }
        });
        for (File f : files) {
            if (f.isFile()) f.delete();
        }
    }

    private void wrongStatus() {
        throw new RuntimeException("VisualModel does not have the correct status to perform this action.");
    }

    public void error(String message) {
        setChanged();
        notifyObservers(message);
        clearChanged();
    }

    public void error(String message, Exception e) {
        error(message + "\n" + e.getMessage());
    }
}
