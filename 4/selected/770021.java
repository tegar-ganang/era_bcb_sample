package eu.davidgamez.mas.midi;

import javax.sound.midi.*;
import java.util.Collection;
import java.util.HashMap;
import java.util.TreeMap;
import java.util.ArrayList;
import java.util.Vector;
import eu.davidgamez.mas.event.TransportListener;
import eu.davidgamez.mas.midi.*;
import eu.davidgamez.mas.*;
import eu.davidgamez.mas.exception.*;
import eu.davidgamez.mas.event.*;
import eu.davidgamez.mas.gui.MsgHandler;

/**
 * ---------------------------- MIDISequencer ---------------------------------
 * The class that handles the playing of the notes generated by the agents.
 * //#FIXME# THIS CLASS CANNOT CURRENTLY HANDLE SEVERAL MIDI INPUT OR OUTPUT
 * DEVICES WITH THE SAME NAME
 * 
 * FIXME: CONNECT TO EXIT EVENT AND CLOSE DEVICES
 * -----------------------------------------------------------------------------
 */
public class MASSequencer implements Constants, TransportListener, BufferListener {

    /** Class that plays MIDI messages as a separate thread. */
    private MIDIPlayer midiPlayer = new MIDIPlayer();

    /** Class that plays OSC messages as a separate thread. */
    private MIDIPlayer oscPlayer = new MIDIPlayer();

    /** Constructor */
    public MASSequencer() {
        Buffer.init();
        EventRouter.addBufferListener(this);
        EventRouter.addTransportListener(this);
    }

    /** Method inherited from TransportListener interface */
    public void killNotesActionPerformed() {
        if (midiPlayer.isPlaying()) stop();
        ShortMessage noteOffMsg = new ShortMessage();
        try {
            ArrayList<Receiver> receiverArrayList = MIDIDeviceManager.getReceiverArrayList();
            Collection<Track> trackList = TrackHolder.getTracks();
            HashMap<Integer, Boolean> channelUpdateMap = new HashMap<Integer, Boolean>();
            for (Track tmpTrk : trackList) {
                if (!channelUpdateMap.containsKey(new Integer(tmpTrk.getChannel()))) {
                    for (Receiver receiver : receiverArrayList) {
                        for (int notePitch = 0; notePitch < 127; ++notePitch) {
                            noteOffMsg.setMessage(ShortMessage.NOTE_OFF, tmpTrk.getChannel(), notePitch, 0);
                            receiver.send(noteOffMsg, -1);
                        }
                    }
                    channelUpdateMap.put(new Integer(tmpTrk.getChannel()), new Boolean(true));
                }
            }
        } catch (Exception ex) {
            MsgHandler.error(ex);
        }
    }

    /** Method inherited from TransportListener interface.
	 * Play is initiated by the agent handler when enough buffers have been filled up.
	 */
    public void playActionPerformed() {
    }

    public void stopActionPerformed() {
    }

    /** The invocation of this method is controlled by the agent handler
	    when enough buffers have been filled up */
    public void play() {
        if (!midiPlayer.isPlaying()) {
            midiPlayer = new MIDIPlayer();
            midiPlayer.start();
        }
    }

    public void stop() {
        System.out.println("Stopping sequencer.");
        if (!midiPlayer.isPlaying()) return;
        midiPlayer.stopThread();
        try {
            midiPlayer.join(5000);
        } catch (InterruptedException e) {
            MsgHandler.critical("Exception thrown waiting for MIDI Player to stop");
            e.printStackTrace();
        }
        if (midiPlayer.isError()) MsgHandler.critical(midiPlayer.getErrorMessage());
        Buffer.reset();
    }

    /** Method inherited from BufferListener */
    public void endLoadBufferAdvanceOccurred(long bufferCount) {
    }

    /** Method inherited from BufferListener */
    public void startLoadBufferAdvanceOccurred(long bufferCount) {
    }

    /** Unused method from BufferListener interface */
    public void playBufferAdvanceOccurred(long bufferCount) {
    }

    /** Unused method from BufferListener interface */
    public void trackAdvanceOccurred(long tickCount) {
    }

    /** Resets all buffers etc. */
    public void reset() {
        Buffer.reset();
    }
}
