package org.jostraca;

import org.jostraca.util.PropertySet;
import org.jostraca.util.PropertySetManager;
import org.jostraca.util.OrderedPropertySetManager;
import java.io.File;
import java.util.Hashtable;

/** 
 *  Default Jostraca writer formats. Used if writer format files cannot be found.
 */
public class DefaultWriterFormats {

    public static Hashtable sWriterFormats = new Hashtable();

    static {
        makeWF_BasicJavaWriterFormat_jwf(sWriterFormats);
        makeWF_BasicPerlWriterFormat_jwf(sWriterFormats);
        makeWF_BasicPythonWriterFormat_jwf(sWriterFormats);
        makeWF_BasicRubyWriterFormat_jwf(sWriterFormats);
        makeWF_BasicCWriterFormat_jwf(sWriterFormats);
        makeWF_BasicRebolWriterFormat_jwf(sWriterFormats);
        makeWF_BasicJythonWriterFormat_jwf(sWriterFormats);
        makeWF_BasicJavaScriptWriterFormat_jwf(sWriterFormats);
        makeWF_BasicJavaComponent_jwf(sWriterFormats);
        makeWF_JavaComponent_jwf(sWriterFormats);
    }

    public static final String makeCanonicalWriterFormatName(String pName) {
        File wff = new File(pName);
        return wff.getName();
    }

    public static final boolean hasWriterFormat(String pCanonicalName) {
        return sWriterFormats.containsKey(pCanonicalName);
    }

    public static final String getWriterFormat(String pCanonicalName) {
        return (String) sWriterFormats.get(pCanonicalName);
    }

    private static final void makeWF_BasicJavaWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicJavaWriterFormat.jwf", "!<header>\n\n\n\n$<{java.CodeWriter.package>package $<java.CodeWriter.package>;$<}java.CodeWriter.package>\n\n\n\nimport java.io.*;\nimport java.util.*;\n\n\n\n\n!<{import>// section:import\n!<import>!<}import>\n\n\n\npublic class $<main.CodeWriter> \n$<{java.CodeWriter.extends>  extends $<java.CodeWriter.extends> $<}java.CodeWriter.extends> \n$<{java.CodeWriter.implements>  implements $<java.CodeWriter.implements> $<}java.CodeWriter.implements>\n{\n\n  /* Constants << */\n \n  // Command line arguments\n  public static final String WRITER__ARGUMENT_CONTROL_PREFIX = \"$<main.CodeWriter.argument.ControlPrefix>\";\n  public static final String WRITER__ARGUMENT_OutputFolder   = \"$<main.CodeWriter.argument.name.OutputFolder>\";\n  public static final String WRITER__ARGUMENT_MetaPropFile   = \"$<main.CodeWriter.argument.name.MetaPropFile>$<main.CodeWriter.argument.name.BuildPropFile>\";\n  public static final String WRITER__ARGUMENT_BackupFolder   = \"$<main.CodeWriter.argument.name.BackupFolder>\";\n  public static final String WRITER__ARGUMENT_NoBackup       = \"$<main.CodeWriter.argument.name.NoBackup>\";\n\n  // User Interface text message parts\n  public static final String WRITER__UITEXT_Method                     = \"method \";\n  public static final String WRITER__UITEXT_Main                       = \"main \";\n  public static final String WRITER__UITEXT_ExceptionIn                = \"Exception in \";\n  public static final String WRITER__UITEXT_ColonNewLine               = \":\\n\";\n  public static final String WRITER__UITEXT_NewLine                    = \"\\n\";\n  public static final String WRITER__UITEXT_Section                    = \"section \";\n  public static final String WRITER__UITEXT_SavedFile                  = \"Saved file:       \";\n  public static final String WRITER__UITEXT_UnableToSaveFile           = \"Unable to save file: \";\n  public static final String WRITER__UITEXT_UnableToBackupFile         = \"Unable to backup file: \";\n  public static final String WRITER__UITEXT_ToBackupFolder             = \" to backup folder: \";\n  public static final String WRITER__UITEXT_BackupFolderColon          = \"Backup folder: \";\n  public static final String WRITER__UITEXT_BackupFolderExistFailure   = \" does not exist and cannot be created.\";\n  public static final String WRITER__UITEXT_BackupFolderNotAFolder     = \" is not a folder.\";\n  public static final String WRITER__UITEXT_BackupFolderNotWritable    = \" is not writable.\";\n  public static final String WRITER__UITEXT_CodeWriterState            = \"Code Writer State: \";\n  public static final String WRITER__UITEXT_GetFileIndexEquals         = \"\\n_getFileIndex()    = \";\n  public static final String WRITER__UITEXT_GetFullFileNameEquals      = \"\\n_getFullFileName() = \";\n  public static final String WRITER__UITEXT_GetOutputFolderEquals      = \"\\n_getOutputFolder() = \";\n  public static final String WRITER__UITEXT_ErrorHeader                = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\n  public static final String WRITER__UITEXT_ErrorFooter                = \"\\n--- CodeWriter Error Description End -----\\n\\n\";\n  public static final String WRITER__UITEXT_UnableToLoadMetaProps      = \"Unable to load metadata from file: \";\n  public static final String WRITER__UITEXT_UndefinedProperty          = \"Undefined property: \";\n  public static final String WRITER__UITEXT_UnableToCreateOutputFolder = \"Unable to create output folder: \";\n  public static final String WRITER__UITEXT_PlaceHolderException \n    = \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\";\n\n  // String constants \n  public static final String WRITER__STRING_empty                    = \"\";\n  public static final String WRITER__STRING_dot                      = \".\";\n  public static final String WRITER__STRING_separator                = File.separator;\n\n  public static final int WRITER__FILE_BUFFER_SIZE                   = 4096;  // initial size of StringBuffer\n\n  /* Constants >> */\n\n\n\n\n  /* Writer Variables << */\n\n  protected String[]     writer__iFileNameRoots    = new String[] {};      // generated file name roots\n  protected int          writer__iNumFiles         = 0;                    // number of generated files\n  \n  protected String       writer__iFileNamePrefix   = WRITER__STRING_empty; // failsafe default\n  protected String       writer__iFileNameSuffix   = WRITER__STRING_empty; // failsafe default\n\n  protected String       writer__iBackupPrefix     = WRITER__STRING_empty; // failsafe default\n  protected String       writer__iBackupSuffix     = WRITER__STRING_empty; // failsafe default\n\n  protected StringBuffer writer__iCurrentText      = new StringBuffer();   // current text\n  protected int          writer__iCurrentFileIndex = 0;                    // current file index\n\n  protected String[]     writer__iArgs             = new String[0];        // cmd line args\n  protected int          writer__iNumArgs          = 0;                    // number of cmd line args\n  protected String[]     writer__iUserArgs         = new String[0];        // user cmd line args\n  protected int          writer__iNumUserArgs      = 0;                    // number of user cmd line args\n\n  protected boolean      writer__iSave             = true;                 // save generated code to disk\n  protected boolean      writer__iBackup           = true;                 // make backups\n\n  protected String       writer__iOutputFolder     = WRITER__STRING_dot;   // written code is output to this folder\n  protected String       writer__iBackupFolder     = WRITER__STRING_dot;   // overwritten files are placed here\n  protected String       writer__iMetaPropFile     = null;                 // metadata properties file path\n\n  protected Properties   writer__iProperties       = null;                 // build properties\n  protected boolean      writer__iPropertiesInit   = false;                // true => lookup table initialiased\n\n  protected Object       writer__iContext          = null;                 // context object\n  protected Object       writer__iResult           = null;                 // result object\n\n  protected boolean      writer__iThrow            = false;                // throw Exceptions\n\n  /* Writer Variables >> */\n\n\n  !<{support>\n  // version 0.1 compatibility\n  // section:support\n  !<support>!<}support>\n\n\n\n  !<{declare>// section:declare\n  !<declare>!<}declare>\n\n\n\n\n  /** Execute. */\n  public static void main( String pArgs[] ) {\n    $<main.CodeWriter> cw = new $<main.CodeWriter>();\n    Object result = cw._generate( pArgs, false );\n    \n    int exitvalue = 0;\n    if( result instanceof Integer ) {\n      exitvalue = ((Integer)result).intValue();\n    }\n\n    System.exit( exitvalue );\n  }\n\n\n\n\n  /* Writer Services << */\n\n  /** Generate. */\n  public Object _generate( String[] pArgs ) {\n    return _generate( pArgs, false );\n  }\n\n\n  /** Generate. */\n  public Object _generate( String[] pArgs, boolean pThrow ) {\n     writer__iThrow = pThrow;\n\n    try {\n      writer__initialize();\n      writer__handleArgs( pArgs );\n      writer__write();    \n\n      Object result = _getResult();\n      if( null == result ) {\n        result = _getText();\n        _setResult( result );\n      }\n\n      return result;\n    } \n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Method + WRITER__UITEXT_Main, e );\n      return new Integer(1);\n    }\n  }\n\n\n  /* Initialize. */\n  public void writer__initialize() {\n    writer__iCurrentFileIndex = 0;\n    writer__setDefaults();\n  }\n\n\n\n  /** Main file generation loop. Template script is placed here in the body section. */\n  public void writer__write() {\n    if( false ) { throw new RuntimeException( WRITER__UITEXT_PlaceHolderException ); }\n\n    // initialize\n    String writer__currentSection = \"init\";\n\n    try {\n      if( false ) { throw new RuntimeException( WRITER__UITEXT_PlaceHolderException ); }\n\n      !<{init>// section:init\n      !<init>!<}init>\n\n\n      // write files loop\n      int      writer__numFiles = _getNumFiles();\n      int      writer__fileI    = 0;\n      writer__next_file: for( writer__fileI = 0; writer__fileI < writer__numFiles; writer__fileI = writer__fileI + 1 ) {\n\n        try {\n          if( false ) { throw new RuntimeException( WRITER__UITEXT_PlaceHolderException ); }\n\n\n          !<{prewrite>// section:prewrite\n          writer__currentSection = \"prewrite\";\n          !<prewrite>!<}prewrite>\n\n\n          if( ! writer__startFile() ) { continue writer__next_file; }\n\n\n          !<{body>// section:body\n          writer__currentSection = \"body\";\n          !<body>!<}body>\n\n\n          if( ! writer__endFile() ) { continue writer__next_file; }\n\n\n          !<{postwrite>// section:postwrite\n          writer__currentSection = \"postwrite\";\n          !<postwrite>!<}postwrite>\n\n\n        } \n        catch( RuntimeException re ) { throw re; }\n        catch( Exception e ) {\n           writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, e );\n        }\n\n        writer__nextFile();       \n      }\n \n\n      !<{cleanup>// section:cleanup\n      writer__currentSection = \"cleanup\";\n      !<cleanup>!<}cleanup>\n\n    } \n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, e );\n    }\n  }\n\n\n\n  /** Start writing a file. */\n  public boolean writer__startFile() {\n    writer__iCurrentText = new StringBuffer( WRITER__FILE_BUFFER_SIZE );\n    return true;\n  }\n\n\n\n  /** End writing a file. */\n  public boolean writer__endFile() {\n    boolean endOK = true;\n  \n    String filePath = \"output-file-path\";\n\n    if( endOK ) {\n      String fileName = _getFullFileName();\n      filePath \n        = writer__iOutputFolder\n        + WRITER__STRING_separator\n        + fileName;\n\n      if( writer__iBackup ) {\n        try {\n          writer__backup( filePath, fileName, writer__iBackupFolder );\n        } \n        catch( RuntimeException re ) { throw re; }\n        catch( Exception e ) {\n          writer__handleException( WRITER__UITEXT_UnableToBackupFile \n                                   + filePath \n                                   + WRITER__UITEXT_ToBackupFolder\n                                   + writer__iBackupFolder\n                                   ,e );\n          endOK = false;\n        }\n      }\n    }\n\n    File outputFolder = null;\n    try {\n      outputFolder = new File( filePath ).getParentFile();\n      if( null != outputFolder && !outputFolder.exists() ) {\n        outputFolder.mkdirs();\n      }\n    }\n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      writer__handleException( WRITER__UITEXT_UnableToCreateOutputFolder \n                               + outputFolder\n                               ,e );\n      endOK = false;\n    }\n\n\n    if( endOK && writer__iSave ) {\n      try {\n        _saveTextFile( filePath, writer__iCurrentText.toString() );\n        writer__userMessage( WRITER__UITEXT_SavedFile + filePath + WRITER__UITEXT_NewLine, false );\n      } \n      catch( RuntimeException re ) { throw re; }\n      catch( Exception e ) {\n        writer__handleException( WRITER__UITEXT_UnableToSaveFile + filePath, e );\n        endOK = false;\n      }\n    }\n\n    return endOK;\n  }\n\n\n\n  /** Move to next file. */\n  public void writer__nextFile() {\n    writer__iCurrentFileIndex = writer__iCurrentFileIndex + 1;\n  }\n\n\n\n  /** Handle command line arguments to CodeWriter. */\n  public void writer__handleArgs( String[] pArgs ) {\n\n    // set arg names\n    String argName_OutputFolder     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_OutputFolder;\n    String argName_MetaPropFile     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_MetaPropFile;\n    String argName_BackupFolder     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_BackupFolder;\n    String argName_NoBackup         = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_NoBackup;\n\n    // parse\n    int numArgs = pArgs.length;\n    for(int argI = 0; argI < numArgs; argI = argI + 1 ) {\n      if( 0 < argName_OutputFolder.length() && pArgs[argI].startsWith( argName_OutputFolder ) ) {\n        _setOutputFolder( pArgs[ argI ].substring( argName_OutputFolder.length() ) );\n      }\n      else if( 0 < argName_MetaPropFile.length() && pArgs[argI].startsWith( argName_MetaPropFile ) ) {\n        _setMetaPropFile( pArgs[ argI ].substring( argName_MetaPropFile.length() ) );\n      }\n      else if( 0 < argName_BackupFolder.length() && pArgs[argI].startsWith( argName_BackupFolder ) ) {\n        _setBackupFolder( pArgs[ argI ].substring( argName_BackupFolder.length() ) );\n      }\n      else if( 0 < argName_NoBackup.length() && argName_NoBackup.equals( pArgs[ argI ] ) ) {\n        _backup( $<lang.FalseString> ); // NOTE: -B => don't make backups\n      }\n    }\n\n    writer__initArgs( pArgs.length, pArgs );\n  }\n\n\n\n  /** Set defaults from configuration property set. */\n  public void writer__setDefaults() {\n\n    $<{main.FileNameRoot>_setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n    $<{main.FileNamePrefix>_setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n    $<{main.FileNameSuffix>_setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n    $<{main.OutputFolder>_setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n    $<{main.BackupFolder>_setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n    $<{main.BackupPrefix>_setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n    $<{main.BackupSuffix>_setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n    _backup( \"$<lang.TrueString>\".equals( \"$<jostraca.MakeBackup>\" ) );\n\n  }\n\n\n\n  /** Initialize command line arguments. */\n  public void writer__initArgs( int pNumArgs, String[] pArgs ) {\n    int      argI        = 0;\n    int      userArgI    = 0;\n\n    writer__iNumArgs     = pNumArgs;\n    writer__iArgs        = pArgs;\n    writer__iNumUserArgs = writer__iNumArgs;\n\n    for( argI = 0; argI < writer__iNumArgs; argI = argI + 1 ) {\n      if( writer__iArgs[argI].startsWith( WRITER__ARGUMENT_CONTROL_PREFIX ) ) {\n        writer__iNumUserArgs = writer__iNumUserArgs - 1;\n      }\n    }\n\n    writer__iUserArgs = new String[ writer__iNumUserArgs ];\n    for( argI = 0; argI < writer__iNumArgs; argI = argI + 1 ) {\n      if( !writer__iArgs[argI].startsWith( WRITER__ARGUMENT_CONTROL_PREFIX ) ) {\n        writer__iUserArgs[ userArgI ] = writer__iArgs[ argI ];\n        userArgI = userArgI + 1;\n      }\n    }\n  }\n\n\n\n  /** Print a user readable message. */\n  public void writer__userMessage( String pMessage, boolean pIsError ) {\n    (pIsError?System.err:System.out).print( pMessage );\n  }\n\n\n\n  /** Handle exceptions: print an explanation for user. */\n  public void writer__handleException( String pMessage, Exception pException ) {\n\n    StringBuffer userMsg = new StringBuffer();\n\n    userMsg.append( WRITER__UITEXT_ErrorHeader );\n\n    userMsg.append( writer__describeState() + pMessage + WRITER__UITEXT_ColonNewLine );\n\n    StringWriter stringWriter = new StringWriter();\n    pException.printStackTrace( new PrintWriter( stringWriter) );\n    userMsg.append( stringWriter.toString() );\n\n    userMsg.append( WRITER__UITEXT_ErrorFooter );\n\n    if( writer__iThrow ) {\n      throw new RuntimeException( userMsg.toString() );\n    }\n    else {\n      writer__userMessage( userMsg.toString(), true );\n    }\n  }\n\n\n\n  /** Provide a concise description of the state of the CodeWriter. */\n  public String writer__describeState() {\n    String currentState \n      = WRITER__UITEXT_CodeWriterState\n      + WRITER__UITEXT_GetFileIndexEquals    + _getFileIndex() \n      + WRITER__UITEXT_GetFullFileNameEquals + _getFullFileName()\n      + WRITER__UITEXT_GetOutputFolderEquals + _getOutputFolder()\n      + WRITER__UITEXT_NewLine\n      ; \n    return currentState;\n  }\n\n\n\n  /** Backup overwritten files, if they exist.\n   *  Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n   */ \n  public void writer__backup( String pFilePath, String pFileName, String pBackupFolder ) {\n\n    File backupFolder = new File( pBackupFolder );\n\n    // check backup folder ( create if necessary )\n    if( ! backupFolder.exists() ) {\n      if( ! backupFolder.mkdirs() ) {\n        throw new RuntimeException( WRITER__UITEXT_BackupFolderColon\n                                    + backupFolder\n                                    + WRITER__UITEXT_BackupFolderExistFailure );\n      }\n    }\n    if( ! backupFolder.isDirectory() ) {\n      throw new RuntimeException( WRITER__UITEXT_BackupFolderColon \n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderNotAFolder );\n    }\n    if( ! backupFolder.canWrite() ) {\n      throw new RuntimeException( WRITER__UITEXT_BackupFolderColon\n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderNotWritable );\n    }\n\n    // create backup file path\n    Calendar calendar = Calendar.getInstance();\n    String year_yyyy = _align( String.valueOf( calendar.get(Calendar.YEAR) ),         \"0\", 4, 'r' );\n    String month_mm  = _align( String.valueOf( (1+calendar.get(Calendar.MONTH)) ),    \"0\", 2, 'r' );\n    String day_dd    = _align( String.valueOf( calendar.get(Calendar.DAY_OF_MONTH) ), \"0\", 2, 'r' );\n    String hour_hh   = _align( String.valueOf( calendar.get(Calendar.HOUR_OF_DAY) ),  \"0\", 2, 'r' );\n    String minute_mm = _align( String.valueOf( calendar.get(Calendar.MINUTE) ),       \"0\", 2, 'r' );\n    String second_ss = _align( String.valueOf( calendar.get(Calendar.SECOND) ),       \"0\", 2, 'r' );\n    String dateTime       = year_yyyy+month_mm+day_dd+hour_hh+minute_mm+second_ss;\n    String backupFileName = dateTime + writer__iBackupPrefix + pFileName + writer__iBackupSuffix;\n    File   backupFilePath = new File( pBackupFolder, backupFileName );\n    \n    File   fullBackupFolder = backupFilePath.getParentFile();\n    if( null != fullBackupFolder && !fullBackupFolder.exists() ) {\n      if( ! fullBackupFolder.mkdirs() ) {\n        throw new RuntimeException( WRITER__UITEXT_BackupFolderColon\n                                    + fullBackupFolder\n                                    + WRITER__UITEXT_BackupFolderExistFailure );\n      }\n    }\n\n\n    // save backup file\n    File fileToBackup = new File( pFilePath );\n    if( fileToBackup.exists() ) {\n      String fileContents = _loadTextFile( pFilePath );\n      _saveTextFile( backupFilePath.getPath(), fileContents );\n    }\n  }\n\n\n\n  /** Load build properties. */\n  public void writer__initProperties() {\n\n    String metaPropFile = _getMetaPropFile();\n    if( null != metaPropFile ) {\n      writer__iProperties = new Properties();\n      \n      try {\n        FileInputStream fis = new FileInputStream( _getMetaPropFile() );\n        writer__iProperties.load( fis );\n        fis.close();\n      }\n      catch( RuntimeException re ) { throw re; }\n      catch( Exception e ) {\n        writer__handleException( WRITER__UITEXT_UnableToLoadMetaProps+_getMetaPropFile(), e );\n      }\n\n      writer__iPropertiesInit = true;\n    }\n  }\n\n  /* Writer Services >> */\n \n\n\n\n  /* Template Services (File Generation) << */\n\n  /** Set the prefix of the files to be generated. */\n  public void _setFileNamePrefix( String pPrefix ) {\n    if( null == pPrefix ) {\n      return; // ignore\n    }\n    writer__iFileNamePrefix = pPrefix;\n  }\n\n\n\n  /** Get prefix of files to be generated. */\n  public String _getFileNamePrefix() {\n    return writer__iFileNamePrefix;\n  }\n\n\n\n  /** Set the suffix of the files to be generated. */\n  public void _setFileNameSuffix( String pSuffix ) {\n    if( null == pSuffix ) {\n      return; // ignore\n    }\n    writer__iFileNameSuffix = pSuffix;\n  }\n\n\n\n  /** Get suffix of files to be generated. */\n  public String _getFileNameSuffix() {\n    return writer__iFileNameSuffix;\n  }\n\n\n\n  /** Set the full name of the file to be generated. \n   *  Prefix and Suffix are set to empty.\n   */\n  public void _setFullFileName( String pName ) {\n    _setFileNamePrefix( WRITER__STRING_empty );\n    _setFileNameRoot(   pName );\n    _setFileNameSuffix( WRITER__STRING_empty );\n  }\n\n\n\n  /** Get the full name of current file being generated. */\n  public String _getFullFileName() {\n    return _getFileNamePrefix() + _getFileNameRoot() + _getFileNameSuffix();\n  }\n\n\n\n  /** Set the names of the files to be generated. \n   *  Prefix and Suffix are set to empty.\n   */\n  public void _setFullFileNames( String[] pNames ) {\n    _setFileNamePrefix( WRITER__STRING_empty );\n    _setFileNameRoots(  pNames );\n    _setFileNameSuffix( WRITER__STRING_empty );\n  }\n\n\n\n  /** Get the full names of the files to be generated. */\n  public String[] _getFullFileNames() {\n\n    String[] fileNameRoots  = _getFileNameRoots();\n    int      numFiles       = fileNameRoots.length;\n    String[] fullFileNames  = new String[ numFiles ];\n    String   fileNamePrefix = _getFileNamePrefix();\n    String   fileNameSuffix = _getFileNameSuffix();\n\n    for( int fileI = 0; fileI < numFiles; fileI = fileI + 1 ) {\n      fullFileNames[ fileI ] = fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix;\n    }\n\n    return fullFileNames;\n  }\n\n\n\n  /** Set the root of the name of the file to be generated. */\n  public void _setFileNameRoot( String pFileNameRoot ) {\n    if( null == pFileNameRoot ) {\n      return; // ignore\n    }\n    _setFileNameRoots( new String[] { pFileNameRoot } );\n  }\n\n\n\n  /** Get the root of the name of the current file being generated. */\n  public String _getFileNameRoot() {\n    if( 0 < writer__iFileNameRoots.length ) {\n      return writer__iFileNameRoots[ writer__iCurrentFileIndex ];\n    }\n    return WRITER__STRING_empty;\n  }\n\n\n\n  /** Set the roots of the names of the files to be generated. */\n  public void _setFileNameRoots( String[] pFileNameRoots ) {\n    if( null == pFileNameRoots ) {\n      return; // ignore\n    }\n\n    // copy\n    String[] roots = (String[]) pFileNameRoots.clone();\n\n    // normalize - replace nulls\n    int numRoots = roots.length;\n    for(int rootI = 0; rootI < numRoots; rootI = rootI + 1 ) {\n      if( null == roots[ rootI ] ) {\n        roots[ rootI ] = WRITER__STRING_empty;\n      }\n    }\n\n    // save roots\n    writer__iFileNameRoots = roots;\n    writer__iNumFiles      = numRoots;\n  }\n\n\n\n  /** Get roots of the names of files to be generated. */\n  public String[] _getFileNameRoots() {\n    return writer__iFileNameRoots;\n  }\n\n\n\n  /** Get index of file currently being generated. */\n  public int _getFileIndex() {\n    return writer__iCurrentFileIndex;\n  }\n\n\n\n  /** Get number of files to generate. */\n  public int _getNumFiles() {\n    return writer__iNumFiles;\n  }\n\n\n\n  /** Set output folder. */\n  public void _setOutputFolder( String pOutputFolder ) {\n    writer__iOutputFolder = pOutputFolder;\n  }\n\n\n\n  /** Get output folder. */\n  public String _getOutputFolder() {\n    return writer__iOutputFolder;\n  }\n\n\n\n  /** Set backup folder. */\n  public void _setBackupFolder( String pBackupFolder ) {\n    writer__iBackupFolder = pBackupFolder;\n  }\n\n\n\n  /** Get backup folder. */\n  public String _getBackupFolder() {\n    return writer__iBackupFolder;\n  }\n\n\n\n  /** Set the prefix of backup files. */\n  public void _setBackupPrefix( String pPrefix ) {\n    if( null == pPrefix ) {\n      return; // ignore\n    }\n    writer__iBackupPrefix = pPrefix;\n  }\n\n\n\n  /** Set the suffix of backup files. */\n  public void _setBackupSuffix( String pSuffix ) {\n    if( null == pSuffix ) {\n      return; // ignore\n    }\n    writer__iBackupSuffix = pSuffix;\n  }\n\n\n\n  /** Set to true if generated files are to be backed up to disk automatically. */\n  public void _backup( boolean pBackup ) {\n    writer__iBackup = pBackup;\n  }\n\n\n\n  /** Set to true if generated files are to be saved to disk automatically. */\n  public void _save( boolean pSave ) {\n    writer__iSave = pSave;\n  }\n\n\n\n  /** Save a text file. */\n  public void _saveTextFile( String pFilePath, String pContent ) {\n    try {\n      StringReader   sr = new StringReader( pContent );\n      BufferedReader br = new BufferedReader( sr );\n      FileWriter     fw = new FileWriter( pFilePath );\n      BufferedWriter bw = new BufferedWriter( fw );\n\n      String line;\n      while( null != (line = br.readLine()) ) {\n        bw.write( line );\n        bw.newLine();\n      }\n\n      bw.close();\n      br.close();\n    }\n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      throw new RuntimeException( e.getMessage() );\n    }\n  }\n\n\n\n  /** Load a text file. */\n  public String _loadTextFile( String pFilePath ) {\n    try {\n      File       file       = new File( pFilePath );\n      FileReader in         = new FileReader( file );\n      int        size       = (int) file.length();\n      char[]     data       = new char[size];\n      int        charsRead  = 0;\n\n      while( charsRead < size ) {\n        charsRead += in.read( data, charsRead, size - charsRead );\n      }\n\n      return new String( data );\n    }\n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      throw new RuntimeException( e.getMessage() );\n    }\n  }\n\n\n  /** Set build properties file. */\n  public void _setMetaPropFile( String pMetaPropFile ) {\n    writer__iMetaPropFile  = pMetaPropFile;\n    writer__iPropertiesInit = false;\n  }\n\n\n\n  /** Get build properties file. */\n  public String _getMetaPropFile() {\n    return writer__iMetaPropFile;\n  }\n\n\n  /* Template Services (File Generation) >> */\n\n\n\n\n  /* Template Services (Control) << */\n\n  /** Get the value of a compile-time property. */\n  public String _getProperty( String pName ) {\n    String result = WRITER__STRING_empty;\n\n    if( ! writer__iPropertiesInit ) {\n      writer__initProperties();\n    }\n\n    if( writer__iProperties.containsKey( pName ) ) {\n      result = writer__iProperties.getProperty( pName );\n    }\n    else {\n      throw new RuntimeException( WRITER__UITEXT_UndefinedProperty+pName );\n    }\n\n    return result;\n  }\n\n\n\n  /** Get first user arg. */\n  public String _getFirstUserArg() {\n    return _getUserArg(0);\n  }\n\n\n\n  /** Get second user arg. */\n  public String _getSecondUserArg() {\n    return _getUserArg(1);\n  }\n\n\n\n  /** Get third user arg. */\n  public String _getThirdUserArg() {\n    return _getUserArg(2);\n  }\n\n\n\n  /** Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX). */\n  public String _getUserArg( int pOrdinal ) {\n    if( pOrdinal < _getNumUserArgs() ) {\n      String[] userargs =  _getUserArgs();\n      return userargs[ pOrdinal ];\n    }\n    else {\n      return WRITER__STRING_empty;\n    }\n  }\n\n\n\n  /** Get user command line arguments to CodeWriter. */\n  public String[] _getUserArgs() {\n    return writer__iUserArgs;\n  }\n\n\n\n  /** Get number of user command line arguments to CodeWriter. */\n  public int _getNumUserArgs() {\n    return writer__iNumUserArgs;\n  }\n\n\n\n  /** Get all command line arguments to CodeWriter. */\n  public String[] _getArgs() {\n    return writer__iArgs;\n  }\n\n\n\n  /** Get total number of command line arguments to CodeWriter. */\n  public int _getNumArgs() {\n    return writer__iNumArgs;\n  }\n\n\n  \n  /** Set a context object for the template to use. */\n  public void _setContext( Object pContext) {\n    writer__iContext = pContext;\n  }\n\n\n\n  /** Get the context object if set. NOTE: may return null. */\n  public Object _getContext() {\n    return writer__iContext;\n  }\n\n  /* Template Services (Control) >> */\n\n\n\n\n  /* Template Services (Text Production) << */\n\n  // inserts\n  // ...\n\n  public void _insert( String pText ) {\n    writer__iCurrentText.append( pText );\n  }\n\n  public void _insert( Object pObject ) {\n    writer__iCurrentText.append( String.valueOf(pObject) );\n  }\n\n  public void _insert( int pInt ) {\n    writer__iCurrentText.append( pInt );\n  }\n\n  public void _insert( long pLong ) {\n    writer__iCurrentText.append( pLong );\n  }\n\n  public void _insert( short pShort ) {\n    writer__iCurrentText.append( pShort );\n  }\n\n  public void _insert( byte pByte ) {\n    writer__iCurrentText.append( pByte );\n  }\n\n  public void _insert( double pDouble ) {\n    writer__iCurrentText.append( pDouble );\n  }\n\n  public void _insert( float pFloat ) {\n    writer__iCurrentText.append( pFloat );\n  }\n\n  public void _insert( char pChar ) {\n    writer__iCurrentText.append( pChar );\n  }\n\n  public void _insert( boolean pBoolean ) {\n    writer__iCurrentText.append( pBoolean );\n  }\n\n\n\n  /** Create a String containing specified number of spaces. */\n  public String _spaces( int pNumSpaces ) {\n    int numSpaces = pNumSpaces;\n    if( 0 > numSpaces ) { numSpaces *= -1; }\n    StringBuffer spaces = new StringBuffer( numSpaces );\n    for(int spaceI = 0; spaceI < numSpaces; spaceI = spaceI + 1 ) {\n      spaces.append(\" \");\n    }\n    return spaces.toString();\n  }\n\n\n\n  /** Left align String with spaces. */ \n  public String _left( String pText, int pColWidth ) {\n    return _align( pText, \" \", pColWidth, 'l' );\n  } \n\n\n\n  /** Right align String with spaces. */ \n  public String _right( String pText, int pColWidth ) {\n    return _align( pText, \" \", pColWidth, 'r' );\n  } \n\n\n\n  /** Center align String with spaces. */ \n  public String _center( String pText, int pColWidth ) {\n    return _align( pText, \" \", pColWidth, 'c' );\n  } \n\n\n\n  /** Align text within background text to specified column width. \n   *  Alignment can be 'l': left, 'c': center, 'r': right.\n   */\n  public String _align( String pText, String pBackText, int pColWidth, char pAlignment ) {\n    String result = pText;\n \n    if( null == pText ) { \n       result = WRITER__STRING_empty; \n    }\n    else if( null != pBackText ) {\n      try {\n        int textLen = pText.length();\n        if( pColWidth > textLen ) {\n          int    backTextLen     = pBackText.length();\n          int    remainWidth     = pColWidth - textLen;\n          int    backTextRepeats = remainWidth / backTextLen;\n          int    backTextRemain  = remainWidth % backTextLen;\n          String back            = WRITER__STRING_empty;\n          for( int backTextI = 0; backTextI < backTextRepeats; backTextI = backTextI + 1 ) {\n            back = back + pBackText;\n          }\n          back = back + pBackText.substring( 0, backTextRemain );\n \n          switch( pAlignment ) {\n          case 'l':\n            result = result + back;\n            break;\n          case 'c':\n            result = back.substring( 0, (back.length()/2) ) + result + back.substring( (back.length()/2) );\n            break;\n          case 'r':\n            result = back + result;\n            break;\n          }\n        }\n      } \n      catch( RuntimeException re ) { throw re; }\n      catch( Exception e ) {\n        result = pText;\n      }\n    }\n    return result;\n  }\n\n\n\n  /** Set the text of file currently being generated. */\n  public void _setText( String pText) {\n    writer__iCurrentText = new StringBuffer( pText );\n  }\n\n\n\n  /** Get the text of file currently being generated. */\n  public String _getText() {\n    return writer__iCurrentText.toString();\n  }\n\n\n  /** Set result object (optional). */\n  public void _setResult( Object pResult ) {\n    writer__iResult = pResult;\n  }\n\n\n\n  /** Get the result object (may be null). */\n  public Object _getResult() {\n    return writer__iResult;\n  }\n\n  /* Template Services (Text Production) >> */\n\n}\n\n\n!<footer>\n");
    }

    private static final void makeWF_BasicPerlWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicPerlWriterFormat.jwf", "!<header>\n$<{perl.use.strict>use strict;$<}perl.use.strict>\n\n\n!<{import># section:import\n!<import>!<}import>\n\n\npackage $<main.CodeWriter>;\n\nsub new {\n  my $self = {};\n  bless $self;\n  $self->{writer__iText} = \"\";\n\n  # Constants \n\n  # Command line arguments\n  $self->{WRITER__ARGUMENT_CONTROL_PREFIX}         = \"$<main.CodeWriter.argument.ControlPrefix>\";\n  $self->{WRITER__ARGUMENT_OutputFolder}           = \"$<main.CodeWriter.argument.name.OutputFolder>\";\n  $self->{WRITER__ARGUMENT_MetaPropFile}           = \"$<main.CodeWriter.argument.name.MetaPropFile>\";\n  $self->{WRITER__ARGUMENT_BackupFolder}           = \"$<main.CodeWriter.argument.name.BackupFolder>\";\n  $self->{WRITER__ARGUMENT_NoBackup}               = \"$<main.CodeWriter.argument.name.NoBackup>\";\n\n  # User Interface text message parts\n  $self->{WRITER__UITEXT_Method}                   = \"method \";\n  $self->{WRITER__UITEXT_Main}                     = \"main \";\n  $self->{WRITER__UITEXT_ExceptionIn}              = \"Exception in \";\n  $self->{WRITER__UITEXT_ColonNewLine}             = \":\\n\";\n  $self->{WRITER__UITEXT_NewLine}                  = \"\\n\";\n  $self->{WRITER__UITEXT_Section}                  = \"section \";\n  $self->{WRITER__UITEXT_SavedFile}                = \"Saved file:       \";\n  $self->{WRITER__UITEXT_UnableToSaveFile}         = \"Unable to save file: \";\n  $self->{WRITER__UITEXT_UnableToBackupFile}       = \"Unable to backup file: \";\n  $self->{WRITER__UITEXT_ToBackupFolder}           = \" to backup folder: \";\n  $self->{WRITER__UITEXT_BackupFolderColon}        = \"Backup folder: \";\n  $self->{WRITER__UITEXT_BackupFolderExistFailure} = \" does not exist and cannot be created.\";\n  $self->{WRITER__UITEXT_BackupFolderNotAFolder}   = \" is not a folder.\";\n  $self->{WRITER__UITEXT_BackupFolderNotWritable}  = \" is not writable.\";\n  $self->{WRITER__UITEXT_CodeWriterState}          = \"Code Writer State: \";\n  $self->{WRITER__UITEXT_GetFileIndexEquals}       = \"\\n_getFileIndex()    = \";\n  $self->{WRITER__UITEXT_GetFullFileNameEquals}    = \"\\n_getFullFileName() = \";\n  $self->{WRITER__UITEXT_GetOutputFolderEquals}    = \"\\n_getOutputFolder() = \";\n  $self->{WRITER__UITEXT_ErrorHeader}              = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\n  $self->{WRITER__UITEXT_ErrorFooter}              = \"\\n--- CodeWriter Error Description End -----\\n\\n\";\n  $self->{WRITER__UITEXT_UnableToLoadMetaProps}    = \"Unable to load metadata from file: \";\n\n  # String constants\n  $self->{WRITER__STRING_empty}                    = \"\";\n  $self->{WRITER__STRING_dot}                      = \".\";\n  $self->{WRITER__STRING_separator}                = \"$<\\jostraca.system.fileSeparator>\";\n\n\n\n  # Writer Variables\n\n  $self->{writer__iFileNameRoots}      = [];                            # generated file name roots\n  $self->{writer__iNumFiles}           = 0;                             # number of generated files\n\n  $self->{writer__iFileNamePrefix}     = $self->{WRITER__STRING_empty}; # failsafe default\n  $self->{writer__iFileNameSuffix}     = $self->{WRITER__STRING_empty}; # failsafe default\n\n  $self->{writer__iBackupPrefix}       = $self->{WRITER__STRING_empty}; # failsafe default\n  $self->{writer__iBackupSuffix}       = $self->{WRITER__STRING_empty}; # failsafe default\n\n  $self->{writer__iCurrentText}        = $self->{WRITER__STRING_empty}; # current text\n  $self->{writer__iCurrentFileIndex}   = 0;                             # current file index\n\n  $self->{writer__iArgs}               = [];                            # cmd line args\n  $self->{writer__iNumArgs}            = 0;                             # number of cmd line args\n  $self->{writer__iUserArgs}           = [];                            # user cmd line args\n  $self->{writer__iNumUserArgs}        = 0;                             # number of user cmd line args\n\n  $self->{writer__iSave}               = $<lang.TrueString>;            # save generated code to disk\n  $self->{writer__iBackup}             = $<lang.TrueString>;            # make backups\n\n  $self->{writer__iOutputFolder}       = $self->{WRITER__STRING_dot};   # written code is output to this folder\n  $self->{writer__iBackupFolder}       = $self->{WRITER__STRING_dot};   # overwritten files are placed here\n  $self->{writer__iMetaPropFile}       = $self->{WRITER__STRING_empty}; # metadata properties file path\n\n  $self->{writer__iProperties}         = {};                            # lookup table for compile time properties\n  $self->{writer__iPropertiesInit}     = $<lang.FalseString>;           # true => lookup table initialiased\n\n  return $self;\n}\n\n\n!<{support># version 0.1 compatibility # section:support\n!<support>!<}support>\n\n\n\n!<{declare># section:declare!<declare>\n!<}declare>\n\n\n\n# Execute.\nsub main {\n  my $self = shift;\n  my @pArgs = @_;\n\n  eval {\n    $self->writer__initialize();\n    $self->writer__handleArgs( @pArgs );\n    $self->writer__write();\n  };\n  if( $@ ) {\n    $self->writer__handleException( $self->{WRITER__UITEXT_ExceptionIn} \n                                    . $self->{WRITER__UITEXT_Method} \n                                    . $self->{WRITER__UITEXT_Main}, $@ );      \n  }\n}\n\n\n\n# Writer Services\n\n# Initialize.\nsub writer__initialize() {\n  my $self = shift;\n  $self->{writer__iCurrentFileIndex} = 0;\n  $self->writer__setDefaults();\n}\n\n\n\n# Main file generation loop. Template script is placed here in the body section.\nsub writer__write {\n  my $self = shift;\n\n  # initialize\n  $self->{writer__currentSection} = \"init\";\n\n  eval {\n\n    !<{init># section:init\n    !<init>!<}init> \n\n\n    # write files loop\n    my $writer__numFiles = $self->_getNumFiles();\n    my $writer__fileI    = 0;\n    writer__next_file: for( $writer__fileI = 0; \n                            $writer__fileI < $writer__numFiles;\n                            $writer__fileI = $writer__fileI + 1 ) {\n      eval {\n\n        !<{prewrite># section:prewrite\n        $self->{writer__currentSection} = \"prewrite\";\n        !<prewrite>!<}prewrite> \n\n\n        if( ! $self->writer__startFile() ) { \n          next writer__next_file; \n        }\n\n\n        !<{body># section:body\n        $self->{writer__currentSection} = \"body\";\n        !<body>!<}body> \n\n\n        if( ! $self->writer__endFile() ) { \n          next writer__next_file; \n        }\n\n\n        !<{postwrite># section:postwrite\n        $self->{writer__currentSection} = \"postwrite\";\n        !<postwrite>!<}postwrite> \n\n      };\n      if( $@ ) {\n        $self->writer__handleException( $self->{WRITER__UITEXT_ExceptionIn} \n                                        . $self->{WRITER__UITEXT_Section} \n                                        . $self->{writer__currentSection}, $@ );\n      }\n\n      $self->writer__nextFile();       \n    }\n \n\n    !<{cleanup># section:cleanup\n    $self->{writer__currentSection} = \"cleanup\";\n    !<cleanup>!<}cleanup> \n\n  };\n  if( $@ ) {\n    $self->writer__handleException( $self->{WRITER__UITEXT_ExceptionIn} \n                                    . $self->{WRITER__UITEXT_Section} \n                                    . $self->{writer__currentSection}, $@ );\n  }\n}\n\n\n\n# Start writing a file.\nsub writer__startFile {\n  my $self = shift;\n  $self->{writer__iCurrentText} = $self->{WRITER__STRING_empty};\n  return $<lang.TrueString>;\n}\n\n\n\n# End writing a file.\nsub writer__endFile {\n  my $self = shift;\n  my $endOK = $<lang.TrueString>;\n\n  my $fileName = $self->_getFullFileName();\n  my $filePath = $self->{writer__iOutputFolder}    \n               . $self->{WRITER__STRING_separator}    \n               . $fileName\n               ;\n\n  if( $self->{writer__iBackup} ) {\n    eval {\n      $self->writer__backup( $filePath, $fileName, $self->{writer__iBackupFolder} );\n    };\n    if( $@ ) {\n       $self->writer__handleException( $self->{WRITER__UITEXT_UnableToBackupFile} \n                                       . $filePath \n                                       . $self->{WRITER__UITEXT_ToBackupFolder}\n                                       . $self->{writer__iBackupFolder}, $@ );\n       $endOK = $<lang.FalseString>;\n    }\n  }\n \n  if( $endOK && $self->{writer__iSave} ) {\n    eval {\n      $self->_saveTextFile( $filePath, $self->{writer__iCurrentText} );\n      $self->writer__userMessage( $self->{WRITER__UITEXT_SavedFile} . $filePath . $self->{WRITER__UITEXT_NewLine}, 0 );\n    };\n    if( $@ ) {\n      $self->writer__handleException( $self->{WRITER__UITEXT_UnableToSaveFile} . $filePath, $@ );\n      $endOK = $<lang.FalseString>;\n    }\n  }\n\n  return $endOK;\n}\n\n\n\n# Move to next file.\nsub writer__nextFile {\n  my $self = shift;\n  $self->{writer__iCurrentFileIndex} = $self->{writer__iCurrentFileIndex} + 1;\n}\n\n\n\n# Handle command line arguments to CodeWriter.\nsub writer__handleArgs {\n  my $self = shift;\n  my @pArgs = @_; \n\n  # set arg names\n  my $argName_OutputFolder           = $self->{WRITER__ARGUMENT_CONTROL_PREFIX} . $self->{WRITER__ARGUMENT_OutputFolder};\n  my $argName_MetaPropFile           = $self->{WRITER__ARGUMENT_CONTROL_PREFIX} . $self->{WRITER__ARGUMENT_MetaPropFile};\n  my $argName_BackupFolder           = $self->{WRITER__ARGUMENT_CONTROL_PREFIX} . $self->{WRITER__ARGUMENT_BackupFolder};\n  my $argName_NoBackup               = $self->{WRITER__ARGUMENT_CONTROL_PREFIX} . $self->{WRITER__ARGUMENT_NoBackup};\n\n  # parse args\n  my $numArgs = @pArgs;\n  my $argI;\n  for( $argI = 0; $argI < $numArgs; $argI = $argI + 1 ) {\n    if( $pArgs[$argI] =~ /^$argName_OutputFolder(.*)$/ ) {\n      $self->_setOutputFolder( $1 );\n    }\n    elsif( $pArgs[$argI] =~ /^$argName_MetaPropFile(.*)$/ ) {\n      $self->_setMetaPropFile( $1 );\n    }\n    elsif( $pArgs[$argI] =~ /^$argName_BackupFolder(.*)$/ ) {\n      $self->_setBackupFolder( $1 );\n    }\n    elsif( $argName_NoBackup eq $pArgs[$argI] ) {\n      $self->_backup( $<lang.FalseString> ); ## NOTE: -B => don't make backups\n    }\n  }\n\n  $self->writer__initArgs( scalar(@pArgs), @pArgs );\n}\n\n\n\n# Set defaults from configuration property set.\nsub writer__setDefaults {\n  my $self = shift;\n\n  $<{main.FileNameRoot>$self->_setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n  $<{main.FileNamePrefix>$self->_setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n  $<{main.FileNameSuffix>$self->_setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n  $<{main.OutputFolder>$self->_setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n  $<{main.BackupFolder>$self->_setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n  $<{main.BackupPrefix>$self->_setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n  $<{main.BackupSuffix>$self->_setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n  $self->_backup( \"$<lang.TrueString>\" eq \"$<jostraca.MakeBackup>\" );\n\n}\n\n\n\n# Initialize command line arguments.\nsub writer__initArgs {\n  my $self = shift;\n  $self->{writer__iNumArgs}     = shift;\n  $self->{writer__iArgs}        = \\@_;\n\n  my $argI        = 0;\n  my $userArgI    = 0;\n  my @args        = @{$self->{writer__iArgs}};\n\n  $self->{writer__iNumUserArgs} = $self->{writer__iNumArgs};\n\n  for( $argI = 0; $argI < $self->{writer__iNumArgs}; $argI = $argI + 1 ) {\n    if( $args[$argI] =~ /^$self->{WRITER__ARGUMENT_CONTROL_PREFIX}/ ) {\n      $self->{writer__iNumUserArgs} = $self->{writer__iNumUserArgs} - 1;\n    }\n  }\n\n  for( $argI = 0; $argI < $self->{writer__iNumArgs}; $argI = $argI + 1 ) {\n    if( $args[$argI] =~ /^$self->{WRITER__ARGUMENT_CONTROL_PREFIX}/ ) {\n      next;\n    } \n    else {\n      ${$self->{writer__iUserArgs}}[ $userArgI ] = $args[ $argI ];\n      $userArgI = $userArgI + 1;\n    }\n  }\n}\n\n\n\n# Print a user readable message.\nsub writer__userMessage {\n  my $self = shift;\n  my $pMessage = shift;\n  my $pError = shift;\n\n  if( $pError ) {\n    print STDERR $pMessage;\n  }\n  else {\n    print( $pMessage );\n  }\n}\n\n\n\n# Handle exceptions: print an explanation for user.\nsub writer__handleException {\n  my $self = shift;\n  my $pMessage   = shift;\n  my $pException = shift;\n\n  my $userMsg = $self->{WRITER__UITEXT_ErrorHeader};\n\n  $userMsg .= $self->writer__describeState() . $pMessage . $self->{WRITER__UITEXT_ColonNewLine};\n  $userMsg .= $pException;\n  $userMsg .= $self->{WRITER__UITEXT_ErrorFooter};\n\n  $self->writer__userMessage( $userMsg, 1 );\n}\n\n\n\n# Provide a concise description of the state of the CodeWriter.\nsub writer__describeState {\n  my $self = shift;\n\n  my $currentState \n    = $self->{WRITER__UITEXT_CodeWriterState} \n    . $self->{WRITER__UITEXT_GetFileIndexEquals}    . $self->_getFileIndex()\n    . $self->{WRITER__UITEXT_GetFullFileNameEquals} . $self->_getFullFileName()\n    . $self->{WRITER__UITEXT_GetOutputFolderEquals} . $self->_getOutputFolder()\n    . $self->{WRITER__UITEXT_NewLine}\n    ; \n  return $currentState;\n}\n\n\n\n# Backup overwritten files, if they exist.\n# Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\nsub writer__backup {\n  my $self = shift;\n\n  my $pFilePath     = shift;\n  my $pFileName     = shift;\n  my $pBackupFolder = shift;\n\n  my $backupFolder = $pBackupFolder;\n\n  # check backup folder ( create if necessary )\n  if( !( -e $backupFolder) ) {\n    if( !( mkdir( $backupFolder, 0700 ) ) ) {\n      die( $self->{WRITER__UITEXT_BackupFolderColon}\n           . $backupFolder\n           . $self->{WRITER__UITEXT_BackupFolderExistFailure} );\n    }\n  }\n  if( !( -d $backupFolder ) ) {\n    die( $self->{WRITER__UITEXT_BackupFolderColon} \n         . $backupFolder\n         . $self->{WRITER__UITEXT_BackupFolderNotAFolder} );\n  }\n  if( !( -w $backupFolder ) ) {\n    die( $self->{WRITER__UITEXT_BackupFolderColon}\n         . $backupFolder\n         . $self->{WRITER__UITEXT_BackupFolderNotWritable} );\n  }\n\n  # create backup file path\n  my @calendar = localtime();\n  my $year_yyyy = $self->_align( 1900+$calendar[5], \"0\", 4, 'r' );\n  my $month_mm  = $self->_align( 1+$calendar[4],    \"0\", 2, 'r' );\n  my $day_dd    = $self->_align( $calendar[3],      \"0\", 2, 'r' );\n  my $hour_hh   = $self->_align( $calendar[2],      \"0\", 2, 'r' );\n  my $minute_mm = $self->_align( $calendar[1],      \"0\", 2, 'r' );\n  my $second_ss = $self->_align( $calendar[0],      \"0\", 2, 'r' );\n  my $dateTime = $year_yyyy.$month_mm.$day_dd.$hour_hh.$minute_mm.$second_ss;\n  my $backupFileName = $dateTime . $self->{writer__iBackupPrefix} . $pFileName . $self->{writer__iBackupSuffix};\n  my $backupFilePath = $pBackupFolder . $self->{WRITER__STRING_separator} . $backupFileName;\n  \n  # save backup file\n  if( -e $pFilePath ) {\n    my $fileContents = $self->_loadTextFile( $pFilePath );\n    $self->_saveTextFile( $backupFilePath, $fileContents );\n  }\n}\n\n\n\n# Set compile time properties.\nsub writer__initProperties {\n  my $self = shift;\n\n  my $metaPropFile = $self->_getMetaPropFile();\n\n  if( \"\" ne $metaPropFile ) {\n    $self->{writer__iProperties} = {};\n      \n    eval {\n      open( PF, $metaPropFile );\n      my $content = \"\\n\".join('',@_=<PF>);\n      close( PF );\n\n      $content =~ s/\\r\\n/\\n/g;\n      $content =~ s/\\r/\\n/g;\n      while( $content =~ /\\n\\s*(.*?)\\s*[=:]\\s*((\\\\\\s*\\n|.)*)/g ) {\n        my $name  = $1;\n        my $value = $2;\n        if( $name !~ /^#/ ) {\n          chomp($value);\n          $value =~ s/\\\\\\s*\\n//g;\n          ${$self->{writer__iProperties}}{$name} = $value;\n        }\n      }\n\n    };\n    if( $@ ) {\n      $self->writer__handleException( $self->{WRITER__UITEXT_UnableToLoadMetaProps} . $self->_getMetaPropFile() );\n    }\n\n    $self->{writer__iPropertiesInit} = $<lang.TrueString>;\n  }\n}\n\n\n\n# Template Services (File Generation)\n\n# Set the prefix of the files to be generated. \nsub _setFileNamePrefix {\n  my $self = shift;\n  my $pPrefix = shift;\n  $self->{writer__iFileNamePrefix} = $pPrefix;\n}\n\n\n\n# Get prefix of files to be generated.\nsub _getFileNamePrefix {\n  my $self = shift;\n  return $self->{writer__iFileNamePrefix};\n}\n\n\n\n#} Set the suffix of the files to be generated.\nsub _setFileNameSuffix {\n  my $self = shift;\n  my $pSuffix = shift;\n  $self->{writer__iFileNameSuffix} = $pSuffix;\n}\n\n\n\n# Get suffix of files to be generated.\nsub _getFileNameSuffix {\n  my $self = shift;\n  return $self->{writer__iFileNameSuffix};\n}\n\n\n\n#} Set the full name of the file to be generated. \n# Prefix and Suffix are set to empty.\nsub _setFullFileName {\n  my $self = shift;\n  my $pName = shift;\n  $self->_setFileNamePrefix( $self->{WRITER__STRING_empty} );\n  $self->_setFileNameRoot(   $pName );\n  $self->_setFileNameSuffix( $self->{WRITER__STRING_empty} );\n}\n\n\n\n# Get the full name of current file being generated.\nsub _getFullFileName {\n  my $self = shift;\n  return $self->_getFileNamePrefix() . $self->_getFileNameRoot() . $self->_getFileNameSuffix();\n}\n\n\n\n# Set the names of the files to be generated. \n# Prefix and Suffix are set to empty.\nsub _setFullFileNames {\n  my $self = shift;\n  my @pNames = @_;\n  $self->_setFileNamePrefix( $self->{WRITER__STRING_empty} );\n  $self->_setFileNameRoots(  @pNames );\n  $self->_setFileNameSuffix( $self->{WRITER__STRING_empty} );\n}\n\n\n\n# Get the full names of the files to be generated.\nsub _getFullFileNames {\n  my $self = shift;\n\n  my @fileNameRoots  = $self->_getFileNameRoots();\n  my $numFiles       = @fileNameRoots;\n  my @fullFileNames;\n  my $fileNamePrefix = $self->_getFileNamePrefix();\n  my $fileNameSuffix = $self->_getFileNameSuffix();\n\n  my $fileI;\n  for( $fileI = 0; $fileI < $numFiles; $fileI = $fileI + 1 ) {\n    $fullFileNames[ $fileI ] = $fileNamePrefix . $fileNameRoots[ $fileI ] . $fileNameSuffix;\n  }\n\n  return @fullFileNames;\n}\n\n\n\n# Set the root of the name of the file to be generated. \nsub _setFileNameRoot {\n  my $self = shift;\n  my $pFileNameRoot = shift;\n  $self->_setFileNameRoots( ($pFileNameRoot) );\n}\n\n\n\n# Get the root of the name of current file being generated.\nsub _getFileNameRoot {\n  my $self = shift;\n  return ${$self->{writer__iFileNameRoots}}[ $self->{writer__iCurrentFileIndex} ];\n}\n\n\n\n# Set the roots of the names of the files to be generated. \nsub _setFileNameRoots {\n  my $self = shift;\n\n  my @pFileNameRoots = @_;\n\n  $self->{writer__iFileNameRoots} = \\@pFileNameRoots;\n  $self->{writer__iNumFiles}      = @pFileNameRoots;\n}\n\n\n\n# Get roots of the names of files to be generated.\nsub _getFileNameRoots {\n  my $self = shift;\n  return @{$self->{writer__iFileNameRoots}};\n}\n\n\n\n# Get index of file currently being generated. \nsub _getFileIndex {\n  my $self = shift;\n  return $self->{writer__iCurrentFileIndex};\n}\n\n\n\n#} Get number of files to generate.\nsub _getNumFiles {\n  my $self = shift;\n  return $self->{writer__iNumFiles};\n}\n\n\n\n#} Set output folder.\nsub _setOutputFolder {\n  my $self = shift;\n\n  $self->{writer__iOutputFolder} = shift;\n}\n\n\n\n# Get output folder.\nsub _getOutputFolder {\n  my $self = shift;\n  return $self->{writer__iOutputFolder};\n}\n\n\n\n#} Set backup folder.\nsub _setBackupFolder {\n  my $self = shift;\n\n  my $pBackupFolder = shift;\n  $self->{writer__iBackupFolder} = $pBackupFolder;\n}\n\n\n\n# Get backup folder.\nsub _getBackupFolder {\n  my $self = shift;\n  return $self->{writer__iBackupFolder};\n}\n\n\n\n#} Set the prefix of backup files.\nsub _setBackupPrefix {\n  my $self = shift;\n  $self->{writer__iBackupPrefix} = shift;\n}\n\n\n\n# Set the suffix of backup files.\n# @param rSuffix Backup files suffix.\nsub _setBackupSuffix {\n  my $self = shift;\n  $self->{writer__iBackupSuffix} = shift;\n}\n\n\n\n# Set to true if generated files are to be backed up to disk automatically. \nsub _backup {\n  my $self = shift;\n  $self->{writer__iBackup} = shift;\n}\n\n\n\n# Set to true if generated files are to be saved to disk automatically. \nsub _save {\n  my $self = shift;\n  $self->{writer__iSave} = shift;\n}\n\n\n\n# Save a text file.\nsub _saveTextFile {\n  my $self = shift;\n\n  my $pFilePath = shift;\n  my $pContent  = shift;\n\n  open( FILE, '>'.$pFilePath ) or die \"Unable to write file: \".$pFilePath;\n  print FILE $pContent;\n  close( FILE );\n}\n\n\n\n# Load a text file.\nsub _loadTextFile {\n  my $self = shift;\n\n  my $pFilePath = shift;\n\n  open( FILE, $pFilePath ) or die \"Unable to read file: \".$pFilePath;\n  my $content = join('',@_=<FILE>);\n  close( FILE );\n  \n  return $content;\n}\n\n\n\n# Set build properties file.\nsub _setMetaPropFile {\n  my $self = shift;\n\n  my $pMetaPropFile = shift;\n\n  $self->{writer__iMetaPropFile}   = $pMetaPropFile;\n  $self->{writer__iPropertiesInit} = 0;\n}\n\n\n\n# Get build properties file.\nsub _getMetaPropFile {\n  my $self = shift;\n  return $self->{writer__iMetaPropFile};\n}\n\n\n\n# Template Services (Control)\n\n# Get the value of a compile-time property.\nsub _getProperty {\n  my $self = shift;\n\n  my $pName = shift;\n\n  if( ! $self->{writer__iPropertiesInit} ) {\n    $self->writer__initProperties();\n  }\n\n  return ${$self->{writer__iProperties}}{$pName};\n}\n\n\n\n# Get first user arg.\nsub _getFirstUserArg {\n  my $self = shift;\n  return $self->_getUserArg(0);\n}\n\n\n\n# Get second user arg.\nsub _getSecondUserArg {\n  my $self = shift;\n  return $self->_getUserArg(1);\n}\n\n\n\n# Get third user arg.\nsub _getThirdUserArg {\n  my $self = shift;\n  return $self->_getUserArg(2);\n}\n\n\n\n# Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX).\nsub _getUserArg {\n  my $self = shift;\n\n  my $pOrdinal = shift;\n\n  if( $pOrdinal < $self->_getNumUserArgs() ) {\n      my @userargs = $self->_getUserArgs();\n      return $userargs[$pOrdinal];\n  }\n  else {\n    return $self->{WRITER__STRING_empty};\n  }\n}\n\n\n\n# Get user command line arguments to CodeWriter.\nsub _getUserArgs {\n  my $self = shift;\n  return @{$self->{writer__iUserArgs}};\n}\n\n\n\n# Get number of user command line arguments to CodeWriter.\nsub _getNumUserArgs {\n  my $self = shift;\n  return $self->{writer__iNumUserArgs};\n}\n\n\n\n#} Get all command line arguments to CodeWriter. \nsub _getArgs() {\n  my $self = shift;\n  return @{$self->{writer__iArgs}};\n}\n\n\n\n# Get total number of command line arguments to CodeWriter.\nsub _getNumArgs() {\n  my $self = shift;\n  return $self->{writer__iNumArgs};\n}\n\n\n\n\n\n# Template Services (Text Production)\n\n# Insert text into generated file. \nsub _insert {\n  my $self = shift;\n  my $pText = shift;\n\n  $self->{writer__iCurrentText} = $self->{writer__iCurrentText} . $pText;\n}\n\n\n\n# Create a String containing specified number of spaces.\nsub _spaces {\n  my $self = shift;\n  my $pNumSpaces = shift;\n  return ' ' x abs($pNumSpaces);\n}\n\n\n\n# Left align String with spaces. \nsub _left {\n  my $self = shift;\n  my $pText     = shift;\n  my $pColWidth = shift;\n  return $self->_align( $pText, \" \", $pColWidth, 'l' );\n} \n\n\n\n# Right align String with spaces. \nsub _right {\n  my $self = shift;\n  my $pText     = shift;\n  my $pColWidth = shift;\n  return $self->_align( $pText, \" \", $pColWidth, 'r' );\n} \n\n\n\n# Center align String with spaces. \nsub _center {\n  my $self = shift;\n  my $pText     = shift;\n  my $pColWidth = shift;\n  return $self->_align( $pText, \" \", $pColWidth, 'c' );\n} \n\n\n\n# Align text within background text with specified column width.\n# Alignment can be 'l': left, 'c': center, 'r': right\nsub _align {\n  my $self = shift;\n\n  my $pText      = shift;\n  my $pBackText  = shift;\n  my $pColWidth  = shift;\n  my $pAlignment = shift;\n\n  my $result = $pText;\n  \n\n  eval {\n    my $textLen = length( $pText );\n    if( $pColWidth > $textLen ) {\n      my $backTextLen     = length( $pBackText );\n      my $remainWidth     = $pColWidth - $textLen;\n      my $backTextRepeats = int( $remainWidth / $backTextLen );\n      my $backTextRemain  = $remainWidth % $backTextLen;\n      my $back            = $self->{WRITER__STRING_empty};\n      my $backTextI;\n      for( $backTextI = 0; $backTextI < $backTextRepeats; $backTextI = $backTextI + 1 ) {\n        $back = $back . $pBackText;\n      }\n      if( 0 < $backTextRemain ) {\n        $back = $back . substr( $pBackText, 0, $backTextRemain );\n      }                       \n\n      if( 'l' eq $pAlignment ) {\n        $result = $result . $back;\n      } \n      elsif( 'c' eq $pAlignment ) {\n        $result = substr( $back, 0, (length($back)/2) ) . $result . substr( $back, (length($back)/2) );\n      } \n      elsif( 'r' eq $pAlignment ) {\n        $result = $back . $result;\n      }\n    }\n  };\n  if( $@ ) {\n    $result = $pText;\n  }\n\n  return $result;\n}\n\n\n\n# Set the text of file currently being generated.\nsub _setText {\n  my $self = shift;\n  $self->{writer__iCurrentText} = shift;\n}\n\n\n\n# Get the text of file currently being generated.\nsub _getText {\n  my $self = shift;\n  return $self->{writer__iCurrentText};\n}\n\n\n\n# Start execution\nmy $cw = $<main.CodeWriter>->new();\n$cw->main( @ARGV );\nexit( 0 );\n\n\n\n!<footer>\n");
    }

    private static final void makeWF_BasicPythonWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicPythonWriterFormat.jwf", "!<header>\n\nimport os\nimport os.path\nimport sys\nimport time\nimport string\nimport traceback\nimport re\n\n\n\n!<{import># section:import\n!<import>!<}import>\n\n\nclass $<main.CodeWriter>$<{python.CodeWriter.extends>($<python.CodeWriter.extends>)$<}python.CodeWriter.extends>:\n\n\n  def __init__(self):\n\n    # Constants << #\n   \n    # Command line arguments\n    self.WRITER__ARGUMENT_CONTROL_PREFIX         = \"$<main.CodeWriter.argument.ControlPrefix>\"\n    self.WRITER__ARGUMENT_OutputFolder           = \"$<main.CodeWriter.argument.name.OutputFolder>\"\n    self.WRITER__ARGUMENT_MetaPropFile           = \"$<main.CodeWriter.argument.name.MetaPropFile>\"\n    self.WRITER__ARGUMENT_BackupFolder           = \"$<main.CodeWriter.argument.name.BackupFolder>\"\n    self.WRITER__ARGUMENT_NoBackup               = \"$<main.CodeWriter.argument.name.NoBackup>\"\n  \n    # User Interface text message parts\n    self.WRITER__UITEXT_Method                   = \"method \"\n    self.WRITER__UITEXT_Main                     = \"main \"\n    self.WRITER__UITEXT_ExceptionIn              = \"Exception in \"\n    self.WRITER__UITEXT_ColonNewLine             = \":\\n\"\n    self.WRITER__UITEXT_NewLine                  = \"\\n\"\n    self.WRITER__UITEXT_Section                  = \"section \"\n    self.WRITER__UITEXT_SavedFile                = \"Saved file:       \"\n    self.WRITER__UITEXT_UnableToSaveFile         = \"Unable to save file: \"\n    self.WRITER__UITEXT_UnableToBackupFile       = \"Unable to backup file: \"\n    self.WRITER__UITEXT_ToBackupFolder           = \" to backup folder: \"\n    self.WRITER__UITEXT_BackupFolderColon        = \"Backup folder: \"\n    self.WRITER__UITEXT_BackupFolderExistFailure = \" does not exist and cannot be created.\"\n    self.WRITER__UITEXT_BackupFolderNotAFolder   = \" is not a folder.\"\n    self.WRITER__UITEXT_BackupFolderNotWritable  = \" is not writable.\"\n    self.WRITER__UITEXT_CodeWriterState          = \"Code Writer State: \"\n    self.WRITER__UITEXT_GetFileIndexEquals       = \"\\n_getFileIndex()    = \";\n    self.WRITER__UITEXT_GetFullFileNameEquals    = \"\\n_getFullFileName() = \";\n    self.WRITER__UITEXT_GetOutputFolderEquals    = \"\\n_getOutputFolder() = \";\n    self.WRITER__UITEXT_ErrorHeader              = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\"\n    self.WRITER__UITEXT_ErrorFooter              = \"\\n--- CodeWriter Error Description End -----\\n\\n\"\n    self.WRITER__UITEXT_UnableToLoadMetaProps    = \"Unable to load metadata from file: \"\n    self.WRITER__UITEXT_PlaceHolderException     = \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\"\n  \n    # String constants\n    self.WRITER__STRING_empty                    = \"\"\n    self.WRITER__STRING_dot                      = \".\"\n    self.WRITER__STRING_separator                = \"$<\\jostraca.system.fileSeparator>\"\n  \n    # Constants >> #\n  \n  \n  \n  \n    # Writer Variables << #\n  \n    self.writer__iFileNameRoots         = [   self.WRITER__STRING_empty ]   # generated file name roots\n    self.writer__iNumFiles              = 0                                 # number of generated files\n    \n    self.writer__iFileNamePrefix        =   self.WRITER__STRING_empty       # failsafe default\n    self.writer__iFileNameSuffix        =   self.WRITER__STRING_empty       # failsafe default\n  \n    self.writer__iBackupPrefix          =   self.WRITER__STRING_empty       # failsafe default\n    self.writer__iBackupSuffix          =   self.WRITER__STRING_empty       # failsafe default\n  \n    self.writer__iCurrentText           =   self.WRITER__STRING_empty       # current text\n    self.writer__iCurrentFileIndex      = 0                                 # current file index\n  \n    self.writer__iArgs                  = []                                # cmd line args\n    self.writer__iNumArgs               = 0                                 # number of cmd line args\n    self.writer__iUserArgs              = []                                # user cmd line args\n    self.writer__iNumUserArgs           = 0                                 # number of user cmd line args\n  \n    self.writer__iSave                  = 1                                 # save generated code to disk\n    self.writer__iBackup                = 1                                 # make backups\n  \n    self.writer__iOutputFolder          = self.WRITER__STRING_dot           # written code is output to this folder\n    self.writer__iBackupFolder          = self.WRITER__STRING_dot           # overwritten files are placed here\n    self.writer__iMetaPropFile          = self.WRITER__STRING_empty;        # metadata properties file path\n\n    self.writer__iProperties            = {}                                # lookup table for compile time properties\n    self.writer__iPropertiesInit        = $<lang.FalseString>               # true => lookup table initialiased\n  \n    # Writer Variables >> #\n\n\n\n  !<{support>\n  # version 0.1 compatibility\n  # section:support\n  !<support>!<}support>\n\n\n\n  !<{declare># section:declare\n  !<declare>!<}declare>\n\n\n\n  # Execute.\n  def main( self, pArgs ) :\n    try :\n      self.writer__initialize()\n      self.writer__handleArgs( pArgs )\n      self.writer__write()\n  \n    except Exception :\n      self.writer__handleException( self.WRITER__UITEXT_ExceptionIn + self.WRITER__UITEXT_Method + self.WRITER__UITEXT_Main )\n  \n\n\n\n  # Writer Services << #\n  \n  # Initialize.\n  def writer__initialize( self ) :\n    self.writer__iCurrentFileIndex = 0\n    self.writer__setDefaults()\n  \n  \n  \n  # Main file generation loop. Template script is placed here in the body section.\n  def writer__write( self ) :\n    \n    # initialize\n    self.writer__currentSection = \"init\"\n    \n    \n    try :\n     \n      !<{init># section:init\n      self.writer__currentSection = \"init\"\n      !<init>!<}init>\n      pass\n  \n     \n      # write files loop  \n      self.writer__numFiles = self._getNumFiles()\n      self.writer__fileI    = 0\n      for self.writer__fileI in range( self.writer__numFiles ) :\n    \n        try :\n     \n          !<{prewrite># section:prewrite\n          self.writer__currentSection = \"prewrite\"\n          !<prewrite>!<}prewrite> \n          pass\n  \n     \n          ok = self.writer__startFile()\n          if ok :     \n     \n            !<{body># section:body\n            self.writer__currentSection = \"body\"\n            !<body>!<}body> \n            pass\n  \n     \n            ok = self.writer__endFile()\n            if ok :     \n  \n              !<{postwrite># section:postwrite\n              self.writer__currentSection = \"postwrite\"\n              !<postwrite>!<}postwrite> \n              pass\n  \n   \n        except Exception :\n          self.writer__handleException( self.WRITER__UITEXT_ExceptionIn + self.WRITER__UITEXT_Section + self.writer__currentSection )\n   \n   \n        self.writer__nextFile()\n   \n   \n      !<{cleanup># section:cleanup \n      self.writer__currentSection = \"cleanup\"\n      !<cleanup>!<}cleanup>\n      pass \n    \n    except Exception :\n      self.writer__handleException( self.WRITER__UITEXT_ExceptionIn + self.WRITER__UITEXT_Section + self.writer__currentSection )\n  \n  \n  \n  # Start writing a file.\n  def writer__startFile( self ) :\n    self.writer__iCurrentText = self.WRITER__STRING_empty\n    return 1\n  \n  \n  \n  # End writing a file.\n  def writer__endFile( self ) :\n    endOK = 1\n  \n    fileName = self._getFullFileName() \n    filePath = self.writer__iOutputFolder + self.WRITER__STRING_separator + fileName\n  \n    if self.writer__iBackup :\n      try :\n        self.writer__backup( filePath, fileName, self.writer__iBackupFolder )\n  \n      except Exception, e :\n        self.writer__handleException( self.WRITER__UITEXT_UnableToBackupFile + filePath + self.WRITER__UITEXT_ToBackupFolder + self.writer__iBackupFolder )\n        endOK = 0\n  \n   \n    if endOK and self.writer__iSave :\n      try :\n        self._saveTextFile( filePath, self.writer__iCurrentText )\n        self.writer__userMessage( self.WRITER__UITEXT_SavedFile + filePath, $<lang.FalseString> ) # CP! + self.WRITER__UITEXT_NewLine )\n  \n      except Exception :\n        self.writer__handleException( self.WRITER__UITEXT_UnableToSaveFile + filePath )\n        endOK = 0\n  \n    return endOK\n    \n  \n  \n  # Move to next file\n  def writer__nextFile( self ) :\n    self.writer__iCurrentFileIndex = self.writer__iCurrentFileIndex + 1\n  \n  \n  \n  # Handle command line arguments to CodeWriter.\n  def writer__handleArgs( self, pArgs ) :\n  \n    # set arg names\n    argName_OutputFolder           = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_OutputFolder\n    argName_MetaPropFile           = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_MetaPropFile\n    argName_BackupFolder           = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_BackupFolder\n    argName_NoBackup               = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_NoBackup\n  \n    # parse args\n    # ...\n  \n    numArgs = len( pArgs )\n    for argI in range( numArgs ) :\n      if   0 == string.find( pArgs[ argI ], argName_OutputFolder ) :\n        self._setOutputFolder( pArgs[ argI ][len(argName_OutputFolder):] )\n      \n      elif 0 == string.find( pArgs[ argI ], argName_MetaPropFile ) :\n        self._setMetaPropFile( pArgs[ argI ][len(argName_MetaPropFile):] )\n\n      elif 0 == string.find( pArgs[ argI ], argName_BackupFolder ) :\n        self._setBackupFolder( pArgs[ argI ][len(argName_BackupFolder):] )\n  \n      elif argName_NoBackup == pArgs[ argI ]  :\n        self._backup( $<lang.FalseString> ) ## NOTE: -B => don't make backups\n      \n    self.writer__initArgs( len( pArgs ), pArgs )\n  \n  \n  \n  # Set def aults from configuration property set.\n  def writer__setDefaults( self ) :\n  \n    $<{main.FileNameRoot>self._setFileNameRoot( \"$<\\main.FileNameRoot>\" )$<}main.FileNameRoot>\n    $<{main.FileNamePrefix>self._setFileNamePrefix( \"$<\\main.FileNamePrefix>\" )$<}main.FileNamePrefix>\n    $<{main.FileNameSuffix>self._setFileNameSuffix( \"$<\\main.FileNameSuffix>\" )$<}main.FileNameSufffix>\n  \n    $<{main.OutputFolder>self._setOutputFolder( \"$<\\main.OutputFolder>\" )$<}main.OutputFolder>\n  \n    $<{main.BackupFolder>self._setBackupFolder( \"$<\\main.BackupFolder>\" )$<}main.BackupFolder>\n    $<{main.BackupPrefix>self._setBackupPrefix( \"$<\\main.BackupPrefix>\" )$<}main.BackupPrefix>\n    $<{main.BackupSuffix>self._setBackupSuffix( \"$<\\main.BackupSuffix>\" )$<}main.BackupSufffix>\n    self._backup( \"$<lang.TrueString>\" == \"$<jostraca.MakeBackup>\" )\n  \n    pass\n  \n  \n  \n  # Initialize command line arguments.\n  def writer__initArgs( self, pNumArgs, pArgs ) :\n    argI     = 0\n    userArgI = 0\n  \n    self.writer__iNumArgs     = pNumArgs\n    self.writer__iArgs        = pArgs\n    self.writer__iNumUserArgs = self.writer__iNumArgs - 1 # script name is arg 0\n  \n    for argI in range( 1, self.writer__iNumArgs ) :\n      if 0 == string.find( self.writer__iArgs[ argI ], self.WRITER__ARGUMENT_CONTROL_PREFIX ) : \n        self.writer__iNumUserArgs = self.writer__iNumUserArgs - 1\n      \n    for argI in range( 1, self.writer__iNumArgs ) :\n      if 0 == string.find( self.writer__iArgs[ argI ], self.WRITER__ARGUMENT_CONTROL_PREFIX ) : \n        continue\n      else :\n        self.writer__iUserArgs.append( self.writer__iArgs[ argI ] )\n        userArgI = userArgI + 1;\n  \n  \n  \n  # Print a user readable message.\n  def writer__userMessage( self, pMessage, pError ) :\n    if pError :\n      print >> sys.stderr, pMessage\n    else :\n      print pMessage\n  \n  \n  \n  # Handle exceptions: print an explanation for user.\n  def writer__handleException( self, pMessage ) :\n    userMsg = self.WRITER__UITEXT_ErrorHeader\n  \n    userMsg = userMsg + self.writer__describeState() + pMessage + self.WRITER__UITEXT_ColonNewLine\n    userMsg = userMsg + string.join(traceback.format_exception( sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2] ))\n    userMsg = userMsg + self.WRITER__UITEXT_ErrorFooter\n  \n    self.writer__userMessage( userMsg, $<lang.TrueString> )\n  \n  \n  \n  # Provide a concise description of the state of the CodeWriter.\n  def writer__describeState( self ) :\n    currentState = self.WRITER__STRING_empty +                                \\\n        self.WRITER__UITEXT_CodeWriterState                                   \\\n      + self.WRITER__UITEXT_GetFileIndexEquals    + str( self._getFileIndex() )    \\\n      + self.WRITER__UITEXT_GetFullFileNameEquals + self._getFullFileName()        \\\n      + self.WRITER__UITEXT_GetOutputFolderEquals + self._getOutputFolder()        \\\n      + self.WRITER__UITEXT_NewLine\n    return currentState\n  \n  \n  \n  # Backup overwritten files, if they exist.\n  # Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n  def writer__backup( self, pFilePath, pFileName, pBackupFolder ) :\n  \n    backupFolder = pBackupFolder\n  \n    # check backup folder ( create if necessary )\n    if not os.path.exists( backupFolder ) :\n      if not os.mkdir( backupFolder, 0700 ) :\n        raise Exception, self.WRITER__UITEXT_BackupFolderColon          \\\n                         + backupFolder                            \\\n                         + self.WRITER__UITEXT_BackupFolderExistFailure\n    if not os.path.isdir( backupFolder ) :\n      raise Exception, self.WRITER__UITEXT_BackupFolderColon        \\\n                       + backupFolder                          \\\n                       + self.WRITER__UITEXT_BackupFolderNotAFolder\n    if not os.access( backupFolder, os.W_OK ) :\n      raise Exception, self.WRITER__UITEXT_BackupFolderColon         \\\n                       + backupFolder                           \\\n                       + self.WRITER__UITEXT_BackupFolderNotWritable\n  \n  \n    # create backup file path\n    calendar = time.localtime( time.time() )\n    year_yyyy    = self._align( str(calendar[0]), \"0\", 4, 'r' )\n    month_mm     = self._align( str(calendar[1]), \"0\", 2, 'r' )\n    day_dd       = self._align( str(calendar[2]), \"0\", 2, 'r' )\n    hour_hh      = self._align( str(calendar[3]), \"0\", 2, 'r' )\n    minute_mm    = self._align( str(calendar[4]), \"0\", 2, 'r' )\n    second_ss    = self._align( str(calendar[5]), \"0\", 2, 'r' )\n    dateTime = year_yyyy+month_mm+day_dd+hour_hh+month_mm+second_ss\n    backupFileName = dateTime + self.writer__iBackupPrefix + pFileName + self.writer__iBackupSuffix\n    backupFilePath = pBackupFolder + self.WRITER__STRING_separator + backupFileName\n    \n    # save backup file\n    if os.path.exists( pFilePath ) :\n      fileContents = self._loadTextFile( pFilePath )\n      self._saveTextFile( backupFilePath, fileContents )\n  \n  \n  \n  # Set compile time properties\n  def writer__initProperties( self ) :\n    metaPropFile = self._getMetaPropFile()\n\n    if not \"\" == metaPropFile:\n      self.writer__iProperties = {}    \n\n      try:\n        content = self._loadTextFile( metaPropFile );\n\n        content = content.replace(\"\\r\\n\",\"\\n\");\n        content = content.replace(\"\\r\",\"\\n\");\n\n        for (name,value,index) in re.findall( '\\n\\s*(.*?)\\s*[=:]\\s*((\\\\\\s*\\n|.)*)', content ):\n          if not name.startswith('#'): \n            value = value.strip()\n            value = re.sub( '\\\\\\s*\\n', '', value )\n            value = value.replace( '\\n', '' )\n            self.writer__iProperties[name] = value    \n\n        self.writer__iPropertiesInit = $<lang.TrueString>\n\n      except:\n        self.writer__handleException( self.WRITER__UITEXT_UnableToLoadMetaProps+self._getMetaPropFile() )\n\n\n  # Writer Services >> #\n  \n  \n  \n  \n  # Template Services (File Generation) << #\n  \n  # Set the prefix of the files to be generated. \n  def _setFileNamePrefix( self, pPrefix ) :\n    prefix = str( pPrefix )\n    self.writer__iFileNamePrefix = prefix\n  \n  \n  \n  # Get prefix of files to be generated.\n  def _getFileNamePrefix( self ) : \n    return self.writer__iFileNamePrefix\n  \n  \n  \n  # Set the suffix of the files to be generated.\n  def _setFileNameSuffix( self, pSuffix ) :\n    suffix = str( pSuffix )\n    self.writer__iFileNameSuffix = suffix\n  \n  \n  \n  # Get suffix of files to be generated.\n  def _getFileNameSuffix( self ) :\n    return self.writer__iFileNameSuffix\n  \n  \n  \n  # Set the full name of the file to be generated. \n  # Prefix and Suffix are set to empty.\n  def _setFullFileName( self, pName ) :\n  \n    name = str( pName )\n    self._setFileNamePrefix( self.WRITER__STRING_empty )\n    self._setFileNameRoot(   name )\n    self._setFileNameSuffix( self.WRITER__STRING_empty )\n  \n  \n  \n  # Get the full name of current file being generated.\n  def _getFullFileName( self ) : \n    return self._getFileNamePrefix() + self._getFileNameRoot() + self._getFileNameSuffix()\n  \n  \n  \n  # Set the names of the files to be generated. \n  # Prefix and Suffix are set to empty.\n  def _setFullFileNames( self, pNames ) :\n    self._setFileNamePrefix( self.WRITER__STRING_empty )\n    self._setFileNameRoots(  pNames )\n    self._setFileNameSuffix( self.WRITER__STRING_empty )\n  \t\n  \n  \n  # Get the full names of the files to be generated.\n  def _getFullFileNames( self ) : \n    fullFileNames  = []\n    fileNameRoots  = self._getFileNameRoots()\n    fileNamePrefix = self._getFileNamePrefix()\n    fileNameSuffix = self._getFileNameSuffix()\n    numFiles       = len( fileNameRoots )\n    for fileI in range( numFiles ) :\n      fullFileNames.append( fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix )\n  \n    return fullFileNames\n  \n  \n  \n  # Set the root of the name of the file to be generated. \n  def _setFileNameRoot( self, pRoot ) :\n    root = str( pRoot )\n    self._setFileNameRoots( [ root ] )\n  \n  \n  \n  # Get the root of the name of current file being generated.\n  def _getFileNameRoot( self ) :\n    return self.writer__iFileNameRoots[ self.writer__iCurrentFileIndex ]\n  \n  \n  \n  # Get roots of the names of files to be generated.\n  def _getFileNameRoots( self ) :\n    return self.writer__iFileNameRoots\n  \n  \n  \n  # Set the roots of the names of the files to be generated. \n  def _setFileNameRoots( self, pRoots ) :\n    self.writer__iFileNameRoots = pRoots\n    self.writer__iNumFiles      = len( self.writer__iFileNameRoots )\n  \n  \n  \n  # Get index of file currently being generated.\n  def _getFileIndex( self ) :\n    return self.writer__iCurrentFileIndex\n  \n  \n  \n  # Get number of files to generate.\n  def _getNumFiles( self ) :\n    return self.writer__iNumFiles\n  \n  \n  \n  # Set output folder.\n  def _setOutputFolder( self, pOutputFolder ) : \n    outputFolder        = str( pOutputFolder )\n    self.writer__iOutputFolder = outputFolder\n   \n  \n  \n  # Get output folder.\n  def _getOutputFolder( self ) :\n    return self.writer__iOutputFolder\n  \n  \n  \n  # Set backup folder.\n  def _setBackupFolder( self, pBackupFolder ) :\n    self.writer__iBackupFolder = pBackupFolder\n  \n  \n  \n  # Get backup folder.\n  def _getBackupFolder( self ) :\n    return self.writer__iBackupFolder\n  \n  \n  \n  # Set the prefix of backup files.\n  def _setBackupPrefix( self, pBackupPrefix ) :\n    self.writer__iBackupPrefix = pBackupPrefix\n  \n  \n  \n  # Set the suffix of backup files.\n  def _setBackupSuffix( self, pBackupSuffix ) :\n    self.writer__iBackupSuffix = pBackupSuffix\n  \n  \n  \n  # Set to true if generated files are to be backed up to disk automatically.   \n  def _backup( self, pBackup ) :\n    self.writer__iBackup = pBackup\n  \n  \n  \n  # Set to true if generated files are to be saved to disk automatically. \n  def _save( self, pSave ) :\n    self.writer__iSave = pSave\n  \n  \n  \n  # Save a text file.\n  def _saveTextFile( self, pFilePath, pContent ) :\n    file = open( pFilePath, \"w\" )\n  \n    if file :  \n      file.write( pContent )\n      file.close()\n    else :\n      raise Exception, \"Unable to read file: \" + pFilePath\n  \n    \n  \n  # Load a text file.\n  def _loadTextFile( self, pFilePath ) :\n    file = open( pFilePath, \"r\" )\n  \n    if file :  \n      contents = file.readlines()\n      file.close()\n      return string.join( contents )\n  \n    else :\n      raise Exception, \"Unable to read file: \" + pFilePath\n  \n\n\n  # Set build properties file.\n  def _setMetaPropFile( self, pMetaPropFile ):\n    self.writer__iMetaPropFile   = pMetaPropFile\n    self.writer__iPropertiesInit = $<lang.FalseString>\n\n\n\n  # Get build properties file.\n  def _getMetaPropFile( self ):\n     return self.writer__iMetaPropFile\n\n\n\n  # Template Services (File Generation) >> #\n  \n  \n  \n  \n  # Template Services (Control) << #\n  \n  # Get the value of a compile-time property.\n  def _getProperty( self, pName ) :\n  \n    if not self.writer__iPropertiesInit : \n      self.writer__initProperties()\n  \n    name   = str( pName )\n    result = self.writer__iProperties.get(name,'') \n  \n    return result\n  \n  \n  \n  # Get first user arg.\n  def _getFirstUserArg( self ) :\n    return self._getUserArg( 0 )\n  \n  \n  \n  # Get second user arg.\n  def _getSecondUserArg( self ) :\n    return self._getUserArg( 1 )\n  \n  \n  \n  # Get third user arg.\n  def _getThirdUserArg( self ) :\n    return self._getUserArg( 2 )\n  \n  \n  \n  # Get nth (n=0,1,2,...) user arg (the nth arg with no self.WRITER__ARGUMENT_CONTROL_PREFIX).\n  def _getUserArg( self, pOrdinal ) :\n    if pOrdinal < self._getNumUserArgs() :\n      userargs = self._getUserArgs()\n      return userargs[ pOrdinal ]\n    else :\n      return self.WRITER__STRING_empty\n  \n  \n  \n  # Get usercommand line arguments to CodeWriter. \n  def _getUserArgs( self ) :\n    return self.writer__iUserArgs\n  \n  \n  \n  # Get number of user command line arguments to CodeWriter.\n  def _getNumUserArgs( self ) :\n    return self.writer__iNumUserArgs\n  \n  \n  \n  # Get command line arguments to CodeWriter. \n  def _getArgs( self ) :\n    return self.writer__iArgs\n  \n  \n  \n  # Get number of command line arguments to CodeWriter.\n  def _getNumArgs( self ) :\n    return self.writer__iNumArgs\n  \n  # Template Services (Control) >> #\n  \n  \n  \n  \n  # Template Services (Text Production) << #\n  \n  \n  # Insert text into generated file.\n  def _insert( self, pText ) :\n    text = str( pText )\n    self.writer__iCurrentText = self.writer__iCurrentText + text\n  \n  \n  \n  # Create a String containing specified number of spaces.\n  def _spaces( self, pNumSpaces ) :\n    return \" \" * abs( int( pNumSpaces ) )\n  \n  \n  \n  # Left align String with spaces. \n  def _left( self, pText, pColWidth ) :\n    return self._align( pText, \" \", pColWidth, 'l' )\n  \n  \n  \n  # Right align String with spaces. \n  def _right( self, pText, pColWidth ) :\n    return self._align( pText, \" \", pColWidth, 'r' )\n  \n  \n  \n  # Center align String with spaces. \n  def _center( self, pText, pColWidth ) :\n    return self._align( pText, \" \", pColWidth, 'c' )\n  \n  \n  \n  # Align text within background text with specified column width.\n  # Alignment can be 'l': left, 'c': center, 'r': right\n  def _align( self, pText, pBackText, pColWidth, pAlignment ) :\n  \n    result = pText\n   \n    try :\n      textLen = len( pText )\n      if pColWidth > textLen :\n        backTextLen     = len( pBackText )\n        remainWidth     = pColWidth - textLen\n        backTextRepeats = remainWidth / backTextLen\n        backTextRemain  = remainWidth % backTextLen\n        back            = self.WRITER__STRING_empty\n        for backTextI in range( backTextRepeats ) :\n          back = back + pBackText\n  \n        back = back + pBackText[0:backTextRemain]\n  \n        if 'l' == pAlignment :\n          result = result + back\n  \n        elif 'c' == pAlignment :\n          result = back[0:(len(back)/2)] + result + back[(len(back)/2):]\n  \n        elif 'r' == pAlignment :\n          result = back + result\n  \n    except Exception, e:\n      result = pText\n  \n    return result\n  \n  \n  \n  # Get text of file currently being generated.\n  def _getText( self ) :\n    return self.writer__iCurrentText\n  \n  \n  \n  # Set text of file currently being generated.\n  def _setText( self, pText ) :\n    self.writer__iCurrentText = pText\n  \n  # Template Services (Text Production) >> */\n\n\n\n\n# Language Specific Services << #\n\n\n# Insert text into generated file. \n# This special name is used for automated indentation.\ndef _py_insert( obj, pText ) :\n  obj._insert( pText )\n\n# Language Specific Services >> #\n\n\n\n# Start execution.\nif __name__ == \"__main__\":\n  cw = $<main.CodeWriter>();\n  cw.main( sys.argv )\n  sys.exit( 0 )\n\n\n!<footer>\n");
    }

    private static final void makeWF_BasicRubyWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicRubyWriterFormat.jwf", "!<header>\n\n\n\n!<{import># section:import\n!<import>!<}import>\n\n\n\n!<{require># section:require\n!<require>!<}require>\n\n\n\nclass $<main.CodeWriter> $<{ruby.CodeWriter.extends> < $<ruby.CodeWriter.extends> $<}ruby.CodeWriter.extends> \n  \n  # Constants << #\n   \n  # Command line arguments\n  WRITER__ARGUMENT_CONTROL_PREFIX         = \"$<main.CodeWriter.argument.ControlPrefix>\"\n  WRITER__ARGUMENT_OutputFolder           = \"$<main.CodeWriter.argument.name.OutputFolder>\"\n  WRITER__ARGUMENT_MetaPropFile           = \"$<main.CodeWriter.argument.name.MetaPropFile>\"\n  WRITER__ARGUMENT_BackupFolder           = \"$<main.CodeWriter.argument.name.BackupFolder>\"\n  WRITER__ARGUMENT_NoBackup               = \"$<main.CodeWriter.argument.name.NoBackup>\"\n  \n  # User Interface text message parts\n  WRITER__UITEXT_Method                   = \"method \"\n  WRITER__UITEXT_Main                     = \"main \"\n  WRITER__UITEXT_ExceptionIn              = \"Exception in \"\n  WRITER__UITEXT_ColonNewLine             = \":\\n\"\n  WRITER__UITEXT_NewLine                  = \"\\n\"\n  WRITER__UITEXT_Section                  = \"section \"\n  WRITER__UITEXT_SavedFile                = \"Saved file:       \"\n  WRITER__UITEXT_UnableToSaveFile         = \"Unable to save file: \"\n  WRITER__UITEXT_UnableToBackupFile       = \"Unable to backup file: \"\n  WRITER__UITEXT_ToBackupFolder           = \" to backup folder: \"\n  WRITER__UITEXT_BackupFolderColon        = \"Backup folder: \"\n  WRITER__UITEXT_BackupFolderExistFailure = \" does not exist and cannot be created.\"\n  WRITER__UITEXT_BackupFolderNotAFolder   = \" is not a folder.\"\n  WRITER__UITEXT_BackupFolderNotWritable  = \" is not writable.\"\n  WRITER__UITEXT_CodeWriterState          = \"Code Writer State: \"\n  WRITER__UITEXT_GetFileIndexEquals       = \"\\n_getFileIndex()    = \"\n  WRITER__UITEXT_GetFullFileNameEquals    = \"\\n_getFullFileName() = \"\n  WRITER__UITEXT_GetOutputFolderEquals    = \"\\n_getOutputFolder() = \"\n  WRITER__UITEXT_ErrorHeader              = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\"\n  WRITER__UITEXT_ErrorFooter              = \"\\n--- CodeWriter Error Description End -----\\n\\n\"\n  WRITER__UITEXT_UnableToLoadMetaProps    = \"Unable to load metadata from file: \"\n  WRITER__UITEXT_PlaceHolderException     = \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\"\n\n  # String constants\n  WRITER__STRING_empty                    = \"\"\n  WRITER__STRING_dot                      = \".\"\n  WRITER__STRING_separator                = \"$<\\jostraca.system.fileSeparator>\"\n\n  # Constants >> #\n  \n\n  \n  \n  # Writer Variables << #\n  \n  def writer__initInstanceVars()\n    @writer__iFileNameRoots         = []                    # generated file name roots\n    @writer__iNumFiles              = 0                     # number of generated files\n    \n    @writer__iFileNamePrefix        = WRITER__STRING_empty  # failsafe default\n    @writer__iFileNameSuffix        = WRITER__STRING_empty  # failsafe default\n  \n    @writer__iBackupPrefix          = WRITER__STRING_empty  # failsafe default\n    @writer__iBackupSuffix          = WRITER__STRING_empty  # failsafe default\n  \n    @writer__iCurrentText           = WRITER__STRING_empty  # current text\n    @writer__iCurrentFileIndex      = 0                     # current file index\n  \n    @writer__iArgs                  = []                    # cmd line args\n    @writer__iNumArgs               = 0                     # number of cmd line args\n    @writer__iUserArgs              = []                    # user cmd line args\n    @writer__iNumUserArgs           = 0                     # number of user cmd line args\n  \n    @writer__iSave                  = true                  # save generated code to disk\n    @writer__iBackup                = true                  # make backups\n  \n    @writer__iOutputFolder          = WRITER__STRING_dot    # written code is output to this folder\n    @writer__iBackupFolder          = WRITER__STRING_dot    # overwritten files are placed here\n    @writer__iMetaPropFile          = WRITER__STRING_empty  # metadata properties file path\n\n    @writer__iProperties            = {}                    # lookup table for compile time properties\n    @writer__iPropertiesInit        = false                 # true => lookup table initialiased\n  end  \n\n  # Writer Variables >> #\n  \n  \n\n  \n  !<{support># version 0.1 compatibility # section:support\n  !<support>!<}support>\n\n\n\n  !<{declare># section:declare\n  !<declare>!<}declare>\n  \n    \n  \n  # Execute.\n  def $<main.CodeWriter>.main( pArgs )\n    begin\n      codeWriter = $<main.CodeWriter>.new\n      codeWriter.writer__initialize()\n      codeWriter.writer__handleArgs( pArgs )\n      codeWriter.writer__write()\n    rescue\n      codeWriter.writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Method + WRITER__UITEXT_Main, $! )      \n    end\n  end\n\n\n\n\n  # Writer Services << #\n  \n  # Initialize.\n  def writer__initialize()\n    @writer__iCurrentFileIndex = 0\n    writer__initInstanceVars()\n    writer__setDefaults()\n  end\n  \n  \n\n  # Main file generation loop. Template script is placed here in the body section.\n  def writer__write()\n\n    # initialize\n    writer__currentSection = \"init\"\n  \n  \n    begin\n  \n      !<{init># section:init\n      !<init>!<}init> \n  \n  \n      # write files loop\n      writer__numFiles = _getNumFiles()\n      writer__fileI    = 0\n      for writer__fileI in 0...writer__numFiles\n\n        begin\n  \n          !<{prewrite># section:prewrite\n          writer__currentSection = \"prewrite\"\n          !<prewrite>!<}prewrite> \n  \n  \n          if ! writer__startFile()\n            next\n          end\n  \n  \n          !<{body># section:body\n          writer__currentSection = \"body\"\n          !<body>!<}body> \n  \n  \n          if ! writer__endFile()\n            next\n          end\n  \n  \n          !<{postwrite># section:postwrite\n          writer__currentSection = \"postwrite\"\n          !<postwrite>!<}postwrite> \n  \n  \n        rescue\n          writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, $! )\n        end\n  \n        writer__nextFile()       \n      end\n   \n  \n        !<{cleanup># section:cleanup \n        writer__currentSection = \"cleanup\"\n        !<cleanup>!<}cleanup> \n  \n    rescue\n      writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, $! )\n    end\n  end\n  \n  \n  \n  # Start writing a file.\n  def writer__startFile()\n    @writer__iCurrentText = WRITER__STRING_empty\n    return true\n  end\n  \n  \n  \n  # End writing a file.\n  def writer__endFile()\n    endOK = true\n  \n    fileName = _getFullFileName()\n    filePath = _getOutputFolder() + WRITER__STRING_separator + fileName # CP!\n\n    if @writer__iBackup\n      begin\n        writer__backup( filePath, fileName, @writer__iBackupFolder )\n      rescue\n        writer__handleException( WRITER__UITEXT_UnableToBackupFile + filePath + WRITER__UITEXT_ToBackupFolder + @writer__iBackupFolder, $! )\n        endOK = false\n      end\n    end\n\n    if( endOK && @writer__iSave )\n      begin\n        _saveTextFile( filePath, @writer__iCurrentText )\n        writer__userMessage( WRITER__UITEXT_SavedFile + filePath + WRITER__UITEXT_NewLine, false )\n  \n      rescue\n        writer__handleException( WRITER__UITEXT_UnableToSaveFile + filePath, $! )\n        endOK = false\n      end\n    end\n  \n    return endOK\n  end\n  \n  \n  \n  # Move to next file.\n  def writer__nextFile()\n    @writer__iCurrentFileIndex = @writer__iCurrentFileIndex + 1\n  end\n  \n  \n  \n  # Handle command line arguments to CodeWriter.\n  def writer__handleArgs( pArgs )\n  \n    # set arg names\n    argName_OutputFolder           = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_OutputFolder\n    argName_MetaPropFile           = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_MetaPropFile\n    argName_BackupFolder           = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_BackupFolder\n    argName_NoBackup               = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_NoBackup\n  \n    # parse args\n    # ...\n  \n    numArgs = pArgs.length\n    argI    = 0\n    for argI in 0...numArgs\n      if( pArgs[argI] =~ /^#{argName_OutputFolder}(.*)/ )\n        _setOutputFolder( $1 )\n\n      elsif( pArgs[argI] =~ /^#{argName_MetaPropFile}(.*)/ )\n        _setMetaPropFile( $1 )\n\n      elsif( pArgs[argI] =~ /^#{argName_BackupFolder}(.*)/ )\n        _setBackupFolder( $1 )\n\n      elsif( argName_NoBackup = pArgs[argI] )\n        _backup( $<lang.FalseString> ); ## NOTE: -B => don't make backups\n      end\n    end\n  \n    writer__initArgs( pArgs.length, pArgs )\n  \n  end\n  \n  \n  \n  # Set defaults from configuration property set.\n  def writer__setDefaults()\n\n    $<{main.FileNameRoot>_setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n    $<{main.FileNamePrefix>_setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n    $<{main.FileNameSuffix>_setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n    $<{main.OutputFolder>_setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n    $<{main.BackupFolder>_setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n    $<{main.BackupPrefix>_setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n    $<{main.BackupSuffix>_setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n    _backup( \"$<lang.TrueString>\" == \"$<jostraca.MakeBackup>\" );\n\n  end\n  \n  \n  # Initialize command line arguments.\n  def writer__initArgs( pNumArgs, pArgs )\n    argI     = 0\n    userArgI = 0\n\n    @writer__iNumArgs     = pNumArgs\n    @writer__iArgs        = pArgs\n    @writer__iNumUserArgs = @writer__iNumArgs\n\n    for argI in 0...@writer__iNumArgs\n      if( @writer__iArgs[argI] =~ /^#{WRITER__ARGUMENT_CONTROL_PREFIX}/ )\n        @writer__iNumUserArgs = @writer__iNumUserArgs - 1;\n      end\n    end\n\n    for argI in 0...@writer__iNumArgs\n      if( @writer__iArgs[argI] =~ /^#{WRITER__ARGUMENT_CONTROL_PREFIX}/ )\n        next;\n      else \n        @writer__iUserArgs[ userArgI ] = @writer__iArgs[ argI ];\n        userArgI = userArgI + 1;\n      end\n    end     \n  end\n  \n  \n  # Print a user readable message.\n  def writer__userMessage( pMessage, pError )\n    if( pError )\n      $stderr.print( pMessage )\n    else \n    print( pMessage )\n  end\n  end\n  \n  \n  \n  # Handle exceptions: print an explanation for user.\n  def writer__handleException( pMessage, pException )\n  \n    userMsg = WRITER__UITEXT_ErrorHeader\n\n    # CP!\n    writerState = WRITER__STRING_empty\n    begin\n      writerState = writer__describeState()\n    rescue \n      # leave empty\n    end\n\n    userMsg = userMsg + writerState + pMessage + WRITER__UITEXT_ColonNewLine\n    userMsg = userMsg + pException.message + WRITER__UITEXT_NewLine\n    userMsg = userMsg + pException.backtrace.join( WRITER__UITEXT_NewLine )\n    userMsg = userMsg + WRITER__UITEXT_ErrorFooter\n  \n    writer__userMessage( userMsg, true )\n  end\n  \n  \n  \n  # Provide a concise description of the state of the CodeWriter.\n  def writer__describeState()\n    currentState                                                     \\\n      = WRITER__UITEXT_CodeWriterState                               \\\n      + WRITER__UITEXT_GetFileIndexEquals    + _getFileIndex().to_s  \\\n      + WRITER__UITEXT_GetFullFileNameEquals + _getFullFileName()    \\\n      + WRITER__UITEXT_GetOutputFolderEquals + _getOutputFolder()    \\\n      + WRITER__UITEXT_NewLine\n           \n    return currentState\n  end\n\n  \n    \n  # Backup overwritten files, if they exist.\n  # Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n  def writer__backup( pFilePath, pFileName, pBackupFolder )\n  \n    backupFolder = pBackupFolder\n\n    # check backup folder ( create if necessary )\n    if( !( FileTest.exist?(backupFolder) ) )\n      if( !( Dir.mkdir( backupFolder, 0700 ) ) )\n        raise( WRITER__UITEXT_BackupFolderColon + backupFolder + WRITER__UITEXT_BackupFolderExistFailure )\n      end\n    end\n    if( !( FileTest.directory?(backupFolder) ) )\n      raise( WRITER__UITEXT_BackupFolderColon + backupFolder + WRITER__UITEXT_BackupFolderNotAFolder )\n    end\n    if( !( FileTest.writable?(backupFolder) ) )\n      raise( WRITER__UITEXT_BackupFolderColon + backupFolder + WRITER__UITEXT_BackupFolderNotWritable )\n    end\n  \n\n    # create backup file path\n    calendar = Time.new\n\n    year_yyyy = _align( calendar.year   ,\"0\", 4, 'r' )\n    month_mm  = _align( calendar.month  ,\"0\", 2, 'r' )\n    day_dd    = _align( calendar.day    ,\"0\", 2, 'r' )\n    hour_hh   = _align( calendar.hour   ,\"0\", 2, 'r' )\n    minute_mm = _align( calendar.min    ,\"0\", 2, 'r' )\n    second_ss = _align( calendar.sec    ,\"0\", 2, 'r' )\n    dateTime  = year_yyyy + month_mm + day_dd + hour_hh + minute_mm + second_ss\n\n    backupFileName = dateTime + @writer__iBackupPrefix + pFileName + @writer__iBackupSuffix\n    backupFilePath = backupFolder + WRITER__STRING_separator + backupFileName # CP!\n      \n    # save backup file\n    if( FileTest.exist?( pFilePath ) )\n      fileContents = _loadTextFile( pFilePath )\n      _saveTextFile( backupFilePath, fileContents )\n    end\n  end\n  \n  \n  \n  # Set compile time properties.\n  def writer__initProperties()\n    metaPropFile = _getMetaPropFile()\n\n    if( \"\" != metaPropFile)\n      @writer__iProperties = {}    \n\n      begin\n        content  = _loadTextFile( metaPropFile )\n\n        content = content.gsub( /\\r\\n/, \"\\n\" )\n        content = content.gsub( /\\r/, \"\\n\" )\n\n        content.scan( /\\n\\s*(.*?)\\s*[=:]\\s*((\\\\\\s*\\n|.)*)/ ) {\n          |name,value| \n          value = value.strip\n          value = value.gsub( /\\\\\\s*\\n/, '' )\n          value = value.gsub( /\\n/, '' )\n          @writer__iProperties[name] = value    \n        }\n\n        @writer__iPropertiesInit = $<lang.TrueString>\n\n      rescue\n        self.writer__handleException( self.WRITER__UITEXT_UnableToLoadMetaProps+self._getMetaPropFile() )\n      end\n    end\n  end\n  \n  # Writer Services >> #\n  \n  \n\n\n  # Template Services (File Generation) << #\n  \n  # Set the prefix of the files to be generated. \n  def _setFileNamePrefix( pPrefix )\n    @writer__iFileNamePrefix = pPrefix\n  end\n  \n  \n\n  # Get prefix of files to be generated.\n  def _getFileNamePrefix()\n    return @writer__iFileNamePrefix\n  end\n  \n  \n  \n  # Set the suffix of the files to be generated.\n  def _setFileNameSuffix( pSuffix )\n    @writer__iFileNameSuffix = pSuffix\n  end\n  \n  \n  \n  # Get suffix of files to be generated.\n  def _getFileNameSuffix()\n    return @writer__iFileNameSuffix\n  end\n  \n  \n  \n  # Set the full name of the file to be generated. \n  # Prefix and Suffix are set to empty.\n  def _setFullFileName( pName )\n    _setFileNamePrefix( WRITER__STRING_empty )\n    _setFileNameRoot(   pName )\n    _setFileNameSuffix( WRITER__STRING_empty )\n  end\n  \n  \n\n  # Get the full name of current file being generated.\n  def _getFullFileName()\n      return _getFileNamePrefix() + _getFileNameRoot() + _getFileNameSuffix()\n  end\n  \n  \n  \n  # Set the names of the files to be generated. \n  # Prefix and Suffix are set to empty.\n  def _setFullFileNames( pNames )\n      _setFileNamePrefix( WRITER__STRING_empty )\n      _setFileNameRoots(  pNames )\n      _setFileNameSuffix( WRITER__STRING_empty )\n  end\n  \n  \n\n  # Get the full names of the files to be generated.\n  def _getFullFileNames()\n  \n      fileNameRoots  = _getFileNameRoots()\n      numFiles       = fileNameRoots.length\n      fullFileNames  = []\n      fileNamePrefix = _getFileNamePrefix()\n      fileNameSuffix = _getFileNameSuffix()\n  \n      fileI = 0\n      for fileI in 0...numFiles\n        fullFileNames[ fileI ] = fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix\n      end\n  \n      return fullFileNames\n  end\n  \n  \n\n  # Set the root of the name of the file to be generated. \n  def _setFileNameRoot( pFileNameRoot )\n    _setFileNameRoots( [ pFileNameRoot ] )\n  end\n  \n  \n\n  # Get the root of the name of current file being generated.\n  def _getFileNameRoot()\n    if( nil == @writer__iFileNameRoots ) \n      return WRITER__STRING_empty\n    else\n      return @writer__iFileNameRoots[ @writer__iCurrentFileIndex ]\n    end\n  end\n\n\n\n  # Set the roots of the names of the files to be generated. \n  def _setFileNameRoots( pFileNameRoots )\n    @writer__iFileNameRoots = pFileNameRoots\n    @writer__iNumFiles      = @writer__iFileNameRoots.length\n  end\n\n  \n\n  # Get roots of the names of files to be generated.\n  def _getFileNameRoots()\n    return @writer__iFileNameRoots\n  end\n  \n  \n  \n  # Get index of file currently being generated. \n  def _getFileIndex()\n    return @writer__iCurrentFileIndex\n  end\n  \n  \n\n  # Get number of files to generate.\n  def _getNumFiles\n    return @writer__iNumFiles;\n  end\n\n\n\n  # Set output folder.\n  def _setOutputFolder( pOutputFolder )\n    @writer__iOutputFolder = pOutputFolder\n  end\n  \n  \n  \n  # Get output folder.\n  def _getOutputFolder()\n    return @writer__iOutputFolder\n  end\n  \n  \n  \n  # Set backup folder.\n  def _setBackupFolder( pBackupFolder )\n    @writer__iBackupFolder = pBackupFolder\n  end\n  \n  \n  \n  # Get backup folder.\n  def _getBackupFolder()\n    return @writer__iBackupFolder\n  end\n  \n  \n  \n  # Set the prefix of backup files.\n  def _setBackupPrefix( pBackupPrefix )\n    @writer__iBackupPrefix = pBackupPrefix\n  end\n\n\n\n  # Set the suffix of backup files.\n  def _setBackupSuffix( pBackupSuffix )\n    @writer__iBackupSuffix = pBackupSuffix\n  end\n  \n  \n\n  # Set to true if generated files are to be backed up to disk automatically.   \n  def _backup( pBackup )\n    @writer__iBackup = pBackup\n  end\n\n\n  \n  # Set to true if generated files are to be saved to disk automatically. \n  def _save( pSave )\n    @writer__iSave = pSave\n  end\n  \n  \n\n  # Save a text file.\n  def _saveTextFile( pFilePath, pContent ) \n    file = open( pFilePath, \"w\" )\n  \tfile.print pContent\n    file.close()\n  end\n  \n  \n\n  # Load a text file.\n  def _loadTextFile( pFilePath )\n    content = ''\n    file    = open( pFilePath, 'r' )\n    file.readlines.each { |line| content += line }\n    file.close\n    return content\n  end\n\n\n  # Set build properties file.\n  def _setMetaPropFile( pMetaPropFile )\n    @writer__iMetaPropFile   = pMetaPropFile\n    @writer__iPropertiesInit = $<lang.FalseString>\n  end\n\n\n  # Get build properties file.\n  def _getMetaPropFile()\n     return @writer__iMetaPropFile\n  end\n\n\n  # Template Services (File Generation) >> #\n\n\n\n\n  # Template Services (Control) << #\n\n  # Get the value of a compile-time property.\n  def _getProperty( pName )\n  \n    if ! @writer__iPropertiesInit\n      writer__initProperties()\n    end\n  \n    return @writer__iProperties[ pName ]\n  end\n  \n  \n  \n  # Get first user arg.\n  def _getFirstUserArg()\n    return _getUserArg( 0 )\n  end\n  \n  \n  \n  # Get second user arg.\n  def _getSecondUserArg()\n    return _getUserArg( 1 )\n  end\n  \n  \n  \n  # Get third user arg.\n  def _getThirdUserArg()\n    return _getUserArg( 2 )\n  end\n  \n  \n  \n  # Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX).\n  def _getUserArg( pOrdinal )\n    if pOrdinal < _getNumUserArgs()\n      userargs = _getUserArgs();\n      return userargs[ pOrdinal ];\n    else \n      return writer__STRING_empty;\n    end\n  end\n  \n  \n  \n  # Get user command line arguments to CodeWriter.\n  def _getUserArgs()\n    return @writer__iUserArgs;\n  end\n\n\n\n  # Get number of user command line arguments to CodeWriter.\n  def _getNumUserArgs()\n    return @writer__iNumUserArgs;\n  end\n\n\n\n  # Get command line arguments to CodeWriter. \n  def _getArgs()\n    return @writer__iArgs\n  end\n  \n  \n  \n  # Get number of command line arguments to CodeWriter.\n  def _getNumArgs()\n    return @writer__iNumArgs\n  end\n  \n  # Template Services (Control) >> #\n  \n\n\n\n  # Template Services (Text Production) << #\n\n  # Insert text into generated file. \n  def _insert( pText )\n    text = pText.to_s\n    @writer__iCurrentText = @writer__iCurrentText + text\n  end\n  \n  \n  \n  # Create a String containing specified number of spaces.\n  def _spaces( pNumSpaces )\n    numSpaces = pNumSpaces.to_i\n    return ' ' * numSpaces.abs\n  end\n  \n  \n  \n  # Left align String with spaces. \n  def _left( pText, pColWidth )\n    return _align( pText, \" \", pColWidth, 'l' )\n  end \n  \n  \n  \n  # Right align String with spaces. \n  def _right( pText, pColWidth )\n    return _align( pText, \" \", pColWidth, 'r' )\n  end \n  \n  \n  \n  # Center align String with spaces. \n  def _center( pText, pColWidth )\n    return _align( pText, \" \", pColWidth, 'c' )\n  end \n  \n  \n  \n  # Align text within background text with specified column width.\n  # Alignment can be 'l': left, 'c': center, 'r': right\n  def _align( pText, pBackText, pColWidth, pAlignment )\n    text     = pText.to_s\n    backText = pBackText.to_s\n\n    result   = text\n \n    begin\n      textLen = text.length\n      if( pColWidth > textLen ) then\n        backTextLen     = backText.length\n        remainWidth     = pColWidth - textLen\n        backTextRepeats = remainWidth / backTextLen;\n        backTextRemain  = remainWidth % backTextLen;\n        back            = WRITER__STRING_empty\n        backTextI       = 0\n        for backTextI in 0...backTextRepeats\n          back += backText\n        end\n        back += backText[0...backTextRemain];\n        \n        if( 'l' == pAlignment ) then\n          result = result + back\n          \n        elsif( 'c' == pAlignment ) then\n          result = back[0...((back.length)/2)] + result + back[ (((back.length)/2))...back.length ];\n\n        elsif( 'r' == pAlignment ) then\n          result = back + result;\n\n        end\n      end\n    rescue\n      result = text\n    end\n\n    return result\n  end\n\n\n\n  # Set text of file currently being generated.\n  def _setText( pCurrentText )\n    @writer__iCurrentText = pCurrentText\n  end\n\n\n\n  # Get text of file currently being generated.\n  def _getText()\n    return @writer__iCurrentText\n  end\n\n  # Template Services (Text Production) >> */\n\nend\n\n\n\n\n# Start execution.\n$<main.CodeWriter>.main( ARGV )\nexit( 0 )\n\n\n\n!<footer>\n");
    }

    private static final void makeWF_BasicCWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicCWriterFormat.jwf", "!<header>\n\n#include <stdio.h>\n#include <string.h>\n#include <dirent.h>\n#include <time.h>\n\n\n\n!<{include>/* section:include */\n!<include>!<}include>\n\n\n\n/* Constants << */ \n\n/* Command line arguments */\nchar* WRITER__ARGUMENT_CONTROL_PREFIX          = \"$<main.CodeWriter.argument.ControlPrefix>\";\nchar* WRITER__ARGUMENT_OutputFolder            = \"$<main.CodeWriter.argument.name.OutputFolder>\";\nchar* WRITER__ARGUMENT_MetaPropFile            = \"$<main.CodeWriter.argument.name.MetaPropFile>\";\nchar* WRITER__ARGUMENT_BackupFolder            = \"$<main.CodeWriter.argument.name.BackupFolder>\";\nchar* WRITER__ARGUMENT_NoBackup                = \"$<main.CodeWriter.argument.name.NoBackup>\";\n\n/* User Interface text message parts */\nchar* WRITER__UITEXT_Method                    = \"method \";\nchar* WRITER__UITEXT_Main                      = \"main \";\nchar* WRITER__UITEXT_ExceptionIn               = \"Exception in \";\nchar* WRITER__UITEXT_ColonNewLine              = \":\\n\";\nchar* WRITER__UITEXT_NewLine                   = \"\\n\";\nchar* WRITER__UITEXT_Section                   = \"section \";\nchar* WRITER__UITEXT_SavedFile                 = \"Saved file:       \";\nchar* WRITER__UITEXT_UnableToSaveFile          = \"Unable to save file: \";\nchar* WRITER__UITEXT_UnableToBackupFile        = \"Unable to backup file: \";\nchar* WRITER__UITEXT_ToBackupFolder            = \" to backup folder: \";\nchar* WRITER__UITEXT_BackupFolderColon         = \"Backup folder: \";\nchar* WRITER__UITEXT_BackupFolderExistFailure  = \" does not exist and cannot be created.\";\nchar* WRITER__UITEXT_BackupFolderNotAFolder    = \" is not a folder.\";\nchar* WRITER__UITEXT_BackupFolderNotWritable   = \" is not writable.\";\nchar* WRITER__UITEXT_CodeWriterState           = \"Code Writer State: \";\nchar* WRITER__UITEXT_GetFileIndexEquals        = \"\\n_getFileIndex()    = \";\nchar* WRITER__UITEXT_GetFullFileNameEquals     = \"\\n_getFullFileName() = \";\nchar* WRITER__UITEXT_GetOutputFolderEquals     = \"\\n_getOutputFolder() = \";\nchar* WRITER__UITEXT_ErrorHeader               = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\nchar* WRITER__UITEXT_ErrorFooter               = \"\\n--- CodeWriter Error Description End -----\\n\\n\";\nchar* WRITER__UITEXT_UnableToLoadMetaProps     = \"Unable to load metadata from file: \";\nchar* WRITER__UITEXT_PlaceHolderException      = \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\";\n\n/* String constants */\n#define WRITER__STRING_empty                   \"\"\n#define WRITER__STRING_dot                     \".\"\n#define WRITER__STRING_separator               \"$<\\jostraca.system.fileSeparator>\"\n\n#define WRITER__MAX_LINE_LEN 2222\n\n\n\n\n/* Constants >> */\n\n\n\n\n/* section:define */\n#define _insertf(f,v) { sprintf( writer__iSprintfInsertBuffer, f, v); _insert( writer__iSprintfInsertBuffer ); }\n!<define>\n\n\n\n/* requires a NULL entry will empty line at end */\nstruct writer__FileText {\n  char*                    line;\n  struct writer__FileText* next; \n};\n\n\n\n/* Writer Variables << */\n\nchar**    writer__iFileNameRoots                   = NULL;                     /* generated file name roots */\nint       writer__iNumFiles                        = 0;                        /* number of generated files */\n  \nchar*     writer__iFileNamePrefix                  = WRITER__STRING_empty;     /* failsafe default */\nchar*     writer__iFileNameSuffix                  = WRITER__STRING_empty;     /* failsafe default */\n\nchar*     writer__iBackupPrefix                    = WRITER__STRING_empty;     /* failsafe default */\nchar*     writer__iBackupSuffix                    = WRITER__STRING_empty;     /* failsafe default */\n\nstruct writer__FileText* writer__iCurrentText      = NULL;                     /* current text */\nstruct writer__FileText* writer__iCurrentTextLine  = NULL;                     /* current text line */\nint                      writer__iCurrentFileIndex = 0;                        /* current file index */\n\nchar**    writer__iArgs                            = NULL;                     /* cmd line args */\nint       writer__iNumArgs                         = 0;                        /* number of cmd line args */\nchar**    writer__iUserArgs                        = NULL;                     /* user cmd line args */\nint       writer__iNumUserArgs                     = 0;                        /* number of user cmd line args */\n\nint       writer__iSave                            = 1;                        /* save generated code to disk */\nint       writer__iBackup                          = 1;                        /* make backups */\n\nchar*     writer__iOutputFolder                    = WRITER__STRING_dot;       /* written code is output to this folder */\nchar*     writer__iBackupFolder                    = WRITER__STRING_dot;       /* overwritten files are placed here */\nchar*     writer__iMetaPropFile                    = WRITER__STRING_empty;     /* metadata properties file path */\n\nstruct writer__FileText* writer__iProperties       = NULL;                     /* empty set of properties */  \nint       writer__iPropertiesInit                  = 1;                        /* true => lookup table initialiased */\n\nint       writer__iException                       = 0;                        /* true => exception was thrown */\nchar*     writer__iExceptionMessage                = WRITER__STRING_empty;     /* internal message describing the exception */\n\n\nchar  writer__iSprintfInsertBuffer[ WRITER__MAX_LINE_LEN ];\n\n/* Writer Variables >> */\n\n\n\nvoid      writer__initialize();\nvoid      writer__write();\nint       writer__startFile();\nint       writer__endFile();\nvoid      writer__nextFile();\nvoid      writer__handleArgs( int argc, char *argv[] );\nvoid      writer__setDefaults();\nvoid      writer__initArgs(int argc, char** argv);\nvoid      writer__userMessage( char* pMessage, int pError );\nvoid      writer__handleException( char* pMessage, char* pException );\nchar*     writer__describeState();\nvoid      writer__backup( char* pFilePath, char* pFileName, char* pBackupFolder );\nstruct writer__FileText* writer__insert( char* pText, struct writer__FileText* pTextLine );\nvoid      writer__initProperties(); \n\n\nvoid      _setFileNamePrefix(char* pPrefix);\nchar*     _getFileNamePrefix();\nvoid      _setFileNameSuffix(char* pSuffix);\nchar*     _getFileNameSuffix();\nvoid      _setFullFileName( char* pName );\nchar*     _getFullFileName();\nvoid      _setFullFileNames( int pNumFileNames, char* pFullFileNames[] );\nchar**    _getFullFileNames();\nvoid      _setFileNameRoot(char* pFileNameRoot);\nchar*     _getFileNameRoot();\nvoid      _setFileNameRoots(int pNumFileNameRoots, char* pFileNameRoots[]);\nchar**    _getFileNameRoots();\nint       _getFileIndex();\nint       _getNumFiles();\nvoid      _setOutputFolder(char* pOutputFolder);\nchar*     _getOutputFolder();\nvoid      _setBackupFolder(char* pBackupFolder);\nchar*     _getBackupFolder();\nvoid      _backup( int pBackup );\nvoid      _setBackupPrefix( char* pBackupPrefix );\nvoid      _setBackupSuffix( char* pBackupSuffix );\nvoid      _backup( int pBackup );\nvoid      _save( int pSave );\nvoid      _saveTextFile( char* pFilePath, struct writer__FileText* pFileText );\nstruct writer__FileText* _loadTextFile( char* pFilePath );\nvoid      _setMetaPropFile( char* pMetaPropFile );\nchar*     _getMetaPropFile();\nchar*     _getProperty( char* pName );\nchar*     _getFirstUserArg();\nchar*     _getSecondUserArg();\nchar*     _getThirdUserArg();\nchar*     _getUserArg(int pOrdinal);\nchar**    _getUserArgs();\nint       _getNumUserArgs();\nchar**    _getArgs();\nint       _getNumArgs();\nvoid      _insert(char* pText);\nchar*     _spaces(int pNumSpaces);\nchar*     _left(char* pText, int pColWidth );\nchar*     _right( char* pText, int pColWidth );\nchar*     _center( char* pText, int pColWidth );\nchar*     _align( char* pText, char* pBackText, int pColWidth, char pAlignment );\nstruct writer__FileText* _getText();\nvoid      _setText( struct writer__FileText* pFileText );\n\n\n\n\n\nchar*     _strcat( char* pFirst, char* pSecond );\n\n\n!<{support>\n// version 0.1 compatibility\n/* section:support */\n!<support>\n\n\n\n!<{declare>/* section:declare */\n!<declare>!<}declare>\n\n\n\n/** Execute Write */\nint main( int argc, char *argv[] ) {\n\n  writer__initialize();\n  writer__handleArgs( argc, argv );\n  writer__write();\n\n  if( writer__iException ) {\n    writer__handleException( _strcat( WRITER__UITEXT_ExceptionIn, _strcat( WRITER__UITEXT_Method, WRITER__UITEXT_Main ) ),\n                             writer__iExceptionMessage );      \n    return 1;\n  }\n\n  return 0;\n}\n\n\n\n/* Writer Services << */\n\n/** Initialize. */\nvoid writer__initialize() {\n  writer__iCurrentFileIndex = 0;\n  writer__setDefaults();\n}\n\n\n\n/** Main file generation loop. Template script is placed here in the body section. */\nvoid writer__write() {\n\n  /* initialize */\n  int    writer__numFiles; \n  int    writer__fileI;\n  char*  writer__currentSection = \"init\";\n\n\n  !<{init>/* section:init */\n  !<init>!<}init>\n\n\n  /* write files loop */\n  writer__numFiles = _getNumFiles();\n  writer__fileI    = 0;\n  for( writer__fileI = 0; writer__fileI < writer__numFiles; writer__fileI++ ) {\n\n\n    !<{prewrite>/* section:prewrite */\n    writer__currentSection = \"prewrite\";\n    !<prewrite>!<}prewrite>\n\n\n    if( ! writer__startFile() ) { \n      continue;\n    }\n\n\n    !<{body>/* section:body */\n    writer__currentSection = \"body\";\n    !<body>!<}body>\n\n\n    if( ! writer__endFile() ) { \n      continue;\n    }\n\n\n    !<{postwrite>/* section:postwrite */\n    writer__currentSection = \"postwrite\";\n    !<postwrite>!<}postwrite>\n\n\n    exception_for_this_file:\n    if( writer__iException ) {\n      writer__handleException( _strcat( WRITER__UITEXT_ExceptionIn, _strcat( WRITER__UITEXT_Section, writer__currentSection ) ), writer__iExceptionMessage );      \n    }\n\n    writer__nextFile();       \n  }\n \n\n  !<{cleanup>/* section:cleanup */\n  writer__currentSection = \"cleanup\";\n  !<cleanup>!<}cleanup>\n\n\n  exception_for_all_files:\n  if( writer__iException ) {\n    writer__handleException( _strcat( WRITER__UITEXT_ExceptionIn, _strcat( WRITER__UITEXT_Section, writer__currentSection ) ), writer__iExceptionMessage );      \n  }\n}\n\n\n\n/** Start writing a file. */\nint writer__startFile() {\n  writer__iCurrentTextLine       = (struct writer__FileText*) malloc(sizeof(struct writer__FileText));\n  writer__iCurrentTextLine->line = WRITER__STRING_empty;\n  writer__iCurrentTextLine->next = NULL;\n  writer__iCurrentText           = writer__iCurrentTextLine;\n  return 1;\n}\n\n\n\n/** End writing a file. */\nint writer__endFile() {\n\n  int   endOK        = 1;\n  char* outputFolder;\n  char* separator = WRITER__STRING_separator;\n  char* fileName;\n  char* filePath;\n  int   outputFolder_len;\n  int   separator_len;\n  int   fileName_len;\n\n  outputFolder     = _getOutputFolder();\n  fileName         = _getFullFileName();\n  outputFolder_len = strlen( outputFolder );\n  separator_len    = strlen( separator );\n  fileName_len     = strlen( fileName );\n\n  filePath = (char*) malloc( (unsigned) (outputFolder_len + separator_len + fileName_len + 1) );\n  strcpy( filePath, outputFolder );\n  strcat( filePath, separator );\n  strcat( filePath, fileName );\n\n  if( writer__iBackup ) {\n    writer__backup( filePath, fileName, writer__iBackupFolder );\n    if( writer__iException ) {\n       writer__handleException( _strcat( WRITER__UITEXT_UnableToBackupFile, _strcat( filePath, _strcat( WRITER__UITEXT_ToBackupFolder, writer__iBackupFolder ) ) ), writer__iExceptionMessage );\n       endOK = 0;\n    }\n  }\n\n  if( endOK && writer__iSave ) {\n    _saveTextFile( filePath, writer__iCurrentText );\n    if( writer__iException ) {\n      writer__handleException( _strcat( WRITER__UITEXT_UnableToSaveFile, filePath), writer__iExceptionMessage );\n      endOK = 0;\n    } else {\n      writer__userMessage( _strcat( WRITER__UITEXT_SavedFile, _strcat( filePath, WRITER__UITEXT_NewLine ) ), 0 );\n    }\n  }\n\n  return endOK;\n}\n\n\n\n/** Move to next file */\nvoid writer__nextFile() {\n  writer__iCurrentFileIndex = writer__iCurrentFileIndex + 1;\n}\n\n\n\n/** Handle command line arguments to CodeWriter. */\nvoid writer__handleArgs( int argc, char *argv[] ) {\n\n  /* set arg names */\n  char* argName_OutputFolder           = _strcat( WRITER__ARGUMENT_CONTROL_PREFIX, WRITER__ARGUMENT_OutputFolder );\n  char* argName_MetaPropFile           = _strcat( WRITER__ARGUMENT_CONTROL_PREFIX, WRITER__ARGUMENT_MetaPropFile );\n  char* argName_BackupFolder           = _strcat( WRITER__ARGUMENT_CONTROL_PREFIX, WRITER__ARGUMENT_BackupFolder );\n  char* argName_NoBackup               = _strcat( WRITER__ARGUMENT_CONTROL_PREFIX, WRITER__ARGUMENT_NoBackup );\n\n  /* parse args */\n  /* ... */\n\n  int argI    = 0;\n  int numArgs = argc;\n  for( argI = 0; argI < numArgs; argI++ ) {\n    if( 0 == strncmp( argName_OutputFolder, argv[argI], strlen( argName_OutputFolder) ) ) {\n      _setOutputFolder( (char*) &argv[argI][ strlen( argName_OutputFolder ) ] );\n    }\n    else if( 0 == strncmp( argName_MetaPropFile, argv[argI], strlen( argName_MetaPropFile ) ) ) {\n      _setMetaPropFile( (char*) &argv[argI][ strlen( argName_MetaPropFile ) ] );\n    }\n    else if( 0 == strncmp( argName_BackupFolder, argv[argI], strlen( argName_BackupFolder ) ) ) {\n      _setBackupFolder( (char*) &argv[argI][ strlen( argName_BackupFolder ) ] );\n    }\n    else if( 0 == strcmp( argName_NoBackup, argv[argI] ) ) {\n      _backup( $<lang.FalseString> ); /* NOTE: -B => don't make backups */\n    }\n  }\n\n  /* set options */\n  writer__initArgs( argc, argv );\n\n}\n\n\n\n/** Set defaults from configuration property set. */\nvoid writer__setDefaults() {\n\n  $<{main.FileNameRoot>_setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n  $<{main.FileNamePrefix>_setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n  $<{main.FileNameSuffix>_setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n  $<{main.OutputFolder>_setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n  $<{main.BackupFolder>_setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n  $<{main.BackupPrefix>_setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n  $<{main.BackupSuffix>_setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n  _backup( 0 == strcmp( \"$<lang.TrueString>\", \"$<jostraca.MakeBackup>\" ) );\n\n}\n\n\n\n/** Store command line arguments */\nvoid writer__initArgs(int argc, char** argv) {\n  int      argI        = 0;\n  int      userArgI    = 0;\n\n  writer__iNumArgs     = argc;\n  writer__iArgs        = argv;\n  writer__iNumUserArgs = writer__iNumArgs - 1; /* program name is first arg */\n\n  for( argI = 1; argI < writer__iNumArgs; argI = argI + 1 ) {\n    if( 0 == strncmp( WRITER__ARGUMENT_CONTROL_PREFIX, writer__iArgs[argI], strlen(WRITER__ARGUMENT_CONTROL_PREFIX) ) ) {\n      writer__iNumUserArgs = writer__iNumUserArgs - 1;\n    }\n  }\n\n  writer__iUserArgs = (char**) malloc( writer__iNumUserArgs * sizeof(char**) );\n\n  for( argI = 1; argI < writer__iNumArgs; argI = argI + 1 ) {\n    if( 0 != strncmp( WRITER__ARGUMENT_CONTROL_PREFIX, writer__iArgs[argI], strlen(WRITER__ARGUMENT_CONTROL_PREFIX) ) ) {\n      writer__iUserArgs[ userArgI ] = writer__iArgs[ argI ];\n      userArgI = userArgI + 1;\n    }\n  }\n}\n\n\n\n/** Print a user readable message */\nvoid writer__userMessage( char* pMessage, int pError ) {\n  if( perror ) {\n    fprintf( stderr, pMessage );\n  }\n  else {\n  printf( pMessage );\n}\n}\n\n\n\n/** Handle exceptions: print an explanation for user. */\nvoid writer__handleException( char* pMessage, char* pException ) {\n\n  char* userMsg = WRITER__UITEXT_ErrorHeader;\n\n  userMsg = _strcat( userMsg, writer__describeState() );\n  userMsg = _strcat( userMsg, pMessage );\n  userMsg = _strcat( userMsg, WRITER__UITEXT_ColonNewLine );\n  userMsg = _strcat( userMsg, pException );\n  userMsg = _strcat( userMsg, WRITER__UITEXT_ErrorFooter );\n\n  writer__userMessage( userMsg, 1 );\n\n  writer__iException = 0;\n}\n\n\n\n/** Provide a concise description of the state of the CodeWriter. */\nchar* writer__describeState() {\n    char* currentState = WRITER__UITEXT_CodeWriterState;\n    char fileIndex[22]; \n\n    sprintf( fileIndex, \"%d\", _getFileIndex() );\n\n    currentState = _strcat( currentState, WRITER__UITEXT_GetFileIndexEquals );\n    currentState = _strcat( currentState, fileIndex );\n    currentState = _strcat( currentState, WRITER__UITEXT_GetFullFileNameEquals );\n    currentState = _strcat( currentState, _getFullFileName() );\n    currentState = _strcat( currentState, WRITER__UITEXT_GetOutputFolderEquals );\n    currentState = _strcat( currentState, _getOutputFolder() );\n    currentState = _strcat( currentState, WRITER__UITEXT_NewLine );\n\n    return currentState;\n}\n\n\n\n/** Backup overwritten files, if they exist.\n *  Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n */\nvoid writer__backup( char* pFilePath, char* pFileName, char* pBackupFolder ) {\n\n  DIR*       backupFolder;\n  time_t     now;\n  struct tm* calendar;\n  char*      year_yyyy;\n  char*      month_mm;\n  char*      day_dd;\n  char*      hour_hh;\n  char*      minute_mm;\n  char*      second_ss;\n  char       buffer[11];\n  char*      dateTime;\n  char*      backupFileName;\n  char*      backupFilePath;\n  struct writer__FileText* fileContents;\n\n  /* check backup folder ( create if necessary ) */\n  /* ... */\n\n  backupFolder = opendir( pBackupFolder );   \n  if( NULL == backupFolder) {\n    if( -1 == mkdir( pBackupFolder, 0700 ) ) {\n      writer__iExceptionMessage = _strcat( WRITER__UITEXT_BackupFolderColon, _strcat( pBackupFolder, WRITER__UITEXT_BackupFolderExistFailure ) );\n      writer__iException = 1;\n      return;\n    }\n  }\n  if( NULL != backupFolder ) {\n    closedir( backupFolder );\n  }\n\n\n  /* create backup file path */\n  now      = (time_t) time( NULL );\n  calendar = (struct tm*) localtime( &now );\n\n  sprintf( buffer, \"%d\", 1900+(calendar->tm_year) );\n  year_yyyy = _align( buffer, \"0\", 4, 'r' );\n\n  sprintf( buffer, \"%d\", 1+(calendar->tm_mon) );\n  month_mm = _align( buffer, \"0\", 2, 'r' );\n\n  sprintf( buffer, \"%d\", calendar->tm_mday );\n  day_dd = _align( buffer, \"0\", 2, 'r' );\n\n  sprintf( buffer, \"%d\", calendar->tm_hour );\n  hour_hh = _align( buffer, \"0\", 2, 'r' );\n\n  sprintf( buffer, \"%d\", calendar->tm_min );\n  minute_mm = _align( buffer, \"0\", 2, 'r' );\n\n  sprintf( buffer, \"%d\", calendar->tm_sec );\n  second_ss = _align( buffer, \"0\", 2, 'r' );\n\n  dateTime       = _strcat( year_yyyy, _strcat( month_mm, _strcat( day_dd, _strcat( hour_hh, _strcat( minute_mm, second_ss ) ) ) ) );\n  backupFileName = _strcat( dateTime, _strcat( writer__iBackupPrefix, _strcat( pFileName, writer__iBackupSuffix ) ) );\n  backupFilePath = _strcat( pBackupFolder, _strcat( WRITER__STRING_separator, backupFileName ) );\n  \n  /* save backup file */\n  fileContents = _loadTextFile( pFilePath );\n  if( writer__iException ) { return; }\n\n  _saveTextFile( backupFilePath, fileContents );\n  if( writer__iException ) { return; }\n}\n\n\n\n/** set compile-time properties */\nvoid writer__initProperties() {\n  struct writer__FileText* content;\n  char*  metaPropFile;\n\n  metaPropFile = _getMetaPropFile();\n\n  writer__iProperties = _loadTextFile( metaPropFile );\n}\n\n\n\n/** Store a line of text. */\nstruct writer__FileText* writer__insert( char* pText, struct writer__FileText* pTextLine ) {\n  \n  struct writer__FileText* newtextline      = (struct writer__FileText*) malloc(sizeof(struct writer__FileText));\n  char*                    newtextlinechars = (char*) malloc( (unsigned) (strlen( pText )+1) );\n\n  strcpy(newtextlinechars, pText);\n  newtextline->next = NULL;\n  pTextLine->line   = newtextlinechars;\n  pTextLine->next   = newtextline;\n  return newtextline;\n}\n\n/* Writer Services >> */\n\n\n\n\n/* Template Services (File Generation) << */\n\n/** Set the prefix of the files to be generated. */\nvoid _setFileNamePrefix(char* pPrefix) {\n  writer__iFileNamePrefix = pPrefix;\n}\n\n\n\n/** Get prefix of files to be generated. */\nchar* _getFileNamePrefix() {\n  return writer__iFileNamePrefix;\n}\n\n\n\n/** Set the suffix of the files to be generated. */\nvoid _setFileNameSuffix(char* pSuffix) {\n  writer__iFileNameSuffix = pSuffix;\n}\n\n\n\n/** Get suffix of files to be generated. */\nchar* _getFileNameSuffix() {\n  return writer__iFileNameSuffix;\n}\n\n\n\n/** Set the full name of the file to be generated. \n *  Prefix and Suffix are set to empty.\n */\nvoid _setFullFileName( char* pName ) {\n  _setFileNamePrefix( WRITER__STRING_empty );\n  _setFileNameRoot(   pName );\n  _setFileNameSuffix( WRITER__STRING_empty );\n}\n\n\n\n/** Get the full name of current file being generated. */\nchar* _getFullFileName() {\n  char* fullFileName;\n  char* fileNameRoot; \n  char* fileNamePrefix; \n  char* fileNameSuffix; \n\n  fileNamePrefix = _getFileNamePrefix();\n  fileNameRoot   = _getFileNameRoot();\n  fileNameSuffix = _getFileNameSuffix();  \n\n  fullFileName = _strcat( fileNamePrefix, fileNameRoot );\n  fullFileName = _strcat( fullFileName, fileNameSuffix );\n\n  return fullFileName;\n}\n\n\n\n/** Set the names of the files to be generated. \n *  Prefix and Suffix are set to empty.\n */\nvoid _setFullFileNames( int pNumFileNames, char* pFullFileNames[] ) {\n  _setFileNamePrefix( WRITER__STRING_empty );\n  _setFileNameRoots(  pNumFileNames, pFullFileNames );\n  _setFileNameSuffix( WRITER__STRING_empty );\n}\n\n\n\n/** Get the full names of the files to be generated. */\nchar** _getFullFileNames() {\n\n  char** fileNameRoots;\n  char** fullFileNames;\n  char*  fileNamePrefix; \n  char*  fileNameSuffix; \n  int    numFiles = 0;       \n  int    fileI    = 0;\n\n  fileNameRoots  = _getFileNameRoots();\n  numFiles       = _getNumFiles();\n  fileNamePrefix = _getFileNamePrefix();\n  fileNameSuffix = _getFileNameSuffix();\n\n  fullFileNames = (char**) malloc( numFiles * sizeof(char*) );\n\n  for( fileI = 0; fileI < numFiles; fileI++ ) {\n    fullFileNames[ fileI ] = _strcat( fileNamePrefix, _strcat( fileNameRoots[ fileI ], fileNameSuffix ) );\n  }\n\n  return fullFileNames;\n}\n\n\n\n/** Set the root of the name of the file to be generated. */\nvoid _setFileNameRoot( char* pFileNameRoot ) {\n  char** fileNameRoots = (char**) malloc( sizeof( char* ) );\n  fileNameRoots[0] = pFileNameRoot;\n  _setFileNameRoots( 1, fileNameRoots );\n}\n\n\n\n/** Get the root of the name of the current file being generated. */\nchar* _getFileNameRoot() {\n  char* fileNameRoot = writer__iFileNameRoots[ writer__iCurrentFileIndex ];\n  return fileNameRoot;\n}\n\n\n\n/** Set the roots of the names of the files to be generated. */\nvoid _setFileNameRoots( int pNumFileNameRoots, char* pFileNameRoots[] ) {\n  writer__iNumFiles      = pNumFileNameRoots;\n  writer__iFileNameRoots = pFileNameRoots;\n}\n\n\n\n/** Get roots of the names of files to be generated. */\nchar** _getFileNameRoots() {\n  return (char**) writer__iFileNameRoots;\n}\n\n\n\n/** Get index of file currently being generated. */\nint _getFileIndex() {\n  return writer__iCurrentFileIndex;\n}\n\n\n/** Get number of files to generate. */\nint _getNumFiles() {\n  return writer__iNumFiles;\n}\n\n\n\n/** Set output folder. */\nvoid _setOutputFolder( char* pOutputFolder ) {\n  writer__iOutputFolder = pOutputFolder;\n}\n\n\n\n/** Get output folder. */\nchar* _getOutputFolder() {\n    return writer__iOutputFolder;\n}\n\n\n\n/** Set backup folder. */\nvoid _setBackupFolder( char* pBackupFolder ) {\n  writer__iBackupFolder = pBackupFolder;\n}\n\n\n\n/** Get backup folder. */\nchar* _getBackupFolder() {\n    return writer__iBackupFolder;\n}\n\n\n\n/** Set the prefix of backup files. */\nvoid _setBackupPrefix( char* pBackupPrefix ) {\n  writer__iBackupPrefix = pBackupPrefix;\n}\n\n\n\n/** Set the suffix of backup files. */\nvoid _setBackupSuffix( char* pBackupSuffix ) {\n  writer__iBackupSuffix = pBackupSuffix;\n}\n\n\n\n/** Set to true if generated files are to be backed up to disk automatically. */\nvoid _backup( int pBackup )  {\n  writer__iBackup = pBackup;\n}\n\n\n\n/** Set to true if generated files are to be saved to disk automatically. */\nvoid _save(int pSave) {\n  writer__iSave = pSave;\n}\n\n\n\n/** Save a text file. */\nvoid _saveTextFile( char* pFullPath, struct writer__FileText* pFileText ) {\n\n  struct writer__FileText* fileline;\n  FILE* fp;\n\n  fileline = pFileText;\n  fp = fopen( pFullPath, \"w\");\n  if( NULL == fp ) {\n    writer__iExceptionMessage = (char*) malloc( 55 + sizeof( pFullPath ) );\n    sprintf( writer__iExceptionMessage, \"Error writing: %s\", pFullPath );\n    writer__iException = 1;\n    return;\n  }\n\n  while( NULL != fileline->next ) {\n    fprintf( fp, \"%s\", fileline->line );\n    fileline = fileline->next;\n  }\n\n  fclose( fp );\n}\n\n\n\n/** Load a text file. */\nstruct writer__FileText* _loadTextFile( char* pFullPath ) {\n\n  struct writer__FileText* fileline = (struct writer__FileText*) malloc(sizeof(struct writer__FileText));\n  FILE*                    fp;\n  char                     line[ WRITER__MAX_LINE_LEN ];\n  struct writer__FileText* filetext;\n\n  fp = fopen( pFullPath, \"r\");\n  if( NULL == fp ) {\n    writer__iExceptionMessage = (char*) malloc( 55 + sizeof( pFullPath ) );\n    sprintf( writer__iExceptionMessage, \"Error reading: %s\", pFullPath );\n    writer__iException = 1;\n    return;\n  }\n\n  filetext = fileline;\n  fileline->line = WRITER__STRING_empty;\n  fileline->next = NULL;\n  while( NULL != fgets( line, WRITER__MAX_LINE_LEN, fp ) ) {\n    fileline = writer__insert( line, fileline );\n  }\n\n  fclose( fp );\n\n  return filetext;\n}\n\n\n/** Set build properties file. */\nvoid _setMetaPropFile( char* pMetaPropFile ) {\n  writer__iMetaPropFile   = pMetaPropFile;\n  writer__iPropertiesInit = 0;\n}\n\n\n\n/** Get build properties file. */\nchar* _getMetaPropFile() {\n  return writer__iMetaPropFile;\n}\n\n\n/* Template Services (File Generation) >> */\n\n\n\n\n/* Template Services (Control) << */\n\n/** Get the value of a compile-time property. */\nchar* _getProperty( char* pName ) {\n\n  struct writer__FileText* propline;\n  int cI = 0, nI = 0, sv = 0, pI = 0, namelen = 0;\n  char c;\n  char* pv;\n\n\n  if( 0 == writer__iPropertiesInit ) {\n    writer__initProperties();\n  }\n\n  cI = 0;\n  while( 0 != ( c = pName[cI++] ) ) {}\n  namelen = --cI;\n\n  propline = writer__iProperties;\n  while( NULL != propline->next ) {\n    if( 0 == strncmp( pName, propline->line, namelen ) ) {\n      nI = namelen;\n      while( 0 != ( c = propline->line[nI] ) ) {\n        if( ' ' != c && '\\t' != c && '=' != c && ':' != c ) {         \n          sv = nI;\n          break;\n        }\n        nI++;\n      }\n      while( 0 != ( c = propline->line[nI] ) ) {\n        if( ' ' == c || '\\t' == c || '\\r' == c || '\\n' == c ) {         \n          break;\n        }\n        nI++;\n      }\n\n      if( 0 == sv || sv == nI ) {\n        return \"\";\n      }\n      else {\n        pv = (char*) malloc( (unsigned) (nI-sv+1) ); \n        for( pI = 0; pI < nI-sv; pI++ ) {\n          pv[pI] = propline->line[sv+pI];\n        }\n        pv[nI-sv] = '\\0';\n        return pv;\n      }\n    }\n\n    propline = propline->next;\n  }\n\n\n  return \"\";\n}\n\n\n\n/** Get first user arg. */\nchar* _getFirstUserArg() {\n  return _getUserArg(0);\n}\n\n\n\n/** Get second user arg. */\nchar* _getSecondUserArg() {\n  return _getUserArg(1);\n}\n\n\n\n/** Get third user arg. */\nchar* _getThirdUserArg() {\n  return _getUserArg(2);\n}\n\n\n\n/** Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX). */\nchar* _getUserArg( int pOrdinal ) {\n\n  int ordinal = 0;\n  int numArgs = _getNumArgs();\n  int argI    = 0;\n\n  /** ingore code writer name (first arg) */\n  for( argI = 1; argI < numArgs; argI++ ) {\n\n    if( 0 == strncmp( WRITER__ARGUMENT_CONTROL_PREFIX, writer__iArgs[argI], strlen(WRITER__ARGUMENT_CONTROL_PREFIX) ) ) {\n      continue;\n    } else {\n      if( ordinal == pOrdinal ) {\n        return writer__iArgs[argI];\n      } else {\n        ordinal++;\n      }\n    }\n  }\n  return NULL;\n}\n\n\n\n/** Get usercommand line arguments to CodeWriter. */\nchar** _getUserArgs() {\n  return writer__iUserArgs;\n}\n\n\n\n/** Get number of user command line arguments to CodeWriter. */\nint _getNumUserArgs() {\n  return writer__iNumUserArgs;\n}\n\n\n\n/** Get command line arguments to CodeWriter. */\nchar** _getArgs() {\n  return writer__iArgs;\n}\n\n\n\n/** Get number of command line arguments to CodeWriter. */\nint _getNumArgs() {\n  return writer__iNumArgs;\n}\n\n/* Template Services (Control) >> */\n\n\n\n\n/* Template Services (Text Production) << */\n\n\n/** Insert text into generated file. */\nvoid _insert( char* pText ) {\n  writer__iCurrentTextLine = writer__insert( pText, writer__iCurrentTextLine );\n}\n\n\n\n/** Create a String containing specified number of spaces. */\nchar* _spaces( int pNumSpaces ) {\n\n  char* spaces    = NULL;\n  int   spaceI    = 0;\n  int   numSpaces = pNumSpaces;\n\n  if( numSpaces < 0 ) {\n    numSpaces = numSpaces * -1;\n  }\n  spaces = (char*) malloc( (unsigned) (numSpaces+1) );\n\n  *spaces = '\\0';\n  for( spaceI = 0; spaceI < numSpaces; spaceI++ ) {\n    strcat( spaces, \" \");\n  }\n\n  return spaces;\n}\n\n\n\n/** Left align String with spaces. */\nchar* _left(char* pText, int pColWidth ) {\n  return _align( pText, \" \", pColWidth, 'l' );\n} \n\n\n\n/** Right align String with spaces. */\nchar* _right( char* pText, int pColWidth ) {\n  return _align( pText, \" \", pColWidth, 'r' );\n} \n\n\n\n/** Center align String with spaces. */\nchar* _center( char* pText, int pColWidth ) {\n  return _align( pText, \" \", pColWidth, 'c' );\n} \n\n\n\n/** Align text within background text with specified column width.\n *  Alignment can be 'l': left, 'c': center, 'r': right\n */\nchar* _align( char* pText, char* pBackText, int pColWidth, char pAlignment ) {\n\n  char*  result;\n  int    textLen;\n  int    backTextLen;\n  int    remainWidth;\n  int    backTextRepeats;\n  int    backTextRemain;\n  int    backTextI = 0;\n  char*  back = WRITER__STRING_empty;\n  char   buffer[WRITER__MAX_LINE_LEN] = WRITER__STRING_empty;\n  int    backLen;\n\n  textLen = strlen( pText );\n  if( pColWidth > textLen ) {\n    backTextLen     = strlen( pBackText );\n    remainWidth     = pColWidth - textLen;\n    backTextRepeats = remainWidth / backTextLen;\n    backTextRemain  = remainWidth % backTextLen;\n    for( backTextI = 0; backTextI < backTextRepeats; backTextI++ ) {\n      back = _strcat( back, pBackText );\n    }\n    if( 0 < backTextRemain ) {\n      strncpy( buffer, pBackText, backTextRemain );\n      back = _strcat( back, buffer );\n    }\n\n    if( 'l' == pAlignment ) {\n      result = _strcat( pText, back );\n      \n    } else if( 'c' == pAlignment ) {\n      backLen = strlen( back );\n      result = _strcat( strncpy( buffer, back, (backLen/2) ) , pText) ;\n      result = _strcat( result, back+(backLen/2) );\n\n    } else if( 'r' == pAlignment ) {\n      result = _strcat( back, pText );\n    }\n  } \n  else {\n    result = (char*) malloc( (textLen+1) * sizeof(char) );\n    strcpy( result, pText );\n  }\n\n  return result;\n}\n\n\n\n/* Get text of file currently being generated. */\nstruct writer__FileText* _getText() {\n  return writer__iCurrentText;\n}\n\n\n\n/* Set text of file currently being generated. */\nvoid _setText( struct writer__FileText* pFileText ) {\n  writer__iCurrentText = pFileText;\n}\n\n/* Template Services (Text Production) >> */\n\n\n\n\n/* Language Specific Services << */\n\n/** Concatenate two strings, dynamically creating the needed memory. \n *  This is a nice little memory leaker...\n */\nchar * _strcat( char* pFirst, char* pSecond ) {\n  int   lenFirst  = strlen( pFirst );\n  int   lenSecond = strlen( pSecond );\n  char* result    = (char*) malloc( (lenFirst + lenSecond + 1) * sizeof(char) ); \n\n  strcpy( result, pFirst );\n  strcat( result, pSecond );\n\n  return result;\n}\n\n/* Language Specific Services >> */\n\n\n\n!<footer>\n");
    }

    private static final void makeWF_BasicRebolWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicRebolWriterFormat.jwf", "!<header>\nREBOL [\n!<rebolheader>\n]\n\n\n\n!<{import>; section:import\n!<import>!<}import>\n\n\n\n; Constants << ;\n \n; Command line arguments\nWRITER__ARGUMENT_CONTROL_PREFIX:         \"$<main.CodeWriter.argument.ControlPrefix>\"\nWRITER__ARGUMENT_OutputFolder:           \"$<main.CodeWriter.argument.name.OutputFolder>\"\nWRITER__ARGUMENT_MetaPropFile:           \"$<main.CodeWriter.argument.name.MetaPropFile>\"\nWRITER__ARGUMENT_BackupFolder:           \"$<main.CodeWriter.argument.name.BackupFolder>\"\nWRITER__ARGUMENT_NoBackup:               \"$<main.CodeWriter.argument.name.NoBackup>\"\n\n; User Interface text message parts\nWRITER__UITEXT_Method:                   \"method \"\nWRITER__UITEXT_Main:                     \"main \"\nWRITER__UITEXT_ExceptionIn:              \"Exception in \"\nWRITER__UITEXT_ColonNewLine:             \":^/\"\nWRITER__UITEXT_NewLine:                  \"^/\"\nWRITER__UITEXT_Section:                  \"section \"\nWRITER__UITEXT_SavedFile:                \"Saved file:       \"\nWRITER__UITEXT_UnableToSaveFile:         \"Unable to save file: \"\nWRITER__UITEXT_UnableToBackupFile:       \"Unable to backup file: \"\nWRITER__UITEXT_ToBackupFolder:           \" to backup folder: \"\nWRITER__UITEXT_BackupFolderColon:        \"Backup folder: \"\nWRITER__UITEXT_BackupFolderExistFailure: \" does not exist and cannot be created.\"\nWRITER__UITEXT_BackupFolderNotAFolder:   \" is not a folder.\"\nWRITER__UITEXT_BackupFolderNotWritable:  \" is not writable.\"\nWRITER__UITEXT_CodeWriterState:          \"Code Writer State: \"\nWRITER__UITEXT_GetFileIndexEquals:       \"^/_getFileIndex()    \"\nWRITER__UITEXT_GetFullFileNameEquals:    \"^/_getFullFileName() \"\nWRITER__UITEXT_GetOutputFolderEquals:    \"^/_getOutputFolder() \"\nWRITER__UITEXT_ErrorHeader:              \"^/^/--- CodeWriter Error Description Start ---^/^/\"\nWRITER__UITEXT_ErrorFooter:              \"^/--- CodeWriter Error Description End -----^/^/\"\nWRITER__UITEXT_UnableToLoadMetaProps:    \"Unable to load metadata from file: \"\nWRITER__UITEXT_PlaceHolderException:     \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\"\n\n; String constants\nWRITER__STRING_empty:                    \"\"\nWRITER__STRING_dot:                      \".\"\nWRITER__STRING_separator:                \"$<\\jostraca.system.fileSeparator>\"\n\n; Constants >> ;\n\n\n\n\n; Writer Variables << ;\n\nwriter__iFileNameRoots:      []                   ; generated file name roots\nwriter__iNumFiles:           0                    ; number of generated files\n  \nwriter__iFileNamePrefix:     WRITER__STRING_empty ; failsafe default\nwriter__iFileNameSuffix:     WRITER__STRING_empty ; failsafe default\n\nwriter__iBackupPrefix:       WRITER__STRING_empty ; failsafe default\nwriter__iBackupSuffix:       WRITER__STRING_empty ; failsafe default\n\nwriter__iCurrentText:        WRITER__STRING_empty ; current text\nwriter__iCurrentFileIndex:   0                    ; current file index\n\nwriter__iArgs:               []                   ; cmd line args\nwriter__iNumArgs:            0                    ; number of cmd line args\n\nwriter__iSave:               true                 ; save generated code to disk\nwriter__iBackup:             true                 ; make backups\n\nwriter__iOutputFolder:       WRITER__STRING_dot   ; written code is output to this folder\nwriter__iBackupFolder:       WRITER__STRING_dot   ; overwritten files are placed here\nwriter__iMetaPropFile:       WRITER__STRING_empty ; metadata properties file path\n\nwriter__iProperties:         []                   ; lookup table for compile time properties\nwriter__iPropertiesInit:     false                ; true => lookup table initialiased\n\n; Writer Variables >> ;\n\n\n\n\n!<{declare>; section:declare\n!<declare>!<}declare>\n\n\n\n\n; Template Services (File Generation) << ;\n\n; Set the prefix of the files to be generated. \n_setFileNamePrefix: func [ pPrefix ] [\n   writer__iFileNamePrefix: pPrefix\n]\n\n\n\n; Get prefix of files to be generated.\n_getFileNamePrefix: func [][\n  writer__iFileNamePrefix\n]\n\n\n\n; Set the suffix of the files to be generated. \n_setFileNameSuffix: func [ pSuffix ] [\n  writer__iFileNameSuffix: pSuffix\n]\n\n\n\n; Get suffix of files to be generated.\n_getFileNameSuffix: func[] [\n  writer__iFileNameSuffix\n]\n\n\n\n; Set the full name of the file to be generated. \n; Prefix and Suffix are set to empty.\n_setFullFileName: func [ pName ] [\n  _setFileNamePrefix  WRITER__STRING_empty\n  _setFileNameRoot    pName\n  _setFileNameSuffix  WRITER__STRING_empty\n]\n\n\n\n; Get the full name of current file being generated.\n_getFullFileName: func[] [\n   rejoin reduce [ _getFileNamePrefix _getFileNameRoot _getFileNameSuffix ]\n]\n\n\n\n; Set the names of the files to be generated. \n; Prefix and Suffix are set to empty.\n_setFullFileNames: func [ pNames ] [\n  _setFileNamePrefix WRITER__STRING_empty\n  _setFileNameRoots  pNames\n  _setFileNameSuffix WRITER__STRING_empty\n]\n\n\n\n; Get the full names of the files to be generated.\n_getFullFileNames: func [ /local fileNameRoot fileNameRoots fullFileNames fileNamePrefix fileNameSuffix ] [\n\n  fileNameRoots:  _getFileNameRoots\n  fullFileNames:  copy []\n  fileNamePrefix: _getFileNamePrefix\n  fileNameSuffix: _getFileNameSuffix\n\n  foreach fileNameRoot fileNameRoots [\n    append fullFileNames   rejoin reduce [ fileNamePrefix fileNameRoot fileNameSuffix ]\n  ]\n\n  fullFileNames\n]\n\n\n\n; Set the root of the name of the file to be generated. \n_setFileNameRoot: func [ pFileNameRoot ] [\n  _setFileNameRoots reduce [ pFileNameRoot ]\n]\n\n\n\n; Get the root of the name of current file being generated.\n_getFileNameRoot: func [] [\n   pick writer__iFileNameRoots ( writer__iCurrentFileIndex + 1 )\n]\n\n\n\n; Get roots of the names of files to be generated.\n_getFileNameRoots: func [] [\n  head writer__iFileNameRoots\n]\n\n\n\n; Set the roots of the names of the files to be generated. \n_setFileNameRoots: func [ pFileNameRoots ] [\n  writer__iFileNameRoots: pFileNameRoots\n  writer__iNumFiles:      length? writer__iFileNameRoots\n]\n\n\n\n; Get index of file currently being generated. \n_getFileIndex: func[] [\n  writer__iCurrentFileIndex\n]\n\n\n\n; Get number of files to generate.\n_getNumFiles: func [] [\n  writer__iNumFiles\n]\n\n\n\n; Set output folder.\n_setOutputFolder: func [ pFolder ] [\n  writer__iOutputFolder: pFolder\n]\n\n\n\n; Get output folder.\n_getOutputFolder: func [] [\n  writer__iOutputFolder\n]\n\n\n\n; Set backup folder.\n_setBackupFolder: func [ pBackupFolder ] [\n  writer__iBackupFolder: pBackupFolder\n]\n\n\n\n; Get backup folder.\n_getBackupFolder: func[] [\n  writer__iBackupFolder\n]\n\n\n\n; Set the prefix of backup files.\n_setBackupPrefix: func [ pBackupPrefix ] [\n  writer__iBackupPrefix: pBackupPrefix\n]\n\n\n\n; Set the suffix of backup files.\n_setBackupSuffix: func [ pBackupSuffix ] [\n  writer__iBackupSuffix: pBackupSuffix\n]\n\n\n\n; Set to true if generated files are to be backed up to disk automatically.\n_backup: func [ pBackup ] [\n  writer__iBackup: pBackup\n]\n\n\n\n; Set to true if generated files are to be saved to disk automatically. \n_save: func [ pSave ] [\n  writer__iSave: pSave\n]\n\n\n\n; Save a text file.\n_saveTextFile: func [ pFilePath pContent ] [\n  write  make file! pFilePath pContent\n  true\n]\n\n\n\n; Load a text file.\n_loadTextFile: func [ pFilePath /local content ] [\n  content: read make file! pFilePath\n  content\n]\n\n; Template Services (File Generation) >> ;\n\n\n\n\n; Template Services (Control) << ;\n\n; Get the value of a compile-time property.\n_getProperty: func [ pName ] [\n  if not writer__iPropertiesInit [\n    writer__initProperties\n  ]\n\n  select writer__iProperties pName\n]\n\n\n\n; Get first user arg.\n_getFirstUserArg: func [] [\n   _getUserArg 0\n]\n\n\n\n; Get second user arg.\n_getSecondUserArg: func [] [\n  _getUserArg 1\n]\n\n\n\n; Get third user arg.\n_getThirdUserArg: func [] [\n  _getUserArg 2\n]\n\n\n\n; Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX).\n_getUserArg: func [ pOrdinal /local userArgs ] [\n  either pOrdinal < _getNumUserArgs [\n    userArgs: _getUserArgs\n    pick userArgs ( pOrdinal + 1 )\n  ][\n    WRITER__STRING_empty\n  ]\n]\n\n\n\n; Get user command line arguments to CodeWriter. \n_getUserArgs: func [] [\n  writer__iUserArgs\n]\n\n\n\n; Get number of user command line arguments to CodeWriter.\n_getNumUserArgs: func [] [\n  writer__iNumUserArgs\n]\n\n\n\n; Get command line arguments to CodeWriter. \n_getArgs: func [] [\n  writer__iArgs\n]\n\n\n\n; Get number of command line arguments to CodeWriter.\n_getNumArgs: func [] [\n  writer__iNumArgs;\n]\n\n; Template Services (Control) >> ;\n\n\n\n\n; Template Services (Text Production) << #\n\n; Insert text into generated file.\n_insert: func [ pText ] [\n  writer__iCurrentText:  rejoin [ writer__iCurrentText pText ]\n]\n\n\n\n; Create a String containing specified number of spaces.\n_spaces: func [ pNumSpaces ] [\n  numSpaces: either pNumSpaces < 0 [ -1 * pNumSpaces][ pNumSpaces ]\n  spaces:    copy WRITER__STRING_empty\n  while [ numSpaces > 0 ] [\n    spaces:    rejoin [ spaces \" \" ]\n    numSpaces: numSpaces - 1\n  ]\n  spaces\n]\n\n\n\n; Left align String with spaces. \n_left: func [ pText pColWidth ] [\n  _align pText \" \" pColWidth \"l\"\n] \n\n\n\n; Right align String with spaces. \n_right: func [ pText pColWidth ] [\n  _align pText \" \" pColWidth \"r\"\n] \n\n\n; Center align String with spaces. \n_center: func [ pText pColWidth ] [\n  _align pText \" \" pColWidth \"c\"\n] \n\n\n\n; Align text within background text with specified column width.\n; Alignment can be 'l': left, 'c': center, 'r': right\n_align: func[ pText pBackText pColWidth pAlignment /local result \n                                                          textLen \n                                                          backTextLen\n                                                          remainWidth\n                                                          backTextRepeats\n                                                          backTextRemain\n                                                          back\n                                                          backTextI ] [\n\n  result: pText\n  \n  if error? e: try [\n    textLen: length? pText\n    if pColWidth > textLen [\n      backTextLen:     length? pBackText\n      remainWidth:     pColWidth - textLen\n      backTextRepeats: make integer! remainWidth / backTextLen\n      backTextRemain:  remainWidth // backTextLen\n      back:            WRITER__STRING_empty\n      backTextI:       0\n      while [ backTextI < backTextRepeats ] [\n        back:      rejoin [ back pBackText ]\n        backTextI: backTextI + 1\n      ]\n      if 0 < backTextRemain [\n        back: rejoin [ back copy/part pBackText backTextRemain ]\n      ]\n\n      if \"l\" = pAlignment [\n        result: rejoin [ result back ]\n      ]\n      if \"c\" = pAlignment [\n        result: rejoin [ copy/part back (make integer! divide length? back 2)  result  at back (1 + make integer! divide length? back 2) ]\n      ]\n      if \"r\" = pAlignment [\n        result: rejoin [ back result ]\n      ]\n    ]\n    true\n  ][\n    result: pText\n  ]\n\n  result\n]\n\n\n\n; Get text of file currently being generated.\n_getText: func [] [\n  writer__iCurrentText\n]\n\n\n\n; Set text of file currently being generated.\n_setText: func [ pText ] [\n  writer__iCurrentText: pText\n]\n\n\n; Set build properties file.\n_setMetaPropFile: func [ pMetaPropFile ] [\n  writer__iMetaPropFile:   pMetaPropFile\n  writer__iPropertiesInit: $<lang.FalseString>\n]\n\n\n; Get build properties file.\n_getMetaPropFile: func [] [\n  writer__iMetaPropFile\n]\n\n\n\n; Template Services (Text Production) >> ;\n\n\n\n\n; Writer Services <<\n\n; Initialize.\nwriter__initialize: func [] [\n  writer__iCurrentFileIndex: 0\n  writer__setDefaults\n]\n\n\n\n; Main file generation loop. Template script is placed here in the body section.\nwriter__write: func [ /local writer__fileNameRoots \n                             writer__numFiles \n                             writer__fileI \n                             writer__currentSection \n                    ] [\n\n  ; initialize\n  writer__currentSection: \"init\"\n\n\n  if error? e: try [\n\n    !<{init>; section:init\n    !<init>!<}init> \n\n\n    ; write files loop\n    writer__numFiles:      _getNumFiles\n    writer__fileI:         0\n    writer__fileNameRoots: _getFileNameRoots\n\n    forall writer__fileNameRoots [\n\n      if error? e: try [\n\n        !<{prewrite>; section:prewrite\n        writer__currentSection: \"prewrite\"\n        !<prewrite>!<}prewrite> \n\n\n        if writer__startFile [\n\n          !<{body>; section:body\n          writer__currentSection: \"body\"\n          !<body>!<}body> \n\n\n          if writer__endFile [ \n\n\n            !<{postwrite>; section:postwrite\n            writer__currentSection: \"postwrite\"\n            !<postwrite>!<}postwrite> \n\n          ] ; writer__endFile\n        ] ; writer__startFile\n\n        true\n      ][\n        writer__handleException  rejoin [ WRITER__UITEXT_ExceptionIn WRITER__UITEXT_Section writer__currentSection ]  disarm e      \n      ]\n\n      writer__nextFile\n    ]\n \n\n    !<{cleanup>; section:cleanup\n    writer__currentSection: \"cleanup\"\n    !<cleanup>!<}cleanup> \n\n    true\n  ][\n    writer__handleException rejoin [ WRITER__UITEXT_ExceptionIn WRITER__UITEXT_Section writer__currentSection ]  disarm e\n  ]\n]\n\n\n\n; Start writing a file.\nwriter__startFile: func [] [\n  writer__iCurrentText: WRITER__STRING_empty\n  true\n]\n\n\n\n; End writing a file.\nwriter__endFile: func [ /local endOK fileName filePath ] [\n  endOK: true\n\n  fileName: _getFullFileName\n  filePath: rejoin [ writer__iOutputFolder\n                     WRITER__STRING_separator\n                     fileName ]\n\n  if writer__iBackup [\n    if error? e: try [\n      writer__backup  filePath fileName writer__iBackupFolder\n      true\n    ][\n      writer__handleException  rejoin [ WRITER__UITEXT_UnableToBackupFile \n                                        filePath \n                                        WRITER__UITEXT_ToBackupFolder\n                                        writer__iBackupFolder ]\n                               disarm e\n      endOK: false\n    ]\n   ]\n \n  if all [ endOK writer__iSave ] [\n    either error? e: try [\n      _saveTextFile filePath writer__iCurrentText\n    ][\n      writer__handleException  rejoin [WRITER__UITEXT_UnableToSaveFile filePath ]  disarm e\n      endOK: false\n    ][\n      writer__userMessage  rejoin [ WRITER__UITEXT_SavedFile filePath WRITER__UITEXT_NewLine ] false\n    ]\n  ]\n\n  endOK\n]\n\n\n\n; Move to next file\nwriter__nextFile: func [] [\n  writer__iCurrentFileIndex: writer__iCurrentFileIndex + 1\n]\n\n\n\n; Handle command line arguments to CodeWriter.\nwriter__handleArgs: func[ pArgs /local argName_OutputFolder\n                                       argName_MetaPropFile\n                                       argName_BackupFolder\n                                       argName_NoBackup \n                                       args ] [\n\n  ; set arg names\n  argName_OutputFolder: rejoin [ WRITER__ARGUMENT_CONTROL_PREFIX WRITER__ARGUMENT_OutputFolder ]\n  argName_MetaPropFile: rejoin [ WRITER__ARGUMENT_CONTROL_PREFIX WRITER__ARGUMENT_MetaPropFile ]\n  argName_BackupFolder: rejoin [ WRITER__ARGUMENT_CONTROL_PREFIX WRITER__ARGUMENT_BackupFolder ]\n  argName_NoBackup:     rejoin [ WRITER__ARGUMENT_CONTROL_PREFIX WRITER__ARGUMENT_NoBackup     ]\n\n  ; parse args\n  ; ...\n\n  foreach arg pArgs [\n    if find/match arg argName_OutputFolder [\n      _setOutputFolder  find/match arg argName_OutputFolder\n    ]\n    if find/match arg argName_MetaPropFile [\n      _setMetaPropFile  find/match arg argName_MetaPropFile\n    ]\n    if find/match arg argName_BackupFolder [\n      _setBackupFolder  find/match arg argName_BackupFolder\n    ]\n    if argName_NoBackup = arg [\n      _backup $<lang.FalseString> ;; NOTE: -B => don't make backups\n    ]\n  ]\n\n  writer__initArgs  make integer! length? pArgs  pArgs\n]\n\n\n\n; Set defaults from configuration property set.\nwriter__setDefaults: func [] [\n\n  $<{main.FileNameRoot>_setFileNameRoot \"$<\\main.FileNameRoot>\" $<}main.FileNameRoot>\n  $<{main.FileNamePrefix>_setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n  $<{main.FileNameSuffix>_setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n  $<{main.OutputFolder>_setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n  $<{main.BackupFolder>_setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n  $<{main.BackupPrefix>_setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n  $<{main.BackupSuffix>_setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n  _backup( \"$<lang.TrueString>\" = \"$<jostraca.MakeBackup>\" );\n\n]\n\n\n\n; Initialize command line arguments.\nwriter__initArgs: func [ pNumArgs pArgs /local argI userArgI ] [\n  argI:     0\n  userArgI: 0\n\n  writer__iNumArgs:     0 + pNumArgs\n  writer__iArgs:        pArgs\n  writer__iNumUserArgs: writer__iNumArgs\n\n  argI: 1\n  while [ argI <= writer__iNumArgs ] [\n    if find/match  make string! at writer__iArgs argI  WRITER__ARGUMENT_CONTROL_PREFIX [\n      writer__iNumUserArgs: writer__iNumUserArgs - 1\n    ]\n    argI: argI + 1\n  ]\n\n  writer__iUserArgs: copy []\n\n  argI: 1\n  while [ argI <= writer__iNumArgs ] [\n    if not find/match  make string! at writer__iArgs argI  WRITER__ARGUMENT_CONTROL_PREFIX [\n      append writer__iUserArgs pick writer__iArgs argI\n      userArgI: userArgI + 1\n    ]\n    argI: argI + 1\n  ]\n]\n\n\n\n; Print a user readable message.\nwriter__userMessage: func [ pMessage pError ] [\n  if pError [\n    ; output to stderr not supported\n    print rejoin [ \"ERROR: \" pMessage ]\n  ][\n  print pMessage\n  ]\n]\n\n\n\n; Handle exceptions: print an explanation for user.\nwriter__handleException: func [ pMessage pException /local userMsg ] [\n\n  userMsg: rejoin [ WRITER__UITEXT_ErrorHeader\n                    writer__describeState \n                    pMessage \n                    WRITER__UITEXT_ColonNewLine\n                    probe pException\n                    WRITER__UITEXT_ErrorFooter ]\n\n  writer__userMessage userMsg true \n]\n\n\n\n; Provide a concise description of the state of the CodeWriter.\nwriter__describeState: func [ /local currentState ] [\n  currentState: rejoin [ \n    WRITER__UITEXT_CodeWriterState\n    WRITER__UITEXT_GetFileIndexEquals    _getFileIndex\n    WRITER__UITEXT_GetFullFileNameEquals _getFullFileName\n    WRITER__UITEXT_GetOutputFolderEquals _getOutputFolder\n    WRITER__UITEXT_NewLine\n  ] \n  currentState\n]\n\n\n\n; Backup overwritten files, if they exist.\n; Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\nwriter__backup: func[ pFilePath pFileName pBackupFolder /local backupFolder\n                                                               dateTime\n                                                               backupFileName\n                                                               backupFilePath \n                                                               dateTimeNow\n                                                               year_yyyy\n                                                               month_mm \n                                                               day_dd   \n                                                               hour_hh  \n                                                               minute_mm\n                                                               second_ss\n\n] [\n\n  backupFolder: make file! pBackupFolder\n\n  ; check backup folder ( create if necessary )\n  if not exists? backupFolder [\n    if error? e: try [    \n      make-dir backupFolder\n      true\n    ][\n      make error!  rejoin [ WRITER__UITEXT_BackupFolderColon\n                            backupFolder\n                            WRITER__UITEXT_BackupFolderExistFailure ]\n    ]\n  ]\n\n  if not dir? backupFolder [\n    make error! rejoin [ WRITER__UITEXT_BackupFolderColon \n                         backupFolder\n                         WRITER__UITEXT_BackupFolderNotAFolder ]\n  ]\n\n;  don't know how to check if folder is writable\n;  if( !( -w $backupFolder ) ) {\n;    die( $WRITER__UITEXT_BackupFolderColon\n;         . $backupFolder\n;         . $WRITER__UITEXT_BackupFolderNotWritable );\n;  }\n\n\n  ; create backup file path\n  dateTimeNow: now\n  year_yyyy: _align make string! dateTimeNow/year     \"0\" 4 \"r\"\n  month_mm:  _align make string! dateTimeNow/month    \"0\" 2 \"r\"\n  day_dd:    _align make string! dateTimeNow/day      \"0\" 2 \"r\"\n  hour_hh:   _align make string! dateTimeNow/time/1   \"0\" 2 \"r\"\n  minute_mm: _align make string! dateTimeNow/time/2   \"0\" 2 \"r\"\n  second_ss: _align make string! dateTimeNow/time/3   \"0\" 2 \"r\"\n  dateTime:  rejoin [ year_yyyy month_mm day_dd hour_hh minute_mm second_ss ]\n  backupFileName: rejoin [ dateTime writer__iBackupPrefix pFileName writer__iBackupSuffix ]\n  backupFilePath: rejoin [ pBackupFolder WRITER__STRING_separator backupFileName ]\n\n  ; save backup file\n  if exists? make file! pFilePath [\n    _saveTextFile backupFilePath  read make file! pFilePath\n  ]\n]\n\n\n\n; set compile time properties\nwriter__initProperties: func [ /local metaPropFile content lines line nv n v ] [\n  metaPropFile: _getMetaPropFile()\n\n  if not \"\" == metaPropFile [\n      writer__iProperties: make hash! []\n\n      if error? e: try [\n\n        content: _loadTextFile( metaPropFile )\n        replace/all content rejoin[ \"\\\" newline ] \"\"\n\n        lines: parse/all content rejoin [ newline ]\n        foreach line lines [\n          nv: parse/all line \"=:\"\n          n:  rejoin [ pick nv 1 ]\n          v:  rejoin [ pick nv 2 ]\n          if not \"#\" == first n [\n            insert writer__iProperties reduce [ trim n trim v ]\n          ] \n        ]\n\n        writer__iPropertiesInit: $<lang.TrueString>\n\n      ][\n        writer__handleException  rejoin [ WRITER__UITEXT_UnableToLoadMetaProps _getMetaPropFile ]  disarm e      \n      ]\n   ]\n]\n\n; Writer Services >> ;\n\n\n\n\n; Execute.\nmain: func [ pArgs /local e ] [\n\n  if error? e: try [\n    writer__initialize\n    writer__handleArgs pArgs\n    writer__write\n  ][\n    writer__handleException  rejoin [ WRITER__UITEXT_ExceptionIn WRITER__UITEXT_Method WRITER__UITEXT_Main ]  disarm e      \n  ]\n]\n\n\n\n; Start execution\nmain system/options/args\n\n\n!<footer>\n\n");
    }

    private static final void makeWF_BasicJythonWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicJythonWriterFormat.jwf", "!<header>\n\nimport os\nimport os.path\nimport sys\nimport time\nimport string\nimport traceback\nimport re\n\n\n\n!<{import># section:import\n!<import>!<}import>\n\n\nclass $<main.CodeWriter>$<{python.CodeWriter.extends>($<python.CodeWriter.extends>)$<}python.CodeWriter.extends>:\n\n\n  def __init__(self):\n\n    # Constants << #\n   \n    # Command line arguments\n    self.WRITER__ARGUMENT_CONTROL_PREFIX         = \"$<main.CodeWriter.argument.ControlPrefix>\"\n    self.WRITER__ARGUMENT_OutputFolder           = \"$<main.CodeWriter.argument.name.OutputFolder>\"\n    self.WRITER__ARGUMENT_MetaPropFile           = \"$<main.CodeWriter.argument.name.MetaPropFile>\"\n    self.WRITER__ARGUMENT_BackupFolder           = \"$<main.CodeWriter.argument.name.BackupFolder>\"\n    self.WRITER__ARGUMENT_NoBackup               = \"$<main.CodeWriter.argument.name.NoBackup>\"\n  \n    # User Interface text message parts\n    self.WRITER__UITEXT_Method                   = \"method \"\n    self.WRITER__UITEXT_Main                     = \"main \"\n    self.WRITER__UITEXT_ExceptionIn              = \"Exception in \"\n    self.WRITER__UITEXT_ColonNewLine             = \":\\n\"\n    self.WRITER__UITEXT_NewLine                  = \"\\n\"\n    self.WRITER__UITEXT_Section                  = \"section \"\n    self.WRITER__UITEXT_SavedFile                = \"Saved file:       \"\n    self.WRITER__UITEXT_UnableToSaveFile         = \"Unable to save file: \"\n    self.WRITER__UITEXT_UnableToBackupFile       = \"Unable to backup file: \"\n    self.WRITER__UITEXT_ToBackupFolder           = \" to backup folder: \"\n    self.WRITER__UITEXT_BackupFolderColon        = \"Backup folder: \"\n    self.WRITER__UITEXT_BackupFolderExistFailure = \" does not exist and cannot be created.\"\n    self.WRITER__UITEXT_BackupFolderNotAFolder   = \" is not a folder.\"\n    self.WRITER__UITEXT_BackupFolderNotWritable  = \" is not writable.\"\n    self.WRITER__UITEXT_CodeWriterState          = \"Code Writer State: \"\n    self.WRITER__UITEXT_GetFileIndexEquals       = \"\\n_getFileIndex()    = \";\n    self.WRITER__UITEXT_GetFullFileNameEquals    = \"\\n_getFullFileName() = \";\n    self.WRITER__UITEXT_GetOutputFolderEquals    = \"\\n_getOutputFolder() = \";\n    self.WRITER__UITEXT_ErrorHeader              = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\"\n    self.WRITER__UITEXT_ErrorFooter              = \"\\n--- CodeWriter Error Description End -----\\n\\n\"\n    self.WRITER__UITEXT_UnableToLoadMetaProps    = \"Unable to load metadata from file: \"\n    self.WRITER__UITEXT_PlaceHolderException     = \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\"\n  \n    # String constants\n    self.WRITER__STRING_empty                    = \"\"\n    self.WRITER__STRING_dot                      = \".\"\n    self.WRITER__STRING_separator                = \"$<\\jostraca.system.fileSeparator>\"\n  \n    # Constants >> #\n  \n  \n  \n  \n    # Writer Variables << #\n  \n    self.writer__iFileNameRoots         = [   self.WRITER__STRING_empty ]   # generated file name roots\n    self.writer__iNumFiles              = 0                                 # number of generated files\n    \n    self.writer__iFileNamePrefix        =   self.WRITER__STRING_empty       # failsafe default\n    self.writer__iFileNameSuffix        =   self.WRITER__STRING_empty       # failsafe default\n  \n    self.writer__iBackupPrefix          =   self.WRITER__STRING_empty       # failsafe default\n    self.writer__iBackupSuffix          =   self.WRITER__STRING_empty       # failsafe default\n  \n    self.writer__iCurrentText           =   self.WRITER__STRING_empty       # current text\n    self.writer__iCurrentFileIndex      = 0                                 # current file index\n  \n    self.writer__iArgs                  = []                                # cmd line args\n    self.writer__iNumArgs               = 0                                 # number of cmd line args\n    self.writer__iUserArgs              = []                                # user cmd line args\n    self.writer__iNumUserArgs           = 0                                 # number of user cmd line args\n  \n    self.writer__iSave                  = 1                                 # save generated code to disk\n    self.writer__iBackup                = 1                                 # make backups\n  \n    self.writer__iOutputFolder          = self.WRITER__STRING_dot           # written code is output to this folder\n    self.writer__iBackupFolder          = self.WRITER__STRING_dot           # overwritten files are placed here\n    self.writer__iMetaPropFile          = self.WRITER__STRING_empty;        # metadata properties file path\n\n    self.writer__iProperties            = {}                                # lookup table for compile time properties\n    self.writer__iPropertiesInit        = $<lang.FalseString>               # true => lookup table initialiased\n\n    self.writer__iContext               = ''                                # context object\n    self.writer__iResult                = ''                                # result object\n\n  \n    # Writer Variables >> #\n\n\n\n  !<{declare># section:declare\n  !<declare>!<}declare>\n\n\n\n  # Execute.\n  def main( self, pArgs ) :\n    try :\n      self.writer__initialize()\n      self.writer__handleArgs( pArgs )\n      self.writer__write()\n  \n      if \"\" == self._getResult():\n         self._setResult( self._getText() )\n\n    except Exception :\n      self.writer__handleException( self.WRITER__UITEXT_ExceptionIn + self.WRITER__UITEXT_Method + self.WRITER__UITEXT_Main )\n  \n\n\n\n  # Writer Services << #\n  \n  # Initialize.\n  def writer__initialize( self ) :\n    self.writer__iCurrentFileIndex = 0\n    self.writer__setDefaults()\n  \n  \n  \n  # Main file generation loop. Template script is placed here in the body section.\n  def writer__write( self ) :\n    \n    # initialize\n    self.writer__currentSection = \"init\"\n    \n    \n    try :\n     \n      !<{init># section:init\n      self.writer__currentSection = \"init\"\n      !<init>!<}init>\n      pass\n  \n     \n      # write files loop  \n      self.writer__numFiles = self._getNumFiles()\n      self.writer__fileI    = 0\n      for self.writer__fileI in range( self.writer__numFiles ) :\n    \n        try :\n     \n          !<{prewrite># section:prewrite\n          self.writer__currentSection = \"prewrite\"\n          !<prewrite>!<}prewrite> \n          pass\n  \n     \n          ok = self.writer__startFile()\n          if ok :     \n     \n            !<{body># section:body\n            self.writer__currentSection = \"body\"\n            !<body>!<}body> \n            pass\n  \n     \n            ok = self.writer__endFile()\n            if ok :     \n  \n              !<{postwrite># section:postwrite\n              self.writer__currentSection = \"postwrite\"\n              !<postwrite>!<}postwrite> \n              pass\n  \n   \n        except Exception :\n          self.writer__handleException( self.WRITER__UITEXT_ExceptionIn + self.WRITER__UITEXT_Section + self.writer__currentSection )\n   \n   \n        self.writer__nextFile()\n   \n   \n      !<{cleanup># section:cleanup\n      self.writer__currentSection = \"cleanup\"\n      !<cleanup>!<}cleanup>\n      pass \n    \n    except Exception :\n      self.writer__handleException( self.WRITER__UITEXT_ExceptionIn + self.WRITER__UITEXT_Section + self.writer__currentSection )\n  \n  \n  \n  # Start writing a file.\n  def writer__startFile( self ) :\n    self.writer__iCurrentText = self.WRITER__STRING_empty\n    return 1\n  \n  \n  \n  # End writing a file.\n  def writer__endFile( self ) :\n    endOK = 1\n  \n    fileName = self._getFullFileName() \n    filePath = self.writer__iOutputFolder + self.WRITER__STRING_separator + fileName\n  \n    if self.writer__iBackup :\n      try :\n        self.writer__backup( filePath, fileName, self.writer__iBackupFolder )\n  \n      except Exception, e :\n        self.writer__handleException( self.WRITER__UITEXT_UnableToBackupFile + filePath + self.WRITER__UITEXT_ToBackupFolder + self.writer__iBackupFolder )\n        endOK = 0\n  \n   \n    if endOK and self.writer__iSave :\n      try :\n        self._saveTextFile( filePath, self.writer__iCurrentText )\n        self.writer__userMessage( self.WRITER__UITEXT_SavedFile + filePath, $<lang.FalseString> ) # CP! + self.WRITER__UITEXT_NewLine )\n  \n      except Exception :\n        self.writer__handleException( self.WRITER__UITEXT_UnableToSaveFile + filePath )\n        endOK = 0\n  \n    return endOK\n    \n  \n  \n  # Move to next file\n  def writer__nextFile( self ) :\n    self.writer__iCurrentFileIndex = self.writer__iCurrentFileIndex + 1\n  \n  \n  \n  # Handle command line arguments to CodeWriter.\n  def writer__handleArgs( self, pArgs ) :\n  \n    # set arg names\n    argName_OutputFolder           = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_OutputFolder\n    argName_MetaPropFile           = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_MetaPropFile\n    argName_BackupFolder           = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_BackupFolder\n    argName_NoBackup               = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_NoBackup\n  \n    # parse args\n    # ...\n  \n    numArgs = len( pArgs )\n    for argI in range( numArgs ) :\n      if   0 == string.find( pArgs[ argI ], argName_OutputFolder ) :\n        self._setOutputFolder( pArgs[ argI ][len(argName_OutputFolder):] )\n      \n      elif 0 == string.find( pArgs[ argI ], argName_MetaPropFile ) :\n        self._setMetaPropFile( pArgs[ argI ][len(argName_MetaPropFile):] )\n\n      elif 0 == string.find( pArgs[ argI ], argName_BackupFolder ) :\n        self._setBackupFolder( pArgs[ argI ][len(argName_BackupFolder):] )\n  \n      elif argName_NoBackup == pArgs[ argI ]  :\n        self._backup( $<lang.FalseString> ) ## NOTE: -B => don't make backups\n      \n    self.writer__initArgs( len( pArgs ), pArgs )\n  \n  \n  \n  # Set def aults from configuration property set.\n  def writer__setDefaults( self ) :\n  \n    $<{main.FileNameRoot>self._setFileNameRoot( \"$<\\main.FileNameRoot>\" )$<}main.FileNameRoot>\n    $<{main.FileNamePrefix>self._setFileNamePrefix( \"$<\\main.FileNamePrefix>\" )$<}main.FileNamePrefix>\n    $<{main.FileNameSuffix>self._setFileNameSuffix( \"$<\\main.FileNameSuffix>\" )$<}main.FileNameSufffix>\n  \n    $<{main.OutputFolder>self._setOutputFolder( \"$<\\main.OutputFolder>\" )$<}main.OutputFolder>\n  \n    $<{main.BackupFolder>self._setBackupFolder( \"$<\\main.BackupFolder>\" )$<}main.BackupFolder>\n    $<{main.BackupPrefix>self._setBackupPrefix( \"$<\\main.BackupPrefix>\" )$<}main.BackupPrefix>\n    $<{main.BackupSuffix>self._setBackupSuffix( \"$<\\main.BackupSuffix>\" )$<}main.BackupSufffix>\n    self._backup( \"$<lang.TrueString>\" == \"$<jostraca.MakeBackup>\" )\n  \n    pass\n  \n  \n  \n  # Initialize command line arguments.\n  def writer__initArgs( self, pNumArgs, pArgs ) :\n    argI     = 0\n    userArgI = 0\n  \n    self.writer__iNumArgs     = pNumArgs\n    self.writer__iArgs        = pArgs\n    self.writer__iNumUserArgs = self.writer__iNumArgs - 1 # script name is arg 0\n  \n    for argI in range( 1, self.writer__iNumArgs ) :\n      if 0 == string.find( self.writer__iArgs[ argI ], self.WRITER__ARGUMENT_CONTROL_PREFIX ) : \n        self.writer__iNumUserArgs = self.writer__iNumUserArgs - 1\n      \n    for argI in range( 1, self.writer__iNumArgs ) :\n      if 0 == string.find( self.writer__iArgs[ argI ], self.WRITER__ARGUMENT_CONTROL_PREFIX ) : \n        continue\n      else :\n        self.writer__iUserArgs.append( self.writer__iArgs[ argI ] )\n        userArgI = userArgI + 1;\n  \n  \n  \n  # Print a user readable message.\n  def writer__userMessage( self, pMessage, pError ) :\n    if pError :\n      print >> sys.stderr, pMessage\n    else :\n      print pMessage\n  \n  \n  \n  # Handle exceptions: print an explanation for user.\n  def writer__handleException( self, pMessage ) :\n    userMsg = self.WRITER__UITEXT_ErrorHeader\n  \n    userMsg = userMsg + self.writer__describeState() + pMessage + self.WRITER__UITEXT_ColonNewLine\n    userMsg = userMsg + string.join(traceback.format_exception( sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2] ))\n    userMsg = userMsg + self.WRITER__UITEXT_ErrorFooter\n  \n    self.writer__userMessage( userMsg, $<lang.TrueString> )\n  \n  \n  \n  # Provide a concise description of the state of the CodeWriter.\n  def writer__describeState( self ) :\n    currentState = self.WRITER__STRING_empty +                                \\\n        self.WRITER__UITEXT_CodeWriterState                                   \\\n      + self.WRITER__UITEXT_GetFileIndexEquals    + str( self._getFileIndex() )    \\\n      + self.WRITER__UITEXT_GetFullFileNameEquals + self._getFullFileName()        \\\n      + self.WRITER__UITEXT_GetOutputFolderEquals + self._getOutputFolder()        \\\n      + self.WRITER__UITEXT_NewLine\n    return currentState\n  \n  \n  \n  # Backup overwritten files, if they exist.\n  # Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n  def writer__backup( self, pFilePath, pFileName, pBackupFolder ) :\n  \n    backupFolder = pBackupFolder\n  \n    # check backup folder ( create if necessary )\n    if not os.path.exists( backupFolder ) :\n      if not os.mkdir( backupFolder, 0700 ) :\n        raise Exception, self.WRITER__UITEXT_BackupFolderColon          \\\n                         + backupFolder                            \\\n                         + self.WRITER__UITEXT_BackupFolderExistFailure\n    if not os.path.isdir( backupFolder ) :\n      raise Exception, self.WRITER__UITEXT_BackupFolderColon        \\\n                       + backupFolder                          \\\n                       + self.WRITER__UITEXT_BackupFolderNotAFolder\n\n    #if not os.access( backupFolder, os.W_OK ) :\n    #  raise Exception, self.WRITER__UITEXT_BackupFolderColon         \\\n    #                   + backupFolder                           \\\n    #                   + self.WRITER__UITEXT_BackupFolderNotWritable\n  \n  \n    # create backup file path\n    calendar = time.localtime( time.time() )\n    year_yyyy    = self._align( str(calendar[0]), \"0\", 4, 'r' )\n    month_mm     = self._align( str(calendar[1]), \"0\", 2, 'r' )\n    day_dd       = self._align( str(calendar[2]), \"0\", 2, 'r' )\n    hour_hh      = self._align( str(calendar[3]), \"0\", 2, 'r' )\n    minute_mm    = self._align( str(calendar[4]), \"0\", 2, 'r' )\n    second_ss    = self._align( str(calendar[5]), \"0\", 2, 'r' )\n    dateTime = year_yyyy+month_mm+day_dd+hour_hh+month_mm+second_ss\n    backupFileName = dateTime + self.writer__iBackupPrefix + pFileName + self.writer__iBackupSuffix\n    backupFilePath = pBackupFolder + self.WRITER__STRING_separator + backupFileName\n    \n    # save backup file\n    if os.path.exists( pFilePath ) :\n      fileContents = self._loadTextFile( pFilePath )\n      self._saveTextFile( backupFilePath, fileContents )\n  \n  \n  \n  # Set compile time properties\n  def writer__initProperties( self ) :\n    metaPropFile = self._getMetaPropFile()\n\n    if not \"\" == metaPropFile:\n      self.writer__iProperties = {}    \n\n      try:\n        content = self._loadTextFile( metaPropFile );\n\n        content = content.replace(\"\\r\\n\",\"\\n\");\n        content = content.replace(\"\\r\",\"\\n\");\n\n        for (name,value,index) in re.findall( '\\n\\s*(.*?)\\s*[=:]\\s*((\\\\\\s*\\n|.)*)', content ):\n          if not name.startswith('#'): \n            value = value.strip()\n            value = re.sub( '\\\\\\s*\\n', '', value )\n            value = value.replace( '\\n', '' )\n            self.writer__iProperties[name] = value    \n\n        self.writer__iPropertiesInit = $<lang.TrueString>\n\n      except:\n        self.writer__handleException( self.WRITER__UITEXT_UnableToLoadMetaProps+self._getMetaPropFile() )\n\n\n  # Writer Services >> #\n  \n  \n  \n  \n  # Template Services (File Generation) << #\n  \n  # Set the prefix of the files to be generated. \n  def _setFileNamePrefix( self, pPrefix ) :\n    prefix = str( pPrefix )\n    self.writer__iFileNamePrefix = prefix\n  \n  \n  \n  # Get prefix of files to be generated.\n  def _getFileNamePrefix( self ) : \n    return self.writer__iFileNamePrefix\n  \n  \n  \n  # Set the suffix of the files to be generated.\n  def _setFileNameSuffix( self, pSuffix ) :\n    suffix = str( pSuffix )\n    self.writer__iFileNameSuffix = suffix\n  \n  \n  \n  # Get suffix of files to be generated.\n  def _getFileNameSuffix( self ) :\n    return self.writer__iFileNameSuffix\n  \n  \n  \n  # Set the full name of the file to be generated. \n  # Prefix and Suffix are set to empty.\n  def _setFullFileName( self, pName ) :\n  \n    name = str( pName )\n    self._setFileNamePrefix( self.WRITER__STRING_empty )\n    self._setFileNameRoot(   name )\n    self._setFileNameSuffix( self.WRITER__STRING_empty )\n  \n  \n  \n  # Get the full name of current file being generated.\n  def _getFullFileName( self ) : \n    return self._getFileNamePrefix() + self._getFileNameRoot() + self._getFileNameSuffix()\n  \n  \n  \n  # Set the names of the files to be generated. \n  # Prefix and Suffix are set to empty.\n  def _setFullFileNames( self, pNames ) :\n    self._setFileNamePrefix( self.WRITER__STRING_empty )\n    self._setFileNameRoots(  pNames )\n    self._setFileNameSuffix( self.WRITER__STRING_empty )\n  \t\n  \n  \n  # Get the full names of the files to be generated.\n  def _getFullFileNames( self ) : \n    fullFileNames  = []\n    fileNameRoots  = self._getFileNameRoots()\n    fileNamePrefix = self._getFileNamePrefix()\n    fileNameSuffix = self._getFileNameSuffix()\n    numFiles       = len( fileNameRoots )\n    for fileI in range( numFiles ) :\n      fullFileNames.append( fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix )\n  \n    return fullFileNames\n  \n  \n  \n  # Set the root of the name of the file to be generated. \n  def _setFileNameRoot( self, pRoot ) :\n    root = str( pRoot )\n    self._setFileNameRoots( [ root ] )\n  \n  \n  \n  # Get the root of the name of current file being generated.\n  def _getFileNameRoot( self ) :\n    if self.writer__iCurrentFileIndex < len(self.writer__iFileNameRoots):\n      return self.writer__iFileNameRoots[ self.writer__iCurrentFileIndex ]\n    else:\n      return ''\n  \n  \n  # Get roots of the names of files to be generated.\n  def _getFileNameRoots( self ) :\n    return self.writer__iFileNameRoots\n  \n  \n  \n  # Set the roots of the names of the files to be generated. \n  def _setFileNameRoots( self, pRoots ) :\n    self.writer__iFileNameRoots = pRoots\n    self.writer__iNumFiles      = len( self.writer__iFileNameRoots )\n  \n  \n  \n  # Get index of file currently being generated.\n  def _getFileIndex( self ) :\n    return self.writer__iCurrentFileIndex\n  \n  \n  \n  # Get number of files to generate.\n  def _getNumFiles( self ) :\n    return self.writer__iNumFiles\n  \n  \n  \n  # Set output folder.\n  def _setOutputFolder( self, pOutputFolder ) : \n    outputFolder        = str( pOutputFolder )\n    self.writer__iOutputFolder = outputFolder\n   \n  \n  \n  # Get output folder.\n  def _getOutputFolder( self ) :\n    return self.writer__iOutputFolder\n  \n  \n  \n  # Set backup folder.\n  def _setBackupFolder( self, pBackupFolder ) :\n    self.writer__iBackupFolder = pBackupFolder\n  \n  \n  \n  # Get backup folder.\n  def _getBackupFolder( self ) :\n    return self.writer__iBackupFolder\n  \n  \n  \n  # Set the prefix of backup files.\n  def _setBackupPrefix( self, pBackupPrefix ) :\n    self.writer__iBackupPrefix = pBackupPrefix\n  \n  \n  \n  # Set the suffix of backup files.\n  def _setBackupSuffix( self, pBackupSuffix ) :\n    self.writer__iBackupSuffix = pBackupSuffix\n  \n  \n  \n  # Set to true if generated files are to be backed up to disk automatically.   \n  def _backup( self, pBackup ) :\n    self.writer__iBackup = pBackup\n  \n  \n  \n  # Set to true if generated files are to be saved to disk automatically. \n  def _save( self, pSave ) :\n    self.writer__iSave = pSave\n  \n  \n  \n  # Save a text file.\n  def _saveTextFile( self, pFilePath, pContent ) :\n    file = open( pFilePath, \"w\" )\n  \n    if file :  \n      file.write( pContent )\n      file.close()\n    else :\n      raise Exception, \"Unable to read file: \" + pFilePath\n  \n    \n  \n  # Load a text file.\n  def _loadTextFile( self, pFilePath ) :\n    file = open( pFilePath, \"r\" )\n  \n    if file :  \n      contents = file.readlines()\n      file.close()\n      return string.join( contents )\n  \n    else :\n      raise Exception, \"Unable to read file: \" + pFilePath\n  \n\n\n  # Set build properties file.\n  def _setMetaPropFile( self, pMetaPropFile ):\n    self.writer__iMetaPropFile   = pMetaPropFile\n    self.writer__iPropertiesInit = $<lang.FalseString>\n\n\n\n  # Get build properties file.\n  def _getMetaPropFile( self ):\n     return self.writer__iMetaPropFile\n\n\n\n  # Template Services (File Generation) >> #\n  \n  \n  \n  \n  # Template Services (Control) << #\n  \n  # Get the value of a compile-time property.\n  def _getProperty( self, pName ) :\n  \n    if not self.writer__iPropertiesInit : \n      self.writer__initProperties()\n  \n    name   = str( pName )\n    result = self.writer__iProperties.get(name,'') \n  \n    return result\n  \n  \n  \n  # Get first user arg.\n  def _getFirstUserArg( self ) :\n    return self._getUserArg( 0 )\n  \n  \n  \n  # Get second user arg.\n  def _getSecondUserArg( self ) :\n    return self._getUserArg( 1 )\n  \n  \n  \n  # Get third user arg.\n  def _getThirdUserArg( self ) :\n    return self._getUserArg( 2 )\n  \n  \n  \n  # Get nth (n=0,1,2,...) user arg (the nth arg with no self.WRITER__ARGUMENT_CONTROL_PREFIX).\n  def _getUserArg( self, pOrdinal ) :\n    if pOrdinal < self._getNumUserArgs() :\n      userargs = self._getUserArgs()\n      return userargs[ pOrdinal ]\n    else :\n      return self.WRITER__STRING_empty\n  \n  \n  \n  # Get usercommand line arguments to CodeWriter. \n  def _getUserArgs( self ) :\n    return self.writer__iUserArgs\n  \n  \n  \n  # Get number of user command line arguments to CodeWriter.\n  def _getNumUserArgs( self ) :\n    return self.writer__iNumUserArgs\n  \n  \n  \n  # Get command line arguments to CodeWriter. \n  def _getArgs( self ) :\n    return self.writer__iArgs\n  \n  \n  \n  # Get number of command line arguments to CodeWriter.\n  def _getNumArgs( self ) :\n    return self.writer__iNumArgs\n\n\n  # Set a context object for the template to use.\n  def _setContext( self, pContext ):\n    self.writer__iContext = pContext\n\n\n  # Get the context object if set. NOTE: may return null. */\n  def _getContext(self):\n    return self.writer__iContext\n\n  \n  # Template Services (Control) >> #\n  \n  \n  \n  \n  # Template Services (Text Production) << #\n  \n  \n  # Insert text into generated file.\n  def _insert( self, pText ) :\n    text = str( pText )\n    self.writer__iCurrentText = self.writer__iCurrentText + text\n  \n  \n  \n  # Create a String containing specified number of spaces.\n  def _spaces( self, pNumSpaces ) :\n    return \" \" * abs( int( pNumSpaces ) )\n  \n  \n  \n  # Left align String with spaces. \n  def _left( self, pText, pColWidth ) :\n    return self._align( pText, \" \", pColWidth, 'l' )\n  \n  \n  \n  # Right align String with spaces. \n  def _right( self, pText, pColWidth ) :\n    return self._align( pText, \" \", pColWidth, 'r' )\n  \n  \n  \n  # Center align String with spaces. \n  def _center( self, pText, pColWidth ) :\n    return self._align( pText, \" \", pColWidth, 'c' )\n  \n  \n  \n  # Align text within background text with specified column width.\n  # Alignment can be 'l': left, 'c': center, 'r': right\n  def _align( self, pText, pBackText, pColWidth, pAlignment ) :\n  \n    result = pText\n   \n    try :\n      textLen = len( pText )\n      if pColWidth > textLen :\n        backTextLen     = len( pBackText )\n        remainWidth     = pColWidth - textLen\n        backTextRepeats = remainWidth / backTextLen\n        backTextRemain  = remainWidth % backTextLen\n        back            = self.WRITER__STRING_empty\n        for backTextI in range( backTextRepeats ) :\n          back = back + pBackText\n  \n        back = back + pBackText[0:backTextRemain]\n  \n        if 'l' == pAlignment :\n          result = result + back\n  \n        elif 'c' == pAlignment :\n          result = back[0:(len(back)/2)] + result + back[(len(back)/2):]\n  \n        elif 'r' == pAlignment :\n          result = back + result\n  \n    except Exception, e:\n      result = pText\n  \n    return result\n  \n  \n  \n  # Get text of file currently being generated.\n  def _getText( self ) :\n    return self.writer__iCurrentText\n  \n  \n  \n  # Set text of file currently being generated.\n  def _setText( self, pText ) :\n    self.writer__iCurrentText = pText\n\n\n  # Set a result object for the template to use.\n  def _setResult( self, pResult ):\n    self.writer__iResult = pResult\n\n\n  # Get the result object if set. NOTE: may return null. */\n  def _getResult(self):\n    return self.writer__iResult\n\n  \n  # Template Services (Text Production) >> */\n\n\n\n\n# Language Specific Services << #\n\n\n# Insert text into generated file. \n# This special name is used for automated indentation.\ndef _py_insert( obj, pText ) :\n  obj._insert( pText )\n\n# Language Specific Services >> #\n\n\n\n# Start execution.\nif __name__ == \"__main__\":\n  cw = $<main.CodeWriter>();\n  cw.main( sys.argv )\n  sys.exit( 0 )\n\n\n!<footer>\n");
    }

    private static final void makeWF_BasicJavaScriptWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicJavaScriptWriterFormat.jwf", "!<header>\n\n\n\nfunction $<main.CodeWriter>() {\n  var self = this;\n\n  /* Constants << */\n \n  // Command line arguments\n  var WRITER__ARGUMENT_CONTROL_PREFIX = \"$<main.CodeWriter.argument.ControlPrefix>\";\n  var WRITER__ARGUMENT_OutputFolder   = \"$<main.CodeWriter.argument.name.OutputFolder>\";\n  var WRITER__ARGUMENT_MetaPropFile   = \"$<main.CodeWriter.argument.name.MetaPropFile>$<main.CodeWriter.argument.name.BuildPropFile>\";\n  var WRITER__ARGUMENT_BackupFolder   = \"$<main.CodeWriter.argument.name.BackupFolder>\";\n  var WRITER__ARGUMENT_NoBackup       = \"$<main.CodeWriter.argument.name.NoBackup>\";\n\n  // User Interface text message parts\n  var WRITER__UITEXT_Method                     = \"method \";\n  var WRITER__UITEXT_Main                       = \"main \";\n  var WRITER__UITEXT_ExceptionIn                = \"Exception in \";\n  var WRITER__UITEXT_ColonNewLine               = \":\\n\";\n  var WRITER__UITEXT_NewLine                    = \"\\n\";\n  var WRITER__UITEXT_Section                    = \"section \";\n  var WRITER__UITEXT_SavedFile                  = \"Saved file:       \";\n  var WRITER__UITEXT_UnableToSaveFile           = \"Unable to save file: \";\n  var WRITER__UITEXT_UnableToBackupFile         = \"Unable to backup file: \";\n  var WRITER__UITEXT_ToBackupFolder             = \" to backup folder: \";\n  var WRITER__UITEXT_BackupFolderColon          = \"Backup folder: \";\n  var WRITER__UITEXT_BackupFolderExistFailure   = \" does not exist and cannot be created.\";\n  var WRITER__UITEXT_BackupFolderNotAFolder     = \" is not a folder.\";\n  var WRITER__UITEXT_BackupFolderNotWritable    = \" is not writable.\";\n  var WRITER__UITEXT_CodeWriterState            = \"Code Writer State: \";\n  var WRITER__UITEXT_GetFileIndexEquals         = \"\\n_getFileIndex()    = \";\n  var WRITER__UITEXT_GetFullFileNameEquals      = \"\\n_getFullFileName() = \";\n  var WRITER__UITEXT_GetOutputFolderEquals      = \"\\n_getOutputFolder() = \";\n  var WRITER__UITEXT_ErrorHeader                = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\n  var WRITER__UITEXT_ErrorFooter                = \"\\n\\n--- CodeWriter Error Description End -----\\n\\n\";\n  var WRITER__UITEXT_UnableToLoadMetaProps      = \"Unable to load metadata from file: \";\n  var WRITER__UITEXT_UndefinedProperty          = \"Undefined property: \";\n  var WRITER__UITEXT_UnableToCreateOutputFolder = \"Unable to create output folder: \";\n\n  // String constants \n  var WRITER__STRING_empty                      = \"\";\n  var WRITER__STRING_dot                        = \".\";\n  var WRITER__STRING_separator                  = java.io.File.separator;\n\n  /* Constants >> */\n\n\n\n\n  /* Writer Variables << */\n\n  var writer__iFileNameRoots    = [];                   // generated file name roots\n  var writer__iNumFiles         = 0;                    // number of generated files\n  \n  var writer__iFileNamePrefix   = WRITER__STRING_empty; // failsafe default\n  var writer__iFileNameSuffix   = WRITER__STRING_empty; // failsafe default\n\n  var writer__iBackupPrefix     = WRITER__STRING_empty; // failsafe default\n  var writer__iBackupSuffix     = WRITER__STRING_empty; // failsafe default\n\n  var writer__iCurrentText      = [];                   // current text\n  var writer__iCurrentFileIndex = 0;                    // current file index\n\n  var writer__iArgs             = [];                   // cmd line args\n  var writer__iNumArgs          = 0;                    // number of cmd line args\n  var writer__iUserArgs         = [];                   // user cmd line args\n  var writer__iNumUserArgs      = 0;                    // number of user cmd line args\n\n  var writer__iSave             = true;                 // save generated code to disk\n  var writer__iBackup           = true;                 // make backups\n\n  var writer__iOutputFolder     = WRITER__STRING_dot;   // written code is output to this folder\n  var writer__iBackupFolder     = WRITER__STRING_dot;   // overwritten files are placed here\n  var writer__iMetaPropFile     = null;                 // metadata properties file path\n\n  var writer__iProperties       = null;                 // build properties\n  var writer__iPropertiesInit   = false;                // true => lookup table initialiased\n\n  var writer__iContext          = null;                 // context object\n  var writer__iResult           = null;                 // result object\n\n  var writer__iThrow            = false;                // throw Exceptions\n\n  /* Writer Variables >> */\n\n\n\n\n  !<{declare>// section:declare\n  !<declare>!<}declare>\n\n\n\n\n  /* Writer Services << */\n\n  /** Generate. */\n  self._generate = function( pArgs, pThrow ) {\n     writer__iThrow = pThrow;\n\n    try {\n      writer__initialize();\n      writer__handleArgs( pArgs );\n      writer__write();    \n\n      var result = self._getResult();\n      if( null == result ) {\n        result = self._getText();\n        self._setResult( result );\n      }\n\n      return result;\n    } \n    catch( e ) {\n      writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Method + WRITER__UITEXT_Main, e );\n      return 1;\n    }\n  }\n\n\n  /* Initialize. */\n  function writer__initialize() {\n    writer__iCurrentFileIndex = 0;\n    writer__setDefaults();\n  }\n\n\n\n  /** Main file generation loop. Template script is placed here in the body section. */\n  function writer__write() {\n\n    // initialize\n    var writer__currentSection = \"init\";\n\n    try {\n      !<{init>// section:init\n      !<init>!<}init>\n\n\n      // write files loop\n      var writer__numFiles = self._getNumFiles();\n      var writer__fileI    = 0;\n      writer__next_file: for( writer__fileI = 0; writer__fileI < writer__numFiles; writer__fileI = writer__fileI + 1 ) {\n\n        try {\n          !<{prewrite>// section:prewrite\n          writer__currentSection = \"prewrite\";\n          !<prewrite>!<}prewrite>\n\n\n          if( ! writer__startFile() ) { continue writer__next_file; }\n\n\n          !<{body>// section:body\n          writer__currentSection = \"body\";\n          !<body>!<}body>\n\n\n          if( ! writer__endFile() ) { continue writer__next_file; }\n\n\n          !<{postwrite>// section:postwrite\n          writer__currentSection = \"postwrite\";\n          !<postwrite>!<}postwrite>\n\n\n        } \n        catch( e ) {\n           writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, e );\n        }\n\n        writer__nextFile();       \n      }\n \n\n      !<{cleanup>// section:cleanup\n      writer__currentSection = \"cleanup\";\n      !<cleanup>!<}cleanup>\n\n    } \n    catch( e ) {\n      writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, e );\n    }\n  }\n\n\n\n  /** Start writing a file. */\n  function writer__startFile() {\n    writer__iCurrentText = [];\n    return true;\n  }\n\n\n\n  /** End writing a file. */\n  function writer__endFile() {\n    var endOK = true;\n  \n    var filePath = \"output-file-path\";\n\n    if( endOK ) {\n      var fileName = self._getFullFileName();\n      filePath \n        = writer__iOutputFolder\n        + WRITER__STRING_separator\n        + fileName;\n\n      if( writer__iBackup ) {\n        try {\n          writer__backup( filePath, fileName, writer__iBackupFolder );\n        } \n        catch( e ) {\n          writer__handleException( WRITER__UITEXT_UnableToBackupFile \n                                   + filePath \n                                   + WRITER__UITEXT_ToBackupFolder\n                                   + writer__iBackupFolder\n                                   ,e );\n          endOK = false;\n        }\n      }\n    }\n\n    var outputFolder = null;\n    try {\n      outputFolder = new java.io.File( filePath ).getParentFile();\n      if( null != outputFolder && !outputFolder.exists() ) {\n        outputFolder.mkdirs();\n      }\n    }\n    catch( e ) {\n      writer__handleException( WRITER__UITEXT_UnableToCreateOutputFolder \n                               + outputFolder\n                               ,e );\n      endOK = false;\n    }\n\n\n    if( endOK && writer__iSave ) {\n      try {\n        self._saveTextFile( filePath, writer__iCurrentText.join('') );\n        writer__userMessage( WRITER__UITEXT_SavedFile + filePath + WRITER__UITEXT_NewLine, false );\n      } \n      catch( e ) {\n        writer__handleException( WRITER__UITEXT_UnableToSaveFile + filePath, e );\n        endOK = false;\n      }\n    }\n\n    return endOK;\n  }\n\n\n\n  /** Move to next file. */\n  function writer__nextFile() {\n    writer__iCurrentFileIndex = writer__iCurrentFileIndex + 1;\n  }\n\n\n\n  /** Handle command line arguments to CodeWriter. */\n  function writer__handleArgs( pArgs ) {\n\n    // set arg names\n    var argName_OutputFolder     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_OutputFolder;\n    var argName_MetaPropFile     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_MetaPropFile;\n    var argName_BackupFolder     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_BackupFolder;\n    var argName_NoBackup         = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_NoBackup;\n\n    // parse\n    var numArgs = pArgs.length;\n    for( var argI = 0; argI < numArgs; argI = argI + 1 ) {\n      if( 0 < argName_OutputFolder.length && 0 == pArgs[argI].indexOf( argName_OutputFolder ) ) {\n        self._setOutputFolder( pArgs[ argI ].substring( argName_OutputFolder.length ) );\n      }\n      else if( 0 < argName_MetaPropFile.length && 0 == pArgs[argI].indexOf( argName_MetaPropFile ) ) {\n        self._setMetaPropFile( pArgs[ argI ].substring( argName_MetaPropFile.length ) );\n      }\n      else if( 0 < argName_BackupFolder.length && 0 == pArgs[argI].indexOf( argName_BackupFolder ) ) {\n        self._setBackupFolder( pArgs[ argI ].substring( argName_BackupFolder.length ) );\n      }\n      else if( 0 < argName_NoBackup.length && argName_NoBackup.equals( pArgs[ argI ] ) ) {\n        self._backup( $<lang.FalseString> ); // NOTE: -B => don't make backups\n      }\n    }\n\n    writer__initArgs( pArgs.length, pArgs );\n  }\n\n\n\n  /** Set defaults from configuration property set. */\n  function writer__setDefaults() {\n\n    $<{main.FileNameRoot>self._setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n    $<{main.FileNamePrefix>self._setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n    $<{main.FileNameSuffix>self._setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n    $<{main.OutputFolder>self._setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n    $<{main.BackupFolder>self._setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n    $<{main.BackupPrefix>self._setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n    $<{main.BackupSuffix>self._setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n    self._backup( \"$<lang.TrueString>\".equals( \"$<jostraca.MakeBackup>\" ) );\n\n  }\n\n\n\n  /** Initialize command line arguments. */\n  function writer__initArgs( pNumArgs, pArgs ) {\n    var argI        = 0;\n    var userArgI    = 0;\n\n    writer__iNumArgs     = pNumArgs;\n    writer__iArgs        = pArgs;\n    writer__iNumUserArgs = writer__iNumArgs;\n\n    for( argI = 0; argI < writer__iNumArgs; argI = argI + 1 ) {\n      if( 0 == writer__iArgs[argI].indexOf( WRITER__ARGUMENT_CONTROL_PREFIX ) ) {\n        writer__iNumUserArgs = writer__iNumUserArgs - 1;\n      }\n    }\n\n    writer__iUserArgs = [];\n    for( argI = 0; argI < writer__iNumArgs; argI = argI + 1 ) {\n      if( -1 == writer__iArgs[argI].indexOf( WRITER__ARGUMENT_CONTROL_PREFIX ) ) {\n        writer__iUserArgs[ userArgI ] = writer__iArgs[ argI ];\n        userArgI = userArgI + 1;\n      }\n    }\n  }\n\n\n\n  /** Print a user readable message. */\n  function writer__userMessage( pMessage, pIsError ) {\n    (pIsError?java.lang.System.err:java.lang.System.out).print( pMessage );\n  }\n\n\n\n  /** Handle exceptions: print an explanation for user. */\n  function writer__handleException( pMessage, pException ) {\n    if( pException.runtime ) {\n      throw pMessage+\": \"+pException.msg;\n    }\n    else {\n      var userMsg = WRITER__UITEXT_ErrorHeader + \n        writer__describeState() + pMessage + WRITER__UITEXT_ColonNewLine + (pException.msg?pException.msg:pException) +\n        WRITER__UITEXT_ErrorFooter;\n\n      if( writer__iThrow ) {\n        throw { runtime:true, msg:userMsg };\n      }\n      else {\n        writer__userMessage( userMsg, true );\n      }\n    }\n  }\n\n\n\n  /** Provide a concise description of the state of the CodeWriter. */\n  function writer__describeState() {\n    var currentState \n      = WRITER__UITEXT_CodeWriterState\n      + WRITER__UITEXT_GetFileIndexEquals    + self._getFileIndex() \n      + WRITER__UITEXT_GetFullFileNameEquals + self._getFullFileName()\n      + WRITER__UITEXT_GetOutputFolderEquals + self._getOutputFolder()\n      + WRITER__UITEXT_NewLine\n      ; \n    return currentState;\n  }\n\n\n\n  /** Backup overwritten files, if they exist.\n   *  Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n   */ \n  function writer__backup( pFilePath, pFileName, pBackupFolder ) {\n\n    var backupFolder = new java.io.File( pBackupFolder );\n\n    // check backup folder ( create if necessary )\n    if( ! backupFolder.exists() ) {\n      if( ! backupFolder.mkdirs() ) {\n        throw { runtime:true, msg:WRITER__UITEXT_BackupFolderColon\n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderExistFailure };\n      }\n    }\n    if( ! backupFolder.isDirectory() ) {\n      throw { runtime:true, msg:WRITER__UITEXT_BackupFolderColon \n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderNotAFolder };\n    }\n    if( ! backupFolder.canWrite() ) {\n      throw { runtime:true, msg:WRITER__UITEXT_BackupFolderColon\n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderNotWritable };\n    }\n\n    // create backup file path\n    var calendar = java.util.Calendar.getInstance();\n    var year_yyyy = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.YEAR) ),         \"0\", 4, 'r' );\n    var month_mm  = self._align( java.lang.String.valueOf( (1+calendar.get(java.util.Calendar.MONTH)) ),    \"0\", 2, 'r' );\n    var day_dd    = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.DAY_OF_MONTH) ), \"0\", 2, 'r' );\n    var hour_hh   = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.HOUR_OF_DAY) ),  \"0\", 2, 'r' );\n    var minute_mm = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.MINUTE) ),       \"0\", 2, 'r' );\n    var second_ss = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.SECOND) ),       \"0\", 2, 'r' );\n    var dateTime       = year_yyyy+month_mm+day_dd+hour_hh+minute_mm+second_ss;\n    var backupFileName = dateTime + writer__iBackupPrefix + pFileName + writer__iBackupSuffix;\n    var backupFilePath = new java.io.File( pBackupFolder, backupFileName );\n    \n    var fullBackupFolder = backupFilePath.getParentFile();\n    if( null != fullBackupFolder && !fullBackupFolder.exists() ) {\n      if( ! fullBackupFolder.mkdirs() ) {\n        throw { runtime:true, msg:WRITER__UITEXT_BackupFolderColon\n                                    + fullBackupFolder\n                                    + WRITER__UITEXT_BackupFolderExistFailure };\n      }\n    }\n\n\n    // save backup file\n    var fileToBackup = new java.io.File( pFilePath );\n    if( fileToBackup.exists() ) {\n      var fileContents = self._loadTextFile( pFilePath );\n      self._saveTextFile( backupFilePath.getPath(), fileContents );\n    }\n  }\n\n\n\n  /** Load build properties. */\n  function writer__initProperties() {\n\n    var metaPropFile = self._getMetaPropFile();\n    if( null != metaPropFile ) {\n      writer__iProperties = new java.util.Properties();\n      \n      try {\n        var fis = new java.io.FileInputStream( self._getMetaPropFile() );\n        writer__iProperties.load( fis );\n        fis.close();\n      }\n      catch( e ) {\n        writer__handleException( WRITER__UITEXT_UnableToLoadMetaProps+_getMetaPropFile(), e );\n      }\n\n      writer__iPropertiesInit = true;\n    }\n  }\n\n  /* Writer Services >> */\n \n\n\n\n  /* Template Services (File Generation) << */\n\n  /** Set the prefix of the files to be generated. */\n  self._setFileNamePrefix = function( pPrefix ) {\n    if( null == pPrefix ) {\n      return; // ignore\n    }\n    writer__iFileNamePrefix = pPrefix;\n  }\n\n\n\n  /** Get prefix of files to be generated. */\n  self._getFileNamePrefix = function() {\n    return writer__iFileNamePrefix;\n  }\n\n\n\n  /** Set the suffix of the files to be generated. */\n  self._setFileNameSuffix = function( pSuffix ) {\n    if( null == pSuffix ) {\n      return; // ignore\n    }\n    writer__iFileNameSuffix = pSuffix;\n  }\n\n\n\n  /** Get suffix of files to be generated. */\n  self._getFileNameSuffix = function() {\n    return writer__iFileNameSuffix;\n  }\n\n\n\n  /** Set the full name of the file to be generated. \n   *  Prefix and Suffix are set to empty.\n   */\n  self._setFullFileName = function( pName ) {\n    self._setFileNamePrefix( WRITER__STRING_empty );\n    self._setFileNameRoot(   pName );\n    self._setFileNameSuffix( WRITER__STRING_empty );\n  }\n\n\n\n  /** Get the full name of current file being generated. */\n  self._getFullFileName = function() {\n    return self._getFileNamePrefix() + self._getFileNameRoot() + self._getFileNameSuffix();\n  }\n\n\n\n  /** Set the names of the files to be generated. \n   *  Prefix and Suffix are set to empty.\n   */\n  self._setFullFileNames = function( pNames ) {\n    self._setFileNamePrefix( WRITER__STRING_empty );\n    self._setFileNameRoots(  pNames );\n    self._setFileNameSuffix( WRITER__STRING_empty );\n  }\n\n\n\n  /** Get the full names of the files to be generated. */\n  self._getFullFileNames = function() {\n\n    var fileNameRoots  = self._getFileNameRoots();\n    var numFiles       = fileNameRoots.length;\n    var fullFileNames  = [];\n    var fileNamePrefix = self._getFileNamePrefix();\n    var fileNameSuffix = self._getFileNameSuffix();\n\n    for( var fileI = 0; fileI < numFiles; fileI = fileI + 1 ) {\n      fullFileNames[ fileI ] = fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix;\n    }\n\n    return fullFileNames;\n  }\n\n\n\n  /** Set the root of the name of the file to be generated. */\n  self._setFileNameRoot = function( pFileNameRoot ) {\n    if( null == pFileNameRoot ) {\n      return; // ignore\n    }\n    self._setFileNameRoots( [ pFileNameRoot ] );\n  }\n\n\n\n  /** Get the root of the name of the current file being generated. */\n  self._getFileNameRoot = function() {\n    if( 0 < writer__iFileNameRoots.length ) {\n      return writer__iFileNameRoots[ writer__iCurrentFileIndex ];\n    }\n    return WRITER__STRING_empty;\n  }\n\n\n\n  /** Set the roots of the names of the files to be generated. */\n  self._setFileNameRoots = function( pFileNameRoots ) {\n    if( null == pFileNameRoots ) {\n      return; // ignore\n    }\n\n    writer__iFileNameRoots = pFileNameRoots;\n    writer__iNumFiles      = pFileNameRoots.length;\n  }\n\n\n\n  /** Get roots of the names of files to be generated. */\n  self._getFileNameRoots = function() {\n    return writer__iFileNameRoots;\n  }\n\n\n\n  /** Get index of file currently being generated. */\n  self._getFileIndex = function() {\n    return writer__iCurrentFileIndex;\n  }\n\n\n\n  /** Get number of files to generate. */\n  self._getNumFiles = function() {\n    return writer__iNumFiles;\n  }\n\n\n\n  /** Set output folder. */\n  self._setOutputFolder = function( pOutputFolder ) {\n    writer__iOutputFolder = pOutputFolder;\n  }\n\n\n\n  /** Get output folder. */\n  self._getOutputFolder = function() {\n    return writer__iOutputFolder;\n  }\n\n\n\n  /** Set backup folder. */\n  self._setBackupFolder = function( pBackupFolder ) {\n    writer__iBackupFolder = pBackupFolder;\n  }\n\n\n\n  /** Get backup folder. */\n  self._getBackupFolder = function() {\n    return writer__iBackupFolder;\n  }\n\n\n\n  /** Set the prefix of backup files. */\n  self._setBackupPrefix = function( pPrefix ) {\n    if( null == pPrefix ) {\n      return; // ignore\n    }\n    writer__iBackupPrefix = pPrefix;\n  }\n\n\n\n  /** Set the suffix of backup files. */\n  self._setBackupSuffix = function( pSuffix ) {\n    if( null == pSuffix ) {\n      return; // ignore\n    }\n    writer__iBackupSuffix = pSuffix;\n  }\n\n\n\n  /** Set to true if generated files are to be backed up to disk automatically. */\n  self._backup = function( pBackup ) {\n    writer__iBackup = pBackup;\n  }\n\n\n\n  /** Set to true if generated files are to be saved to disk automatically. */\n  self._save = function( pSave ) {\n    writer__iSave = pSave;\n  }\n\n\n\n  /** Save a text file. */\n  self._saveTextFile = function( pFilePath, pContent ) {\n    try {\n      var sr = new java.io.StringReader( pContent );\n      var br = new java.io.BufferedReader( sr );\n      var fw = new java.io.FileWriter( pFilePath );\n      var bw = new java.io.BufferedWriter( fw );\n\n      var line = null;\n      while( null != (line = br.readLine()) ) {\n        bw.write( line );\n        bw.newLine();\n      }\n\n      bw.close();\n      br.close();\n    }\n    catch( e ) {\n      throw { runtime:true, msg:e.getMessage() };\n    }\n  }\n\n\n\n  /** Load a text file. */\n  self._loadTextFile = function( pFilePath ) {\n    try {\n      var fr = new java.io.FileReader( new java.io.File( pFilePath ) );\n      var br = new java.io.BufferedReader( fr );\n\n      var line = null;\n      var sb   = [];\n      while( null != ( line = br.readLine() ) ) {\n        sb.push( line+\"\\n\" );\n      }\n      br.close();\n      return sb.join('');\n    }\n    catch( e ) {\n      throw { runtime:true, msg:e.getMessage() };\n    }\n  }\n\n\n  /** Set build properties file. */\n  self._setMetaPropFile = function( pMetaPropFile ) {\n    writer__iMetaPropFile   = pMetaPropFile;\n    writer__iPropertiesInit = false;\n  }\n\n\n\n  /** Get build properties file. */\n  self._getMetaPropFile = function() {\n    return writer__iMetaPropFile;\n  }\n\n  /* Template Services (File Generation) >> */\n\n\n\n\n  /* Template Services (Control) << */\n\n  /** Get the value of a compile-time property. */\n  self._getProperty = function( pName ) {\n    var result = WRITER__STRING_empty;\n\n    if( ! writer__iPropertiesInit ) {\n      writer__initProperties();\n    }\n\n    result = writer__iProperties.getProperty(pName);\n    return result;\n  }\n\n\n\n  /** Get first user arg. */\n  self._getFirstUserArg = function() {\n    return self._getUserArg(0);\n  }\n\n\n\n  /** Get second user arg. */\n  self._getSecondUserArg = function() {\n    return self._getUserArg(1);\n  }\n\n\n\n  /** Get third user arg. */\n  self._getThirdUserArg = function() {\n    return self._getUserArg(2);\n  }\n\n\n\n  /** Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX). */\n  self._getUserArg = function( pOrdinal ) {\n    if( pOrdinal < self._getNumUserArgs() ) {\n      var userargs =  self._getUserArgs();\n      return userargs[ pOrdinal ];\n    }\n    else {\n      return WRITER__STRING_empty;\n    }\n  }\n\n\n\n  /** Get user command line arguments to CodeWriter. */\n  self._getUserArgs = function() {\n    return writer__iUserArgs;\n  }\n\n\n\n  /** Get number of user command line arguments to CodeWriter. */\n  self._getNumUserArgs = function() {\n    return writer__iNumUserArgs;\n  }\n\n\n\n  /** Get all command line arguments to CodeWriter. */\n  self._getArgs = function() {\n    return writer__iArgs;\n  }\n\n\n\n  /** Get total number of command line arguments to CodeWriter. */\n  self._getNumArgs = function() {\n    return writer__iNumArgs;\n  }\n\n\n  \n  /** Set a context object for the template to use. */\n  self._setContext = function( pContext ) {\n    writer__iContext = pContext;\n  }\n\n\n\n  /** Get the context object if set. NOTE: may return null. */\n  self._getContext = function() {\n    return writer__iContext;\n  }\n\n  /* Template Services (Control) >> */\n\n\n\n\n  /* Template Services (Text Production) << */\n\n  // inserts\n  self._insert = function( pText ) {\n    writer__iCurrentText.push( pText );\n  }\n\n\n  /** Create a String containing specified number of spaces. */\n  self._spaces = function( pNumSpaces ) {\n    var numSpaces = pNumSpaces;\n    if( 0 > numSpaces ) { numSpaces *= -1; }\n    var spaces = [];\n    for(var spaceI = 0; spaceI < numSpaces; spaceI = spaceI + 1 ) {\n      spaces.push(\" \");\n    }\n    return spaces.join('');\n  }\n\n\n\n  /** Left align String with spaces. */ \n  self._left = function( pText, pColWidth ) {\n    return self._align( pText, \" \", pColWidth, 'l' );\n  } \n\n\n\n  /** Right align String with spaces. */ \n  self._right = function( pText, pColWidth ) {\n    return self._align( pText, \" \", pColWidth, 'r' );\n  } \n\n\n\n  /** Center align String with spaces. */ \n  self._center = function( pText, pColWidth ) {\n    return self._align( pText, \" \", pColWidth, 'c' );\n  } \n\n\n\n  /** Align text within background text to specified column width. \n   *  Alignment can be 'l': left, 'c': center, 'r': right.\n   */\n  self._align = function( pText, pBackText, pColWidth, pAlignment ) {\n    var result = pText;\n \n    if( null == pText ) { \n       result = WRITER__STRING_empty; \n    }\n    else if( null != pBackText ) {\n      try {\n        var textLen = pText.length;\n        if( pColWidth > textLen ) {\n          var backTextLen     = pBackText.length;\n          var remainWidth     = pColWidth - textLen;\n          var backTextRepeats = Math.floor( remainWidth / backTextLen );\n          var backTextRemain  = remainWidth % backTextLen;\n          var back            = WRITER__STRING_empty;\n          for( var backTextI = 0; backTextI < backTextRepeats; backTextI = backTextI + 1 ) {\n            back = back + pBackText;\n          }\n          back = back + pBackText.substring( 0, backTextRemain );\n \n          switch( pAlignment ) {\n          case 'l':\n            result = result + back;\n            break;\n          case 'c':\n            result = back.substring( 0, Math.floor(back.length/2) ) + result + back.substring( Math.floor(back.length/2) );\n            break;\n          case 'r':\n            result = back + result;\n            break;\n          }\n        }\n      } \n      catch( e ) {\n        result = pText;\n      }\n    }\n    return result;\n  }\n\n\n\n  /** Set the text of file currently being generated. */\n  self._setText = function( pText) {\n    writer__iCurrentText = [pText];\n  }\n\n\n\n  /** Get the text of file currently being generated. */\n  self._getText = function() {\n    return writer__iCurrentText.join('');\n  }\n\n\n  /** Set result object (optional). */\n  self._setResult = function( pResult ) {\n    writer__iResult = pResult;\n  }\n\n\n\n  /** Get the result object (may be null). */\n  self._getResult = function() {\n    return writer__iResult;\n  }\n\n  /* Template Services (Text Production) >> */\n\n}\n\n\nvar codewriter = new $<main.CodeWriter>();\n\n/** Execute. */\nfunction main( pArgs ) {\n  var result = codewriter._generate( pArgs, false );\n    \n  var exitvalue = 0;\n  if( !isNan(result) ) {\n    try {\n      exitvalue = parseInt(result);\n    } \n    catch( e ) {\n      // result was not an integer, so ignore it\n    } \n  }\n\n  java.lang.System.exit( exitvalue );\n}\n\n\n!<footer>\n");
    }

    private static final void makeWF_BasicJavaComponent_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicJavaComponent.jwf", "!<header>\n\n\n\n$<{java.CodeWriter.package>package $<java.CodeWriter.package>;$<}java.CodeWriter.package>\n\n\n\nimport java.io.FileOutputStream;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.StringReader;\nimport java.io.BufferedReader;\nimport java.io.FileWriter;\nimport java.io.BufferedWriter;\n\nimport java.util.Vector;\nimport java.util.Hashtable;\nimport java.util.Calendar;\n\n\n\n!<{import>/* section:import << */\n//\n\n!<import>\n\n//\n/* section:import >> */!<}import>\n\n\n/** DEPRECATED */\npublic class $<main.CodeWriter> \n$<{java.CodeWriter.extends>  extends $<java.CodeWriter.extends> $<}java.CodeWriter.extends> \n$<{java.CodeWriter.implements>  implements $<java.CodeWriter.implements> $<}java.CodeWriter.implements>\n{\n\n  /* Constants << */\n \n  // User Interface text message parts\n  public static final String writer__UITEXT_ExceptionIn              = \"Exception in \";\n  public static final String writer__UITEXT_ColonNewLine             = \":\\n\";\n  public static final String writer__UITEXT_Section                  = \"section \";\n  public static final String writer__UITEXT_ErrorHeader              = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\n  public static final String writer__UITEXT_ErrorFooter              = \"\\n--- CodeWriter Error Description End -----\\n\\n\";\n\n  public static final int writer__BUFFER_SIZE  = 4096; // initial size of StringBuffer\n\n  /* Constants >> */\n\n\n  /* Writer Variables << */\n\n  protected StringBuffer writer__iText                  = new StringBuffer();  // current text\n  protected Hashtable    writer__iProperties            = new Hashtable();     // lookup table for compile time properties\n  protected boolean      writer__iPropertiesInitialised = false;               // true => lookup table initialiased\n\n  /* Writer Variables >> */\n\n\n  !<{declare>/* section:declare << */\n  //\n\n  !<declare>\n\n  //\n  /* section:declare >> */!<}declare>\n\n\n\n  /* Writer Services << */\n\n  /* Initialize. */\n  public void writer__initialize() {\n    writer__iText = new StringBuffer( writer__BUFFER_SIZE );\n  }\n\n\n\n  /** Template script is placed here in the body section. */\n  public void writer__write() throws Exception {\n\n    // initialize\n    String writer__currentSection = \"body\";\n\n    try {\n\n      !<{init>/* section:init << */\n      //\n\n      writer__currentSection = \"init\";\n      !<init>\n\n      //\n      /* section:init >> */!<}init>\n\n\n      !<{body>/* section:body << */\n      //\n\n      writer__currentSection = \"body\";\n      !<body>\n\n      //\n      /* section:body >> */!<}body>\n\n    } \n    catch( Exception e ) {\n      writer__handleException( writer__UITEXT_ExceptionIn + writer__UITEXT_Section + writer__currentSection, e );\n    }\n  }\n\n\n\n  /** Handle exceptions: print an explanation for user. */\n  public void writer__handleException( final String pMessage, final Exception pException ) throws Exception {\n\n    StringBuffer userMsg = new StringBuffer( 111 );\n\n    userMsg.append( writer__UITEXT_ErrorHeader );\n\n    userMsg.append( writer__describeState() + pMessage + writer__UITEXT_ColonNewLine );\n\n    StringWriter stringWriter = new StringWriter();\n    pException.printStackTrace( new PrintWriter( stringWriter) );\n    userMsg.append( stringWriter.toString() );\n\n    userMsg.append( writer__UITEXT_ErrorFooter );\n\n    throw new Exception( userMsg.toString() );\n  }\n\n\n\n  /** Provide a concise description of the state of the CodeWriter. */\n  public String writer__describeState() {\n    String currentState = \"\"; \n    return currentState;\n  }\n\n\n\n  /** Set compile time properties. */\n  public void writer__initProperties() {\n    $<{jostraca.properties.NameValueList>\n    String[] propertyList = new String[] { $<jostraca.properties.NameValueList> };\n    int numProperties = propertyList.length;\n    for( int propI = 0; propI < numProperties; propI += 2 ) {\n      writer__iProperties.put( propertyList[ propI ], propertyList[ propI+1 ] );\n    }\n    writer__iPropertiesInitialised = true;\n    $<}jostraca.properties.NameValueList>\n  }\n\n\n  /* Writer Services >> */\n \n\n\n\n  /* Template Services (Control) << */\n\n  public String _emit() throws Exception {\n    writer__initialize();\n    writer__write();\n    return _getText();\n  }\n\n\n\n  /** Get compile time property\n   *  @param rName Name of property to get.\n   */\n  public String _getProperty( final String pName ) {\n    String result = \"\";\n\n    if( ! writer__iPropertiesInitialised ) {\n      writer__initProperties();\n    }\n\n    if( writer__iProperties.containsKey( pName ) ) {\n      result = (String) writer__iProperties.get( pName );\n    }\n\n    return result;\n  }\n\n  /* Template Services (Control) >> */\n\n\n\n\n  /* Template Services (Text Production) << */\n\n\n  // inserts\n  // ...\n\n  /** Insert text into written file. */\n  public void _insert( String rText ) {\n    writer__iText.append( rText );\n  }\n\n  /** Insert string representation of object into written file. */\n  public void _insert( final Object pObject ) {\n    writer__iText.append( String.valueOf( pObject ) );\n  }\n\n  /** Insert string representation of primitive data type into written file. */\n\n  public void _insert( final int pInt ) {\n    writer__iText.append( pInt );\n  }\n  public void _insert( final long pLong ) {\n    writer__iText.append( pLong );\n  }\n  public void _insert( final short pShort ) {\n    writer__iText.append( pShort );\n  }\n  public void _insert( final byte pByte ) {\n    writer__iText.append( pByte );\n  }\n  public void _insert( final double pDouble ) {\n    writer__iText.append( pDouble );\n  }\n  public void _insert( final float pFloat ) {\n    writer__iText.append( pFloat );\n  }\n  public void _insert( final char pChar ) {\n    writer__iText.append( pChar );\n  }\n  public void _insert( final boolean pBoolean ) {\n    writer__iText.append( pBoolean );\n  }\n\n\n\n  /** Create a String containing specified number of spaces. */\n  public String _spaces( final int pNumSpaces ) {\n    int numSpaces = pNumSpaces;\n    if( 0 > numSpaces ) { numSpaces *= -1; }\n    StringBuffer spaces = new StringBuffer( numSpaces );\n    for(int spaceI = 0; spaceI < numSpaces; spaceI++) {\n      spaces.append(\" \");\n    }\n    return spaces.toString();\n  }\n\n\n\n  /** Left align String with spaces. */ \n  public String _left( final String pText, final int pColWidth ) {\n    return _align( pText, \" \", pColWidth, 'l' );\n  } \n\n\n\n  /** Right align String with spaces. */ \n  public String _right( final String pText, final int pColWidth ) {\n    return _align( pText, \" \", pColWidth, 'r' );\n  } \n\n\n\n  /** Center align String with spaces. */ \n  public String _center( final String pText, final int pColWidth ) {\n    return _align( pText, \" \", pColWidth, 'c' );\n  } \n\n\n\n  /** Align text within background text to specified column width. \n   *  Alignment can be 'l': left, 'c': center, 'r': right\n   */\n  public String _align( final String pText, final String pBackText, final int pColWidth, final char pAlignment ) {\n    String result = pText;\n \n    if( null == pText ) { \n       result = \"\"; \n    }\n    else if( null != pBackText ) {\n      try {\n        int textLen = pText.length();\n        if( pColWidth > textLen ) {\n          int    backTextLen     = pBackText.length();\n          int    remainWidth     = pColWidth - textLen;\n          int    backTextRepeats = remainWidth / backTextLen;\n          int    backTextRemain  = remainWidth % backTextLen;\n          String back            = \"\";\n          for( int backTextI = 0; backTextI < backTextRepeats; backTextI++ ) {\n            back = back + pBackText;\n          }\n          back = back + pBackText.substring( 0, backTextRemain );\n \n          switch( pAlignment ) {\n          case 'l':\n            result = result + back;\n            break;\n          case 'c':\n            result = back.substring( 0, (back.length()/2) ) + result + back.substring( (back.length()/2) );\n            break;\n          case 'r':\n            result = back + result;\n            break;\n          }\n        }\n      } \n      catch( Exception e ) {\n        result = pText;\n      }\n    }\n    return result;\n  }\n\n\n\n  /** Set text being generated. */\n  public void _setText( final String pText) {\n    writer__iText = new StringBuffer( pText );\n  }\n\n\n\n  /** Get text being generated. */\n  public String _getText() {\n    return writer__iText.toString();\n  }\n\n  /* Template Services (Text Production) >> */\n\n}\n\n!<footer>\n");
    }

    private static final void makeWF_JavaComponent_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("JavaComponent.jwf", "!<header>\n\n\n\n$<{java.CodeWriter.package>package $<java.CodeWriter.package>;$<}java.CodeWriter.package>\n\n\n\nimport java.io.FileOutputStream;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.StringReader;\nimport java.io.BufferedReader;\nimport java.io.FileWriter;\nimport java.io.BufferedWriter;\n\nimport java.util.Vector;\nimport java.util.Hashtable;\nimport java.util.Calendar;\n\n\n\n!<{import>/* section:import << */\n//\n\n!<import>\n\n//\n/* section:import >> */!<}import>\n\n\n\npublic class $<main.CodeWriter> \n$<{java.CodeWriter.extends>  extends $<java.CodeWriter.extends> $<}java.CodeWriter.extends> \n$<{java.CodeWriter.implements>  implements $<java.CodeWriter.implements> $<}java.CodeWriter.implements>\n{\n\n  /* Constants << */\n \n  // User Interface text message parts\n  public static final String writer__UITEXT_Method                   = \"method \";\n  public static final String writer__UITEXT_Main                     = \"main \";\n  public static final String writer__UITEXT_ExceptionIn              = \"Exception in \";\n  public static final String writer__UITEXT_ColonNewLine             = \":\\n\";\n  public static final String writer__UITEXT_NewLine                  = \"\\n\";\n  public static final String writer__UITEXT_Section                  = \"section \";\n  public static final String writer__UITEXT_SavedFile                = \"Saved file:       \";\n  public static final String writer__UITEXT_UnableToSaveFile         = \"Unable to save file: \";\n  public static final String writer__UITEXT_UnableToBackupFile       = \"Unable to backup file: \";\n  public static final String writer__UITEXT_ToBackupFolder           = \" to backup folder: \";\n  public static final String writer__UITEXT_BackupFolderColon        = \"Backup folder: \";\n  public static final String writer__UITEXT_BackupFolderExistFailure = \" does not exist and cannot be created.\";\n  public static final String writer__UITEXT_BackupFolderNotAFolder   = \" is not a folder.\";\n  public static final String writer__UITEXT_BackupFolderNotWritable  = \" is not writable.\";\n  public static final String writer__UITEXT_CodeWriterState          = \"Code Writer State: \";\n  public static final String writer__UITEXT_GetFileIndexEquals       = \"\\n_getFileIndex()    = \";\n  public static final String writer__UITEXT_GetFullFileNameEquals    = \"\\n_getFullFileName() = \";\n  public static final String writer__UITEXT_GetOutputFolderEquals    = \"\\n_getOutputFolder() = \";\n  public static final String writer__UITEXT_ErrorHeader              = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\n  public static final String writer__UITEXT_ErrorFooter              = \"\\n--- CodeWriter Error Description End -----\\n\\n\";\n  public static final String writer__UITEXT_PlaceHolderException \n    = \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\";\n\n  public static final int writer__FILE_BUFFER_SIZE  = 4096;                // initial size of StringBuffer\n\n  /* Constants >> */\n\n\n  /* Writer Variables << */\n\n  protected String[]     writer__iFileNameRoots     = new String[] {};     // generated file name roots\n  protected int          writer__iNumFiles          = 0;                   // number of generated files\n  \n  protected String       writer__iFileNamePrefix    = \"\";                  // failsafe default\n  protected String       writer__iFileNameSuffix    = \"\";                  // failsafe default\n\n  protected String       writer__iBackupPrefix      = \"\";                  // failsafe default\n  protected String       writer__iBackupSuffix      = \"\";                  // failsafe default\n\n  protected StringBuffer writer__iCurrentText       = new StringBuffer();  // current text\n  protected int          writer__iCurrentFileIndex  = 0;                   // current file index\n\n  protected boolean      writer__iSave              = true;                // save generated code to disk\n  protected boolean      writer__iBackup            = true;                // make backups\n\n  protected String       writer__iOutputFolder      = \".\";                 // written code is output to this folder\n  protected String       writer__iBackupFolder      = \".\";                 // overwritten files are placed here\n\n  protected Hashtable    writer__iProperties            = new Hashtable(); // lookup table for compile time properties\n  protected boolean      writer__iPropertiesInitialised = false;           // true => lookup table initialiased\n\n  /* Writer Variables >> */\n\n\n  !<{declare>/* section:declare << */\n  //\n\n  !<declare>\n\n  //\n  /* section:declare >> */!<}declare>\n\n\n\n  /* Writer Services << */\n\n  /* Initialize. */\n  public void writer__initialize() {\n    writer__iCurrentFileIndex = 0;\n    writer__setDefaults();\n  }\n\n\n\n  /** Main loop.\n   *  Template script is placed here in the @body section.\n   */\n  public void writer__write() throws Exception {\n\n    // initialize\n    String writer__currentSection = \"init\";\n\n    try {\n      !<{init>/* section:init << */\n      //\n\n      !<init>\n\n      //\n      /* section:init >> */!<}init>\n\n\n      // write files loop\n      int      writer__numFiles = _getNumFiles();\n      int      writer__fileI    = 0;\n      writer__next_file: for( writer__fileI = 0; writer__fileI < writer__numFiles; writer__fileI++ ) {\n\n        !<{prewrite>/* section:prewrite << */\n        // \n\n        writer__currentSection = \"prewrite\";\n        !<prewrite>\n\n        //\n        /* section:prewrite >> */!<}prewrite>\n\n\n        if( ! writer__startFile() ) { continue writer__next_file; }\n\n\n        !<{body>/* section:body << */\n        //\n\n        writer__currentSection = \"body\";\n        !<body>\n\n        //\n        /* section:body >> */!<}body>\n\n\n        if( ! writer__endFile() ) { continue writer__next_file; }\n\n\n        !<{postwrite>/* section:postwrite << */\n        // \n\n        writer__currentSection = \"postwrite\";\n        !<postwrite>\n\n        //\n        /* section:postwrite >> */!<}postwrite>\n\n        writer__nextFile();       \n      }\n \n\n      !<{cleanup>/* section:cleanup << */\n      //\n \n      writer__currentSection = \"cleanup\";\n      !<cleanup>\n\n      //\n      /* section:cleanup >> */!<}cleanup>\n\n\n    } \n    catch( Exception e ) {\n      writer__handleException( writer__UITEXT_ExceptionIn + writer__UITEXT_Section + writer__currentSection, e );\n    }\n\n  }\n\n\n\n  /** Start writing a file. */\n  public boolean writer__startFile() {\n    writer__iCurrentText = new StringBuffer( writer__FILE_BUFFER_SIZE );\n    return true;\n  }\n\n\n\n  /** End writing a file. */\n  public boolean writer__endFile() throws Exception {\n    boolean endOK = true;\n\n    String fileName = _getFullFileName();\n    String filePath \n      = writer__iOutputFolder\n      + \"$<\\jostraca.system.fileSeparator>\"\n      + fileName\n      ;\n\n    if( writer__iBackup ) {\n      try {\n        writer__backup( filePath, fileName, writer__iBackupFolder );\n\n      } \n      catch( Exception e ) {\n        writer__handleException( writer__UITEXT_UnableToBackupFile \n                                + filePath \n                                + writer__UITEXT_ToBackupFolder\n                                + writer__iBackupFolder\n                                ,e \n                              );\n        endOK = false;\n      }\n    }\n \n    if( endOK && writer__iSave ) {\n      try {\n        writer__save( filePath, writer__iCurrentText.toString() );\n      } \n      catch( Exception e ) {\n        writer__handleException( writer__UITEXT_UnableToSaveFile + filePath, e );\n        endOK = false;\n      }\n    }\n\n    return endOK;\n  }\n\n\n\n  /** Move to next file. */\n  public void writer__nextFile() {\n    writer__iCurrentFileIndex = writer__iCurrentFileIndex + 1;\n  }\n\n\n\n  /** Set defaults from configuration property set. */\n  public void writer__setDefaults() {\n\n    $<{main.FileNameRoot>_setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n    $<{main.FileNamePrefix>_setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n    $<{main.FileNameSuffix>_setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n    $<{main.OutputFolder>_setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n    $<{main.BackupFolder>_setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n    $<{main.BackupPrefix>_setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n    $<{main.BackupSuffix>_setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n    _backup( \"$<lang.TrueString>\".equals( \"$<jostraca.MakeBackup>\" ) );\n\n  }\n\n\n\n  /** Handle exceptions: print an explanation for user. */\n  public void writer__handleException( String rMessage, Exception rException ) throws Exception {\n\n    StringBuffer userMsg = new StringBuffer( 111 );\n\n    userMsg.append( writer__UITEXT_ErrorHeader );\n\n    userMsg.append( writer__describeState() + rMessage + writer__UITEXT_ColonNewLine );\n\n    StringWriter stringWriter = new StringWriter();\n    rException.printStackTrace( new PrintWriter( stringWriter) );\n    userMsg.append( stringWriter.toString() );\n\n    userMsg.append( writer__UITEXT_ErrorFooter );\n\n    throw new Exception( userMsg.toString() );\n  }\n\n\n\n  /** Provide a concise description of the state of the CodeWriter. */\n  public String writer__describeState() {\n    String currentState \n      = writer__UITEXT_CodeWriterState\n      + writer__UITEXT_GetFileIndexEquals    + _getFileIndex() \n      + writer__UITEXT_GetFullFileNameEquals + _getFullFileName()\n      + writer__UITEXT_GetOutputFolderEquals + _getOutputFolder()\n      + writer__UITEXT_NewLine\n      ; \n    return currentState;\n  }\n\n\n\n  /** Save written files to disk. \n   *  @param rFilePath Save location.\n   *  @param rContent  File content.\n   */\n  public void writer__save( String rFilePath, String rContent ) throws Exception {\n    StringReader   sr = new StringReader( rContent );\n    BufferedReader br = new BufferedReader( sr );\n    FileWriter     fw = new FileWriter( rFilePath );\n    BufferedWriter bw = new BufferedWriter( fw );\n\n    String line;\n    while( null != (line = br.readLine()) ) {\n      bw.write( line );\n      bw.newLine();\n    }\n\n    bw.close();\n    br.close();\n\n  }\n\n\n\n  /** Read file from disk.\n   *  @param rFilePath.\n   */\n  public String writer__read( String rFilePath ) throws Exception {\n    File       file       = new File( rFilePath );\n    FileReader in         = new FileReader( file );\n    int        size       = (int) file.length();\n    char[]     data       = new char[size];\n    int        charsRead  = 0;\n\n    while( charsRead < size ) {\n      charsRead += in.read( data, charsRead, size - charsRead );\n    }\n\n    return new String( data );\n  }\n\n\n\n  /** Backup overwritten files, if they exist.\n   *  Backups have the format:\n   *  [YYYYMMDDhhmmss][prefix][filename][suffix]\n   *  @param rFilePath     Full Path of File to backup (including name).\n   *  @param rFileName     Name of File to backup.\n   *  @param rBackupFolder Folder to place backups in.\n   */ \n  public void writer__backup( String rFilePath, String rFileName, String rBackupFolder ) throws Exception {\n\n    File backupFolder = new File( rBackupFolder );\n\n    // check backup folder ( create if necessary )\n    // ...\n\n    if( ! backupFolder.exists() ) {\n      if( ! backupFolder.mkdir() ) {\n        throw new Exception( writer__UITEXT_BackupFolderColon\n                             + backupFolder\n                             + writer__UITEXT_BackupFolderExistFailure );\n      }\n    }\n    if( ! backupFolder.isDirectory() ) {\n      throw new Exception( writer__UITEXT_BackupFolderColon \n                           + backupFolder\n                           + writer__UITEXT_BackupFolderNotAFolder );\n    }\n    if( ! backupFolder.canWrite() ) {\n      throw new Exception( writer__UITEXT_BackupFolderColon\n                           + backupFolder\n                           + writer__UITEXT_BackupFolderNotWritable );\n    }\n\n    // create backup file path\n    Calendar calendar = Calendar.getInstance();\n    String year_yyyy = _align( String.valueOf( calendar.get(Calendar.YEAR) ),         \"0\", 4, 'r' );\n    String month_mm  = _align( String.valueOf( (1+calendar.get(Calendar.MONTH)) ),    \"0\", 2, 'r' );\n    String day_dd    = _align( String.valueOf( calendar.get(Calendar.DAY_OF_MONTH) ), \"0\", 2, 'r' );\n    String hour_hh   = _align( String.valueOf( calendar.get(Calendar.HOUR_OF_DAY) ),  \"0\", 2, 'r' );\n    String minute_mm = _align( String.valueOf( calendar.get(Calendar.MINUTE) ),       \"0\", 2, 'r' );\n    String second_ss = _align( String.valueOf( calendar.get(Calendar.SECOND) ),       \"0\", 2, 'r' );\n    String dateTime       = year_yyyy+month_mm+day_dd+hour_hh+minute_mm+second_ss;\n    String backupFileName = dateTime + writer__iBackupPrefix + rFileName + writer__iBackupSuffix;\n    File   backupFilePath = new File( rBackupFolder, backupFileName );\n    \n    // save backup file\n    File fileToBackup = new File( rFilePath );\n    if( fileToBackup.exists() ) {\n      String fileContents = writer__read( rFilePath );\n      writer__save( backupFilePath.getPath(), fileContents );\n    }\n  }\n\n\n\n  /** Set compile time properties. */\n  public void writer__initProperties() {\n    $<{jostraca.properties.NameValueList>\n    String[] propertyList = new String[] { $<jostraca.properties.NameValueList> };\n    int numProperties = propertyList.length;\n    for( int propI = 0; propI < numProperties; propI += 2 ) {\n      writer__iProperties.put( propertyList[ propI ], propertyList[ propI+1 ] );\n    }\n    writer__iPropertiesInitialised = true;\n    $<}jostraca.properties.NameValueList>\n  }\n\n\n  /* Writer Services >> */\n \n\n\n\n  /* Template Services (File Generation) << */\n\n  /** Set the prefix of the files to be written. \n   *  @param rPrefix Written files prefix.\n   */\n  public void _setFileNamePrefix( String rPrefix ) {\n    if( null == rPrefix ) {\n      return; // ignore\n    }\n    writer__iFileNamePrefix = rPrefix;\n  }\n\n\n\n  /** Get prefix of files to be written. */\n  public String _getFileNamePrefix() {\n    return writer__iFileNamePrefix;\n  }\n\n\n\n  /** Set the suffix of the files to be written. \n   *  @param rSuffix Written files suffix.\n   */\n  public void _setFileNameSuffix( String rSuffix ) {\n    if( null == rSuffix ) {\n      return; // ignore\n    }\n    writer__iFileNameSuffix = rSuffix;\n  }\n\n\n\n  /** Get suffix of files to be written. */\n  public String _getFileNameSuffix() {\n    return writer__iFileNameSuffix;\n  }\n\n\n\n  /** Set the full name of the file to be written. \n   *  Prefix and Suffix are set to empty\n   *  @param rName Full name of the file to write.\n   */\n  public void _setFullFileName( String rName ) {\n    _setFileNamePrefix( \"\" );\n    _setFileNameRoot(   rName );\n    _setFileNameSuffix( \"\" );\n  }\n\n\n\n  /** Get the full name of current file being generated. */\n  public String _getFullFileName() {\n    return _getFileNamePrefix() + _getFileNameRoot() + _getFileNameSuffix();\n  }\n\n\n\n  /** Set the names of the files to be written. \n   *  Prefix and Suffix are set to empty\n   *  @param rName Full name of the file to write.\n   */\n  public void _setFullFileNames( String[] rNames ) {\n    _setFileNamePrefix( \"\" );\n    _setFileNameRoots(  rNames );\n    _setFileNameSuffix( \"\" );\n  }\n\n\n\n  /** Get the full names of the files to be written. */\n  public String[] _getFullFileNames() {\n\n    String[] fileNameRoots  = _getFileNameRoots();\n    int      numFiles       = fileNameRoots.length;\n    String[] fullFileNames  = new String[ numFiles ];\n    String   fileNamePrefix = _getFileNamePrefix();\n    String   fileNameSuffix = _getFileNameSuffix();\n\n    for( int fileI = 0; fileI < numFiles; fileI++ ) {\n      fullFileNames[ fileI ] = fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix;\n    }\n\n    return fullFileNames;\n  }\n\n\n\n  /** Set the root of the name of the file to be written. \n   *  @param rFileNameRoot Root of the name of file to be written.\n   */\n  public void _setFileNameRoot( String rFileNameRoot ) {\n    if( null == rFileNameRoot ) {\n      return; // ignore\n    }\n    _setFileNameRoots( new String[] { rFileNameRoot } );\n  }\n\n\n\n  /** Get the root of the name of current file being generated. */\n  public String _getFileNameRoot() {\n    if( 0 < writer__iFileNameRoots.length ) {\n      return writer__iFileNameRoots[ writer__iCurrentFileIndex ];\n    }\n    return \"\";\n  }\n\n\n\n  /** Set the roots of the names of the files to be written. \n   *  @param rFileNameRoots Roots of names of files to be written.\n   */\n  public void _setFileNameRoots( String[] rFileNameRoots ) {\n    if( null == rFileNameRoots ) {\n      return; // ignore\n    }\n\n    // copy\n    String[] roots = (String[]) rFileNameRoots.clone();\n\n    // normalize - replace nulls\n    int numRoots = roots.length;\n    for(int rootI = 0; rootI < numRoots; rootI++) {\n      if( null == roots[ rootI ] ) {\n        roots[ rootI ] = \"\";\n      }\n    }\n\n    // save roots\n    writer__iFileNameRoots = roots;\n    writer__iNumFiles      = numRoots;\n  }\n\n\n\n  /** Get roots of the names of files to be written. */\n  public String[] _getFileNameRoots() {\n    return writer__iFileNameRoots;\n  }\n\n\n\n  /** Get index of file currently being generated. */\n  public int _getFileIndex() {\n    return writer__iCurrentFileIndex;\n  }\n\n\n\n  /** Get number of generated files. */\n  public int _getNumFiles() {\n    return writer__iNumFiles;\n  }\n\n\n\n  /** Set output folder.\n   *  @param rOutputFolder Folder to output generated code to.\n   */\n  public void _setOutputFolder( String rOutputFolder ) {\n    writer__iOutputFolder = rOutputFolder;\n  }\n\n\n\n  /** Get output folder. */\n  public String _getOutputFolder() {\n    return writer__iOutputFolder;\n  }\n\n\n\n  /** Set backup folder.\n   *  @param rBackupFolder Folder to backup overwritten files to.\n   */\n  public void _setBackupFolder( String rBackupFolder ) {\n    writer__iBackupFolder = writer__iOutputFolder + \"$<\\jostraca.system.fileSeparator>\" + rBackupFolder;\n  }\n\n\n\n  /** Get backup folder. */\n  public String _getBackupFolder() {\n    return writer__iBackupFolder;\n  }\n\n\n\n  /** Set the suffix of backup files.\n   *  @param rSuffix Backup files suffix.\n   */\n  public void _setBackupSuffix( String rSuffix ) {\n    if( null == rSuffix ) {\n      return; // ignore\n    }\n    writer__iBackupSuffix = rSuffix;\n  }\n\n\n\n  /** Set the prefix of backup files.\n   *  @param rPrefix Backup files prefix.\n   */\n  public void _setBackupPrefix( String rPrefix ) {\n    if( null == rPrefix ) {\n      return; // ignore\n    }\n    writer__iBackupPrefix = rPrefix;\n  }\n\n\n\n  /** Set to true if written files are to be backed up to disk automatically. \n   *  @param rBackup True => Backup files to disk.\n   */\n  public void _backup( boolean rBackup ) {\n    writer__iBackup = rBackup;\n  }\n\n\n\n  /** Set to true if written files are to be saved to disk automatically. \n   *  @param rSave True => Save written files to disk.\n   */\n  public void _save( boolean rSave ) {\n    writer__iSave = rSave;\n  }\n\n\n  /* Template Services (File Generation) >> */\n\n\n\n\n  /* Template Services (Control) << */\n\n  /** Get compile time property\n   *  @param rName Name of property to get.\n   */\n  public String _getProperty( String rName ) {\n    String result = \"\";\n\n    if( ! writer__iPropertiesInitialised ) {\n      writer__initProperties();\n    }\n\n    if( writer__iProperties.containsKey( rName ) ) {\n      result = (String) writer__iProperties.get( rName );\n    }\n\n    return result;\n  }\n\n  /* Template Services (Control) >> */\n\n\n\n  /* Template Services (Text Production) << */\n\n\n  // inserts\n  // ...\n\n  /** Insert text into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rText Text to insert.\n   */\n  public void _insert( String rText ) {\n    writer__iCurrentText.append( rText );\n  }\n\n  /** Insert string representation of object into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rObject Object to insert.\n   */\n  public void _insert( Object rObject ) {\n    writer__iCurrentText.append( \"\"+rObject );\n  }\n\n  /** Insert string representation of primitive data type into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rInt int to insert\n   */\n  public void _insert( int rInt ) {\n    writer__iCurrentText.append( rInt );\n  }\n\n  /** Insert string representation of primitive data type into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rLong long to insert\n   */\n  public void _insert( long rLong ) {\n    writer__iCurrentText.append( rLong );\n  }\n\n  /** Insert string representation of primitive data type into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rShort short to insert\n   */\n  public void _insert( short rShort ) {\n    writer__iCurrentText.append( rShort );\n  }\n\n  /** Insert string representation of primitive data type into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rByte byte to insert\n   */\n  public void _insert( byte rByte ) {\n    writer__iCurrentText.append( rByte );\n  }\n\n  /** Insert string representation of primitive data type into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rDouble double to insert\n   */\n  public void _insert( double rDouble ) {\n    writer__iCurrentText.append( rDouble );\n  }\n\n  /** Insert string representation of primitive data type into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rFloat float to insert\n   */\n  public void _insert( float rFloat ) {\n    writer__iCurrentText.append( rFloat );\n  }\n\n  /** Insert string representation of primitive data type into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rChar char to insert\n   */\n  public void _insert( char rChar ) {\n    writer__iCurrentText.append( rChar );\n  }\n\n  /** Insert string representation of primitive data type into written file. \n   *  Abbreviated by <%=foobar%>. \n   *  @param rBoolean boolean to insert\n   */\n  public void _insert( boolean rBoolean ) {\n    writer__iCurrentText.append( rBoolean );\n  }\n\n\n\n  /** Create a String containing specified number of spaces.\n   *  @param rNumSpaces Number of spaces to place in String\n   */\n  public String _spaces( int rNumSpaces ) {\n    int numSpaces = rNumSpaces;\n    if( 0 > numSpaces ) { numSpaces *= -1; }\n    StringBuffer spaces = new StringBuffer( numSpaces );\n    for(int spaceI = 0; spaceI < numSpaces; spaceI++) {\n      spaces.append(\" \");\n    }\n    return spaces.toString();\n  }\n\n\n\n  /** Left align String with spaces. */ \n  public String _left( String rText, int rColWidth ) {\n    return _align( rText, \" \", rColWidth, 'l' );\n  } \n\n\n\n  /** Right align String with spaces. */ \n  public String _right( String rText, int rColWidth ) {\n    return _align( rText, \" \", rColWidth, 'r' );\n  } \n\n\n\n  /** Center align String with spaces. */ \n  public String _center( String rText, int rColWidth ) {\n    return _align( rText, \" \", rColWidth, 'c' );\n  } \n\n\n\n  /** Align text within background text to specified column width. \n   *  Alignment can be 'l': left, 'c': center, 'r': right\n   */\n  public String _align( String rText, String rBackText, int rColWidth, char rAlignment ) {\n    String result = rText;\n \n    if( null == rText ) { \n       result = \"\"; \n    }\n    else if( null != rBackText ) {\n      try {\n        int textLen = rText.length();\n        if( rColWidth > textLen ) {\n          int    backTextLen     = rBackText.length();\n          int    remainWidth     = rColWidth - textLen;\n          int    backTextRepeats = remainWidth / backTextLen;\n          int    backTextRemain  = remainWidth % backTextLen;\n          String back            = \"\";\n          for( int backTextI = 0; backTextI < backTextRepeats; backTextI++ ) {\n            back = back + rBackText;\n          }\n          back = back + rBackText.substring( 0, backTextRemain );\n \n          switch( rAlignment ) {\n          case 'l':\n            result = result + back;\n            break;\n          case 'c':\n            result = back.substring( 0, (back.length()/2) ) + result + back.substring( (back.length()/2) );\n            break;\n          case 'r':\n            result = back + result;\n            break;\n          }\n        }\n      } \n      catch( Exception e ) {\n        result = rText;\n      }\n    }\n    return result;\n  }\n\n\n\n  /** Set current text of file currently being generated. */\n  public void _setText( String rText) {\n    writer__iCurrentText = new StringBuffer( rText );\n  }\n\n\n\n  /** Get current text of file currently being generated. */\n  public String _getText() {\n    return writer__iCurrentText.toString();\n  }\n\n  /* Template Services (Text Production) << */\n\n}\n\n\n!<footer>\n");
    }
}
