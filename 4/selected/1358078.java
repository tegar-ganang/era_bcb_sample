package org.ozoneDB.xml.dom;

import java.io.*;
import org.ozoneDB.*;
import org.ozoneDB.xml.dom.iterator.*;
import org.w3c.dom.*;

public abstract class NodeImpl extends OzoneObject implements NodeProxy, Externalizable {

    static final long serialVersionUID = 1;

    /**
     * Returns a duplicate of this node, i.e., serves as a generic copy
     * constructor for nodes. The duplicate node has no parent (
     * <code>parentNode</code> is <code>null</code>) and no user data. User
     * data associated to the imported node is not carried over. However, if
     * any <code>UserDataHandlers</code> has been specified along with the
     * associated data these handlers will be called with the appropriate
     * parameters before this method returns.
     * <br>Cloning an <code>Element</code> copies all attributes and their
     * values, including those generated by the XML processor to represent
     * defaulted attributes, but this method does not copy any children it
     * contains unless it is a deep clone. This includes text contained in
     * an the <code>Element</code> since the text is contained in a child
     * <code>Text</code> node. Cloning an <code>Attr</code> directly, as
     * opposed to be cloned as part of an <code>Element</code> cloning
     * operation, returns a specified attribute (<code>specified</code> is
     * <code>true</code>). Cloning an <code>Attr</code> always clones its
     * children, since they represent its value, no matter whether this is a
     * deep clone or not. Cloning an <code>EntityReference</code>
     * automatically constructs its subtree if a corresponding
     * <code>Entity</code> is available, no matter whether this is a deep
     * clone or not. Cloning any other type of node simply returns a copy of
     * this node.
     * <br>Note that cloning an immutable subtree results in a mutable copy,
     * but the children of an <code>EntityReference</code> clone are readonly
     * . In addition, clones of unspecified <code>Attr</code> nodes are
     * specified. And, cloning <code>Document</code>,
     * <code>DocumentType</code>, <code>Entity</code>, and
     * <code>Notation</code> nodes is implementation dependent.
     *
     * @param deep If <code>true</code>, recursively clone the subtree under
     *             the specified node; if <code>false</code>, clone only the node
     *             itself (and its attributes, if it is an <code>Element</code>).
     * @return The duplicate node.
     */
    public Node cloneNode(boolean deep) {
        return null;
    }

    /**
     * The absolute base URI of this node or <code>null</code> if the
     * implementation wasn't able to obtain an absolute URI. This value is
     * computed as described in . However, when the <code>Document</code>
     * supports the feature "HTML" [<a href='http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109'>DOM Level 2 HTML</a>]
     * , the base URI is computed using first the value of the href
     * attribute of the HTML BASE element if any, and the value of the
     * <code>documentURI</code> attribute from the <code>Document</code>
     * interface otherwise.
     *
     * @since DOM Level 3
     */
    public String getBaseURI() {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".getBaseURI(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * Compares the reference node, i.e. the node on which this method is
     * being called, with a node, i.e. the one passed as a parameter, with
     * regard to their position in the document and according to the
     * document order.
     *
     * @param other The node to compare against the reference node.
     * @return Returns how the node is positioned relatively to the reference
     *         node.
     * @throws org.w3c.dom.DOMException NOT_SUPPORTED_ERR: when the compared nodes are from different DOM
     *                                  implementations that do not coordinate to return consistent
     *                                  implementation-specific results.
     * @since DOM Level 3
     */
    public short compareDocumentPosition(Node other) throws DOMException {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".compareDocumentPosition(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * This attribute returns the text content of this node and its
     * descendants. When it is defined to be <code>null</code>, setting it
     * has no effect. On setting, any possible children this node may have
     * are removed and, if it the new string is not empty or
     * <code>null</code>, replaced by a single <code>Text</code> node
     * containing the string this attribute is set to.
     * <br> On getting, no serialization is performed, the returned string
     * does not contain any markup. No whitespace normalization is performed
     * and the returned string does not contain the white spaces in element
     * content (see the attribute
     * <code>Text.isElementContentWhitespace</code>). Similarly, on setting,
     * no parsing is performed either, the input string is taken as pure
     * textual content.
     * <br>The string returned is made of the text content of this node
     * depending on its type, as defined below:
     * <table border='1' cellpadding='3'>
     * <tr>
     * <th>Node type</th>
     * <th>Content</th>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>
     * ELEMENT_NODE, ATTRIBUTE_NODE, ENTITY_NODE, ENTITY_REFERENCE_NODE,
     * DOCUMENT_FRAGMENT_NODE</td>
     * <td valign='top' rowspan='1' colspan='1'>concatenation of the <code>textContent</code>
     * attribute value of every child node, excluding COMMENT_NODE and
     * PROCESSING_INSTRUCTION_NODE nodes. This is the empty string if the
     * node has no children.</td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE,
     * PROCESSING_INSTRUCTION_NODE</td>
     * <td valign='top' rowspan='1' colspan='1'><code>nodeValue</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>DOCUMENT_NODE,
     * DOCUMENT_TYPE_NODE, NOTATION_NODE</td>
     * <td valign='top' rowspan='1' colspan='1'><em>null</em></td>
     * </tr>
     * </table>
     *
     * @throws org.w3c.dom.DOMException DOMSTRING_SIZE_ERR: Raised when it would return more characters than
     *                                  fit in a <code>DOMString</code> variable on the implementation
     *                                  platform.
     * @since DOM Level 3
     */
    public String getTextContent() throws DOMException {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".getTextContent(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * This attribute returns the text content of this node and its
     * descendants. When it is defined to be <code>null</code>, setting it
     * has no effect. On setting, any possible children this node may have
     * are removed and, if it the new string is not empty or
     * <code>null</code>, replaced by a single <code>Text</code> node
     * containing the string this attribute is set to.
     * <br> On getting, no serialization is performed, the returned string
     * does not contain any markup. No whitespace normalization is performed
     * and the returned string does not contain the white spaces in element
     * content (see the attribute
     * <code>Text.isElementContentWhitespace</code>). Similarly, on setting,
     * no parsing is performed either, the input string is taken as pure
     * textual content.
     * <br>The string returned is made of the text content of this node
     * depending on its type, as defined below:
     * <table border='1' cellpadding='3'>
     * <tr>
     * <th>Node type</th>
     * <th>Content</th>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>
     * ELEMENT_NODE, ATTRIBUTE_NODE, ENTITY_NODE, ENTITY_REFERENCE_NODE,
     * DOCUMENT_FRAGMENT_NODE</td>
     * <td valign='top' rowspan='1' colspan='1'>concatenation of the <code>textContent</code>
     * attribute value of every child node, excluding COMMENT_NODE and
     * PROCESSING_INSTRUCTION_NODE nodes. This is the empty string if the
     * node has no children.</td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE,
     * PROCESSING_INSTRUCTION_NODE</td>
     * <td valign='top' rowspan='1' colspan='1'><code>nodeValue</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>DOCUMENT_NODE,
     * DOCUMENT_TYPE_NODE, NOTATION_NODE</td>
     * <td valign='top' rowspan='1' colspan='1'><em>null</em></td>
     * </tr>
     * </table>
     *
     * @throws org.w3c.dom.DOMException NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
     * @since DOM Level 3
     */
    public void setTextContent(String textContent) throws DOMException {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".setTextContent(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * Returns whether this node is the same node as the given one.
     * <br>This method provides a way to determine whether two
     * <code>Node</code> references returned by the implementation reference
     * the same object. When two <code>Node</code> references are references
     * to the same object, even if through a proxy, the references may be
     * used completely interchangeably, such that all attributes have the
     * same values and calling the same DOM method on either reference
     * always has exactly the same effect.
     *
     * @param other The node to test against.
     * @return Returns <code>true</code> if the nodes are the same,
     *         <code>false</code> otherwise.
     * @since DOM Level 3
     */
    public boolean isSameNode(Node other) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".isSameNode(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * Look up the prefix associated to the given namespace URI, starting from
     * this node. The default namespace declarations are ignored by this
     * method.
     * <br>See  for details on the algorithm used by this method.
     *
     * @param namespaceURI The namespace URI to look for.
     * @return Returns an associated namespace prefix if found or
     *         <code>null</code> if none is found. If more than one prefix are
     *         associated to the namespace prefix, the returned namespace prefix
     *         is implementation dependent.
     * @since DOM Level 3
     */
    public String lookupPrefix(String namespaceURI) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".lookupPrefix(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * This method checks if the specified <code>namespaceURI</code> is the
     * default namespace or not.
     *
     * @param namespaceURI The namespace URI to look for.
     * @return Returns <code>true</code> if the specified
     *         <code>namespaceURI</code> is the default namespace,
     *         <code>false</code> otherwise.
     * @since DOM Level 3
     */
    public boolean isDefaultNamespace(String namespaceURI) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".isDefaultNamespace(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * Look up the namespace URI associated to the given prefix, starting from
     * this node.
     * <br>See  for details on the algorithm used by this method.
     *
     * @param prefix The prefix to look for. If this parameter is
     *               <code>null</code>, the method will return the default namespace URI
     *               if any.
     * @return Returns the associated namespace URI or <code>null</code> if
     *         none is found.
     * @since DOM Level 3
     */
    public String lookupNamespaceURI(String prefix) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".lookupNamespaceURI(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * Tests whether two nodes are equal.
     * <br>This method tests for equality of nodes, not sameness (i.e.,
     * whether the two nodes are references to the same object) which can be
     * tested with <code>Node.isSameNode()</code>. All nodes that are the
     * same will also be equal, though the reverse may not be true.
     * <br>Two nodes are equal if and only if the following conditions are
     * satisfied:
     * <ul>
     * <li>The two nodes are of the same type.
     * </li>
     * <li>The following string
     * attributes are equal: <code>nodeName</code>, <code>localName</code>,
     * <code>namespaceURI</code>, <code>prefix</code>, <code>nodeValue</code>
     * . This is: they are both <code>null</code>, or they have the same
     * length and are character for character identical.
     * </li>
     * <li>The
     * <code>attributes</code> <code>NamedNodeMaps</code> are equal. This
     * is: they are both <code>null</code>, or they have the same length and
     * for each node that exists in one map there is a node that exists in
     * the other map and is equal, although not necessarily at the same
     * index.
     * </li>
     * <li>The <code>childNodes</code> <code>NodeLists</code> are equal.
     * This is: they are both <code>null</code>, or they have the same
     * length and contain equal nodes at the same index. Note that
     * normalization can affect equality; to avoid this, nodes should be
     * normalized before being compared.
     * </li>
     * </ul>
     * <br>For two <code>DocumentType</code> nodes to be equal, the following
     * conditions must also be satisfied:
     * <ul>
     * <li>The following string attributes
     * are equal: <code>publicId</code>, <code>systemId</code>,
     * <code>internalSubset</code>.
     * </li>
     * <li>The <code>entities</code>
     * <code>NamedNodeMaps</code> are equal.
     * </li>
     * <li>The <code>notations</code>
     * <code>NamedNodeMaps</code> are equal.
     * </li>
     * </ul>
     * <br>On the other hand, the following do not affect equality: the
     * <code>ownerDocument</code>, <code>baseURI</code>, and
     * <code>parentNode</code> attributes, the <code>specified</code>
     * attribute for <code>Attr</code> nodes, the <code>schemaTypeInfo</code>
     * attribute for <code>Attr</code> and <code>Element</code> nodes, the
     * <code>Text.isElementContentWhitespace</code> attribute for
     * <code>Text</code> nodes, as well as any user data or event listeners
     * registered on the nodes.
     * <p ><b>Note:</b>  As a general rule, anything not mentioned in the
     * description above is not significant in consideration of equality
     * checking. Note that future versions of this specification may take
     * into account more attributes and implementations conform to this
     * specification are expected to be updated accordingly.
     *
     * @param arg The node to compare equality with.
     * @return Returns <code>true</code> if the nodes are equal,
     *         <code>false</code> otherwise.
     * @since DOM Level 3
     */
    public boolean isEqualNode(Node arg) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".isEqualNode(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * This method returns a specialized object which implements the
     * specialized APIs of the specified feature and version, as specified
     * in . The specialized object may also be obtained by using
     * binding-specific casting methods but is not necessarily expected to,
     * as discussed in . This method also allow the implementation to
     * provide specialized objects which do not support the <code>Node</code>
     * interface.
     *
     * @param feature The name of the feature requested. Note that any plus
     *                sign "+" prepended to the name of the feature will be ignored since
     *                it is not significant in the context of this method.
     * @param version This is the version number of the feature to test.
     * @return Returns an object which implements the specialized APIs of
     *         the specified feature and version, if any, or <code>null</code> if
     *         there is no object which implements interfaces associated with that
     *         feature. If the <code>DOMObject</code> returned by this method
     *         implements the <code>Node</code> interface, it must delegate to the
     *         primary core <code>Node</code> and not return results inconsistent
     *         with the primary core <code>Node</code> such as attributes,
     *         childNodes, etc.
     * @since DOM Level 3
     */
    public Object getFeature(String feature, String version) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".getFeature(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * Associate an object to a key on this node. The object can later be
     * retrieved from this node by calling <code>getUserData</code> with the
     * same key.
     *
     * @param key     The key to associate the object to.
     * @param data    The object to associate to the given key, or
     *                <code>null</code> to remove any existing association to that key.
     * @param handler The handler to associate to that key, or
     *                <code>null</code>.
     * @return Returns the <code>DOMUserData</code> previously associated to
     *         the given key on this node, or <code>null</code> if there was none.
     * @since DOM Level 3
     */
    public Object setUserData(String key, Object data, UserDataHandler handler) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".setUserData(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    /**
     * Retrieves the object associated to a key on a this node. The object
     * must first have been set to this node by calling
     * <code>setUserData</code> with the same key.
     *
     * @param key The key the object is associated to.
     * @return Returns the <code>DOMUserData</code> associated to the given
     *         key on this node, or <code>null</code> if there was none.
     * @since DOM Level 3
     */
    public Object getUserData(String key) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, this.getClass() + ".getUserData(): ozone's persistent DOM doesn't support DOM level 3 yet.");
    }

    public boolean supports(java.lang.String feature, java.lang.String version) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, "Node.supports(): ozone's persistent DOM doesn't support DOM level 2 yet.");
    }

    public void normalize() {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, "Node.normalize(): ozone's persistent DOM doesn't support DOM level 2 yet.");
    }

    public java.lang.String getNamespaceURI() {
        return null;
    }

    public java.lang.String getPrefix() {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, "Node.getPrefix(): ozone's persistent DOM doesn't support DOM level 2 yet.");
    }

    public void setPrefix(java.lang.String prefix) throws DOMException {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, "Node.setPrefix(): ozone's persistent DOM doesn't support DOM level 2 yet.");
    }

    public java.lang.String getLocalName() {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, "Node.getLocalName(): ozone's persistent DOM doesn't support DOM level 2 yet.");
    }

    /**
     * Abstract method must be implemented by each node class.
     *
     * @see org.w3c.dom.Node#getNodeType
     */
    public abstract short getNodeType();

    /**
     * Returns the name of the node, set from the constructor. Some derived classes
     * do not have the notion of a name, and will return the same name each time.
     * They should do so by setting the default name (e.g. <TT>"#comment"</TT>)
     * in the constructor. This value is never null.
     *
     * @see org.w3c.dom.Node#getNodeName
     */
    public final String getNodeName() {
        return _nodeName;
    }

    /**
     */
    public final void setNodeName(String nodeName) {
        _nodeName = nodeName;
    }

    /**
     * Returns the value of the node. Depending on the node type, this value
     * is either the node value (e.g. the text in {@link org.w3c.dom.Text}),
     * or always null is node has no notion of a value (e.g. {@link
     * org.w3c.dom.Element}). For complete list of which node types will return
     * what, see {@link #setNodeValue}.
     *
     * @return Value of node, null if node has no value
     */
    public final String getNodeValue() {
        return _nodeValue;
    }

    /**
     * Changes the value of the node. Not all node types support the notion of
     * a value. If the value is not supported by a particular node type, it will
     * throw an exception when calling this method. The following table specifies
     * which node types support values:
     * <PRE>
     * Element                  Not supported
     * Attr                     Value supported
     * Text                     Value supported
     * CDATASection             Value supported
     * EntityReference          Not supported
     * Entity                   Not supported
     * ProcessingInstruction    Value supported
     * Comment                  Value supported
     * Document                 Not supported
     * DocumentType             Not supported
     * DocumentFragment         Not supported
     * Notation                 Not supported
     * </PRE>
     * For most node types, if the value is set to null, {@link #getNodeValue}
     * will return an empty string instead.
     *
     * @param value New value of node
     * @throws org.w3c.dom.DOMException <TT>NO_MODIFICATION_ALLOWED_ERR</TT>
     *  Node is read-only and cannot be modified
     * @throws org.w3c.dom.DOMException <TT>NO_DATA_ALLOWED_ERR</TT>
     *  This node does not support a value
     */
    public void setNodeValue(String value) {
        if (isReadOnly()) {
            throw new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR);
        }
        _nodeValue = value == null ? "" : value;
    }

    /**
     * Returns the parent node of this node. Node may not necessarily have a
     * parent node. If node has been created but not added to any other node,
     * it will be parentless. The {@link org.w3c.dom.Document} node is always
     * parentless.
     *
     * @return Parent node of this node
     */
    public Node getParentNode() {
        return _parent;
    }

    /**
     */
    public void setParentNode(Node newParent) {
        _parent = (NodeProxy) newParent;
    }

    /**
     * Called to notify all the iterators created from this node that a
     * child of this node has been removed. Iterators that point at this
     * child might choose to select another child to point to. This method
     * is called before the child is removed.
     * <P>
     * The removed node is a direct child of this node. Affected iterators
     * are those that point at the document tree directly below this node,
     * or the tree below one of its parents. Other iterators are not affected
     * by the change. This method also performs a notification on all the
     * parents of this node.
     *
     * @param removedChild The child node being removed
     */
    protected void notifyIterators(Node removedChild) {
    }

    /**
     * Returns a {@link org.w3c.dom.NodeList} object that can be used to traverse
     * this node's children. The node list is live, so every change to this node
     * is reflected in it.
     * <P>
     * If children are not supported by the derived class, an exception is thrown.
     *
     * @return {@link org.w3c.dom.NodeList} on this node
     * @throws org.w3c.dom.DOMException HIERARCHY_REQUEST_ERR Childern not supported
     *  by this node type
     * @see org.w3c.dom.NodeList
     * @see NodeListImpl
     */
    public NodeList getChildNodes() {
        if (!supportsChildern()) {
            throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, "No childern supported by this node type.");
        }
        return new org.ozoneDB.xml.dom.NodeListImpl(this);
    }

    /**
     * Returns the first child of the node. If node has no children, returns null.
     *
     * @return First child or null
     */
    public final Node getFirstChild() {
        return _firstChild;
    }

    /**
     * Returns the last child of the node. If node has no children, returns null.
     *
     * @return Last child or null
     */
    public final Node getLastChild() {
        return _lastChild;
    }

    /**
     * Returns the previous sibling of this node. If node has no previous siblings,
     * returns null.
     *
     * @return Previous sibling or null
     */
    public Node getPreviousSibling() {
        return _prevNode;
    }

    /**
     */
    public void setPreviousSibling(Node prevNode) {
        _prevNode = (NodeProxy) prevNode;
    }

    /**
     * Returns the next sibling of this node. If node has no next siblings,
     * returns null.
     *
     * @return Next sibling or null
     */
    public Node getNextSibling() {
        return _nextNode;
    }

    /**
     */
    public void setNextSibling(Node nextNode) {
        _nextNode = (NodeProxy) nextNode;
    }

    /**
     * Return attributes of node. Returns null unless node is of type {@link
     * org.w3c.dom.Element}, in which case the returned {@link
     * org.w3c.dom.NamedNodeMap} will provide access to all the element's
     * attributes.
     *
     * @return Attributes of node or null
     */
    public NamedNodeMap getAttributes() {
        return null;
    }

    public boolean hasAttributes() {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, "ozone's persistent DOM doesn't support DOM level 2 yet.");
    }

    public final Document getOwnerDocument() {
        if (_ownerDocument != this) {
            return _ownerDocument;
        } else {
            return null;
        }
    }

    /**
     * Return true if there are any childern to this node. Less intensive than
     * calling {#link getChildNodes}.
     *
     * @return True if node has any children
     */
    public final boolean hasChildNodes() {
        return _firstChild != null;
    }

    /**
     * Insert <TT>newChild</TT> as the last child of this parent.
     * <P>
     * If <TT>newChild</TT> is null, <TT>newChild</TT> does not belong to this DOM,
     * or childern are not supported by this node type, an exception is thrown.
     * <P>
     * <TT>newChild</TT> is removed from its original parent before adding to this
     * parent. If <TT>newChild</TT> is a {@link org.w3c.dom.DocumentFragment}, all
     * its children are inserted one by one into this parent.
     *
     * @param newChild The new child to add
     * @return The newly inserted child
     * @throws org.w3c.dom.DOMException <TT>NO_MODIFICATION_ALLOWED_ERR</TT>
     *  Node is read-only and cannot be modified
     * @throws org.w3c.dom.DOMException <TT>HIERARCHY_REQUEST_ERR</TT>
     *  Children are not supported by this node type, or <TT>newChild</TT> is not
     *  a compatible type for this node
     * @see #castNewChild
     * @see #castOldChild
     */
    public final synchronized Node appendChild(Node newChild) {
        NodeProxy newChildX;
        if (isReadOnly()) {
            throw new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR);
        }
        if (!supportsChildern()) {
            throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, "No childern supported by this node type.");
        }
        newChildX = (NodeProxy) castNewChild(newChild);
        synchronized (newChild) {
            if (newChildX.getParentNode() != null) {
                if (((NodeProxy) newChildX.getParentNode()).isReadOnly()) {
                    throw new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR);
                }
                newChildX.getParentNode().removeChild(newChildX);
            }
            if (newChildX instanceof DocumentFragment) {
                NodeProxy nextChild;
                newChildX = (NodeProxy) newChildX.getFirstChild();
                while (newChildX != null) {
                    nextChild = (NodeProxy) newChildX.getNextSibling();
                    appendChild(newChildX);
                    newChildX = nextChild;
                }
                return newChild;
            }
            newChildX.setParentNode(this);
            if (_ownerDocument != null) {
                newChildX.setOwnerDocument(_ownerDocument);
            }
            if (_lastChild == null) {
                _lastChild = newChildX;
                _firstChild = newChildX;
                newChildX.setPreviousSibling(null);
                newChildX.setNextSibling(null);
            } else {
                _lastChild.setNextSibling(newChildX);
                newChildX.setPreviousSibling(_lastChild);
                newChildX.setNextSibling(null);
                _lastChild = newChildX;
            }
            ++_childsCount;
        }
        return newChild;
    }

    /**
     * Remove <TT>oldChild</TT> from this parent. If <TT>oldChild</TT> is not
     * a direct child of this parent, or childern are not supported by this node
     * type, an exception is thrown.
     *
     * @param oldChild The child to remove
     * @return The removed child
     * @throws org.w3c.dom.DOMException <TT>NO_MODIFICATION_ALLOWED_ERR</TT>
     *  Node is read-only and cannot be modified
     * @throws org.w3c.dom.DOMException <TT>HIERARCHY_REQUEST_ERR</TT>
     *  Children are not supported by this node type
     * @throws org.w3c.dom.DOMException <TT>NOT_FOUND_ERR</TT>
     *  <TT>oldChild</TT> is not a direct child of this node
     * @see #castOldChild
     */
    public final synchronized Node removeChild(Node oldChild) throws DOMException {
        NodeProxy oldChildX;
        if (isReadOnly()) {
            throw new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR);
        }
        if (!supportsChildern()) {
            throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, "No childern supported by this node type.");
        }
        oldChildX = (NodeProxy) castOldChild(oldChild);
        synchronized (oldChild) {
            notifyIterators(oldChild);
            oldChildX.setParentNode(null);
            if (_firstChild != null && _firstChild.equals(oldChildX)) {
                _firstChild = (NodeProxy) oldChildX.getNextSibling();
            }
            if (_lastChild != null && _lastChild.equals(oldChildX)) {
                _lastChild = (NodeProxy) oldChildX.getPreviousSibling();
            }
            if (oldChildX.getPreviousSibling() != null) {
                ((NodeProxy) oldChildX.getPreviousSibling()).setNextSibling(oldChildX.getNextSibling());
            }
            if (oldChildX.getNextSibling() != null) {
                ((NodeProxy) oldChildX.getNextSibling()).setPreviousSibling(oldChildX.getPreviousSibling());
            }
            oldChildX.setPreviousSibling(null);
            oldChildX.setNextSibling(null);
            --_childsCount;
        }
        return oldChild;
    }

    /**
     * Replace <TT>oldChild</TT> with <TT>newChild</TT>, adding the new child and
     * removing the old one.
     * <P>
     * If <TT>newChild</TT> does not belong to this DOM, <TT>oldChild</TT> is not
     * a direct child of this parent, or childern are not supported by this node
     * type, an exception is thrown.
     * <P>
     * <TT>newChild</TT> is removed from its original parent before adding to this
     * parent. If <TT>newChild</TT> is a {@link org.w3c.dom.DocumentFragment}, all
     * its children are inserted one by one into this parent.
     *
     * @param newChild The new child to add
     * @param oldChild The old child to take away
     * @return The old child
     * @throws org.w3c.dom.DOMException <TT>NO_MODIFICATION_ALLOWED_ERR</TT>
     *  Node is read-only and cannot be modified
     * @throws org.w3c.dom.DOMException <TT>HIERARCHY_REQUEST_ERR</TT>
     *  Children are not supported by this node type, or <TT>newChild</TT> is not
     *  a compatible type for this node
     * @throws org.w3c.dom.DOMException <TT>NOT_FOUND_ERR</TT>
     *  <TT>oldChild</TT> is not a direct child of this node
     * @see #castNewChild
     * @see #castOldChild
     */
    public final synchronized Node replaceChild(Node newChild, Node oldChild) throws DOMException {
        NodeProxy newChildX;
        NodeProxy oldChildX;
        if (isReadOnly()) {
            throw new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR);
        }
        if (!supportsChildern()) {
            throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, "No childern supported by this node type.");
        }
        if (newChild != null) {
            newChildX = (NodeProxy) castNewChild(newChild);
        }
        oldChildX = (NodeProxy) castOldChild(oldChild);
        synchronized (oldChild) {
            if (newChild != null) {
                synchronized (newChild) {
                    insertBefore(newChild, oldChild);
                    removeChild(oldChild);
                }
            } else {
                removeChild(oldChild);
            }
        }
        return oldChild;
    }

    /**
     * Insert <TT>newChild</TT> in this parent, before the existing child
     * <TT>refChild</TT>. If <TT>refChild</TT> is null, insert <TT>newChild</TT>
     * as the last child of this parent, akin to calling {@link #appendChild}.
     * <P>
     * If <TT>newChild</TT> is null, <TT>newChild</TT> does not belong to this DOM,
     * <TT>refChild</TT> is not a direct child of this node, or childern are not
     * supported by this node type, an exception is thrown.
     * <P>
     * <TT>newChild</TT> is removed from its original parent before adding to this
     * parent. If <TT>newChild</TT> is a {@link org.w3c.dom.DocumentFragment}, all
     * its children are inserted one by one into this parent.
     *
     * @param newChild The new child to add
     * @param refChild Insert new child before this child, or insert at the end
     *  if this child is null
     * @return The newly inserted child
     * @throws org.w3c.dom.DOMException <TT>NO_MODIFICATION_ALLOWED_ERR</TT>
     *  Node is read-only and cannot be modified
     * @throws org.w3c.dom.DOMException <TT>HIERARCHY_REQUEST_ERR</TT>
     *  Children are not supported by this node type, or <TT>newChild</TT> is not
     *  a compatible type for this node
     * @throws org.w3c.dom.DOMException <TT>NOT_FOUND_ERR</TT>
     *  <TT>oldChild</TT> is not null and not a direct child of this node
     * @see #castNewChild
     * @see #castOldChild
     */
    public final synchronized Node insertBefore(Node newChild, Node refChild) throws DOMException {
        NodeProxy newChildX;
        NodeProxy refChildX;
        if (isReadOnly()) {
            throw new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR);
        }
        if (!supportsChildern()) {
            throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, "No childern supported by this node type.");
        }
        if (refChild == null) {
            return appendChild(newChild);
        }
        newChildX = (NodeProxy) castNewChild(newChild);
        refChildX = (NodeProxy) castOldChild(refChild);
        synchronized (newChild) {
            synchronized (refChild) {
                if (newChildX.getParentNode() != null) {
                    if (((NodeProxy) newChildX.getParentNode()).isReadOnly()) {
                        throw new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR);
                    }
                    newChildX.getParentNode().removeChild(newChildX);
                }
                if (newChildX instanceof DocumentFragment) {
                    NodeProxy nextChild;
                    newChildX = (NodeProxy) newChildX.getFirstChild();
                    while (newChildX != null) {
                        nextChild = (NodeProxy) newChildX.getNextSibling();
                        insertBefore(newChildX, refChild);
                        newChildX = nextChild;
                    }
                    return newChild;
                }
                newChildX.setParentNode(this);
                newChildX.setOwnerDocument(_ownerDocument);
                if (_firstChild.equals(refChildX)) {
                    _firstChild = newChildX;
                }
                if (refChildX.getPreviousSibling() != null) {
                    newChildX.setPreviousSibling(refChildX.getPreviousSibling());
                    ((NodeProxy) refChildX.getPreviousSibling()).setNextSibling(newChildX);
                }
                refChildX.setPreviousSibling(newChildX);
                newChildX.setNextSibling(refChildX);
                ++_childsCount;
            }
        }
        return newChild;
    }

    /**
     * Checks whether <TT>newChild</TT> can be added to this node as a child, and
     * if so, performs a necessary cast. <TT>newChild</TT> cannot be null and must
     * belong to this DOM. It is impossible to transfer nodes between different
     * DOM implementations.
     * <P>
     * The following rules govern the allowed <TT>newChild</TT> types:
     * <UL>
     * <LI>Parent is an {@link org.w3c.dom.Attr}, <TT>newChild</TT> must be either
     *  a {@link org.w3c.dom.Text} or an {@link org.w3c.dom.EntityReference}
     * <LI>Parent is a {@link org.w3c.dom.DocumentType}, <TT>newChild</TT> must be
     *  either an {@link org.w3c.dom.Entity} or a {@link org.w3c.dom.Notation}.
     * <LI>Parnet is any other node type, <TT>newChild</TT> must be an {@link
     *  org.w3c.dom.Element}, a {@link org.w3c.dom.CharacterData} derived type,
     *  a {@link org.w3c.dom.DocumentFragment}, an {@link
     *  org.w3c.dom.EntityReference} or a {@link org.w3c.dom.ProcessingInstruction}.
     * </UL>
     * Any deviation will throw an exception.
     *
     * @param newChild New child node
     * @return <TT>newChild</TT> cast to type {@link NodeImpl}
     * @throws org.w3c.dom.DOMException <TT>HIERARCHY_REQUEST_ERR</TT>
     *  <TT>newChild</TT> is null, does not belong to this DOM, or its node type
     *  is not supported for this parent
     */
    protected Node castNewChild(Node newChild) throws DOMException {
        if (newChild == null) {
            throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, "Child reference is null.");
        }
        if (!(newChild instanceof Node)) {
            throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, "Child is not a compatible type for this node.");
        }
        if (!(newChild instanceof Element || newChild instanceof CharacterData || newChild instanceof DocumentFragment || newChild instanceof EntityReference || newChild instanceof ProcessingInstruction)) {
            throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, "Child is not a compatible type for this node.");
        }
        return newChild;
    }

    /**
     * Checks whether <TT>oldChild</TT> is a direct child of this node, and if so,
     * performs a necessary cast. <TT>oldChild</TT> cannot be null.
     *
     * @param oldChild Old child node
     * @return <T>oldChild</TT> cast to type {@link NodeImpl}
     * @throws org.w3c.dom.DOMException <TT>NOT_FOUND_ERR</TT>
     *  <TT>oldChild</TT> is null, or not a direct child of this node
     */
    protected final Node castOldChild(Node oldChild) throws DOMException {
        if (oldChild == null || !(oldChild instanceof NodeProxy) || !((OzoneProxy) oldChild.getParentNode()).remoteID().equals(container().id())) {
            throw new DOMExceptionImpl(DOMException.NOT_FOUND_ERR, "Not a direct child of this node.");
        }
        return oldChild;
    }

    /**
     * This clone method is called after a new node has been constructed to copy
     * the contents of this node into the new one. It clones in contents but not
     * in context, and guarantees that the cloned node will pass the equality
     * test (see {@link #equals}).
     * <P>
     * <TT>into</TT> must be a valid node of the exact same class as this one.
     * <TT>deep</TT> is true if deep cloning (includes all children nodes) is to
     * be performed. If <TT>deep</TT> is false, the clone might not pass the
     * equality test.
     * <P>
     * Derived classes override and call this method to add per-class variable
     * copying. This method is called by {@link #cloneNode} and the default
     * {@link java.lang.Object#clone} method.
     * <P>
     * Contents cloning duplicates the node's name and value, and its children.
     * It does not duplicate it's context, that is, the node's parent or sibling.
     * Initially a clone node has no parents or siblings. However, the node does
     * belong to the same document, since all nodes must belong to some document.
     * The cloned node is never read-only.
     *
     * @param into A node into which to duplicate this one
     * @param deep True if deep cloning is required
     */
    public synchronized void cloneInto(NodeProxy into, boolean deep) {
        NodeProxy child;
        into.setNodeName(_nodeName);
        String nodeValue = getNodeValue();
        if (nodeValue != null) {
            into.setNodeValue(nodeValue);
        }
        into.setOwnerDocument(_ownerDocument);
        if (deep) {
            child = (NodeProxy) getFirstChild();
            while (child != null) {
                into.appendChild(child.cloneNode(true));
                child = (NodeProxy) child.getNextSibling();
            }
        }
    }

    public synchronized void setOwnerDocument(Document owner) {
        Node node;
        if (owner == null) {
            _ownerDocument = null;
        } else {
            if (!(owner instanceof DocumentProxy)) {
                throw new IllegalArgumentException("Argument 'owner' not of compatible DOM class.");
            }
            _ownerDocument = (DocumentProxy) owner;
        }
        node = getFirstChild();
        while (node != null) {
            ((NodeProxy) node).setOwnerDocument(owner);
            node = node.getNextSibling();
        }
    }

    /**
     * Renders this node read only, preventing it's contents from being modified.
     * Attempts to modify the node's contents will throw an exception. The node's
     * children are also made read-only.
     */
    public final synchronized void setReadOnly() {
        NodeProxy child;
        _readOnly = true;
        child = (NodeProxy) getFirstChild();
        while (child != null) {
            child.setReadOnly();
            child = (NodeProxy) child.getNextSibling();
        }
    }

    /**
     * Returns true if node is read-only and cannot be modified, or if node
     * belongs to a read-only document.
     *
     * @return True if node is read-only and cannot be modified
     * @see #setReadOnly
     */
    public final boolean isReadOnly() {
        return _readOnly;
    }

    /**
     * Returns true if this node supports children. Other methods query this to
     * determine whether to properly support childern, return null or throw an
     * exception in response. The default method returns false.
     *
     * @return True if childern supported by this node type
     */
    boolean supportsChildern() {
        return false;
    }

    /**
     * Returns the <TT>index</TT>-th child of this node. This method is used
     * exclusively by {@link NodeListImpl}.
     *
     * @param index Index of child to retrieve
     * @return The child node or null
     * @see NodeListImpl#item(int)
     */
    public final synchronized Node getChild(int index) {
        NodeProxy node;
        if (index < 0 || index > _childsCount) {
            return null;
        }
        node = (NodeProxy) getFirstChild();
        while (node != null && index > 0) {
            node = (NodeProxy) node.getNextSibling();
            --index;
        }
        return node;
    }

    /**
     * Returns the number of children in this node.  This method is used
     * exclusively by {@link NodeListImpl}.
     *
     * @return Number of childern in this node
     * @see NodeListImpl#getLength
     */
    public final int getChildCount() {
        return _childsCount;
    }

    /**
     * Hidden constructor creates a new node. Only one constructor is supported,
     * although cloning is also supported. Owner document must be supplied except
     * for {@link DocumentImpl} in which case the document itself becomes its
     * owner. Name must be supplied, either dynamic or static (e.g. "#document#").
     * <P>
     * If <TT>checkName</TT> is true, the supplied named is assumed to be a valid
     * XML name token, one that can contain any Unicode letter and digit, must
     * start with a letter, and may also contain hyphen, underscore, digit or colon.
     *
     * @param owner Document owner of this node, or null
     * @param name Name of node
     * @param value Initial value of node or null
     * @param checkName True if name is an XML name token
     * @throws org.w3c.dom.DOMException <TT>INVALID_CHARACTER_ERR</TT>
     *  Node name cannot contain whitespaces or non-printable characters
     */
    protected NodeImpl(DocumentImpl owner, String name, String value, boolean checkName) throws DOMException {
        init(owner, name, value, checkName);
    }

    protected NodeImpl() {
    }

    public final void init(DocumentProxy owner, String name, String value, boolean checkName) throws DOMException {
        char ch;
        int i;
        if (name == null) {
            throw new NullPointerException("Argument 'name' is null.");
        }
        _nodeName = name;
        _ownerDocument = owner;
        if (checkName && name.length() > 0) {
            ch = name.charAt(0);
            if (!Character.isLetter(ch) && ch != '_' && ch != ':') {
                throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR);
            }
            for (i = 1; i < name.length(); ++i) {
                ch = name.charAt(1);
                if (!Character.isLetterOrDigit(ch) && ch != '_' && ch != ':' && ch != '-' && ch != '.') {
                    throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR);
                }
            }
        }
        if (value != null) {
            setNodeValue(value);
        }
    }

    /**
     * Element declaration node. Not part of the DOM, identifies an element
     * declaration node appearing in the DTD.
     */
    public static final short ELEMENT_DECL_NODE = 13;

    /**
     * Attributes list declaration node. Not part of the DOM, identifies an
     * attributes list declaration node appearing in the DTD..
     */
    public static final short ATTLIST_DECL_NODE = 14;

    /**
     * Parameter entity declaration node. Not part of the DOM, identifies an
     * internal or external parameter entity declaration node appearing in the
     * DTD (see {@link ParamEntity}).
     */
    public static final short PARAM_ENTITY_NODE = 15;

    /**
     * This node ia part of a double-linked list that belongs to its parent.
     * This reference identifies the next child in the list. Class access
     * required by derived classes.
     */
    NodeProxy _nextNode;

    /**
     * This node ia part of a double-linked list that belongs to its parent.
     * This reference identifies the previous child in the list. Class access
     * required by derived classes.
     */
    NodeProxy _prevNode;

    /**
     * The parent of this node or null if the node has no parent. Class access
     * required by derived classes.
     */
    NodeProxy _parent;

    /**
     * The document owner of this node, or the document itself. If the node belongs
     * to any document, this will point to that document. For a document this will
     * point at the document itself ({@link #getOwnerDocument} will return null,
     * though). Class access required by derived classes.
     */
    DocumentProxy _ownerDocument;

    /**
     * The name of this node. All nodes have names, some are dynamic (e.g. the
     * tag name of an element), others are static (e.g. "#document").
     */
    private String _nodeName;

    /**
     * The value of this node. Not all nodes support values and this might be
     * null for some nodes.
     */
    private String _nodeValue;

    /**
     * The children of this node are arranged in a doubly linked lists.
     * This reference identifies the first child in the list.
     */
    private NodeProxy _firstChild;

    /**
     * The children of this node are arranged in a doubly linked lists.
     * This reference identifies the last child in the list.
     */
    private NodeProxy _lastChild;

    /**
     * Counts how many children nodes belong to this parent. Used to speed up
     * some checks.
     */
    private int _childsCount;

    /**
     * True if this node is read-only and its contents cannot be modified.
     */
    private boolean _readOnly;

    /**
     * Holdes a list of iterators that are observing this node of its
     * childern.
     */
    private NodeIteratorListener[] _iterators;

    /**
     */
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(_nextNode);
        out.writeObject(_prevNode);
        out.writeObject(_parent);
        out.writeObject(_ownerDocument);
        if (_nodeName != null) {
            out.writeByte(1);
            out.writeUTF(_nodeName);
        } else {
            out.writeByte(-1);
        }
        if (_nodeValue != null) {
            out.writeByte(1);
            out.writeUTF(_nodeValue);
        } else {
            out.writeByte(-1);
        }
        out.writeObject(_firstChild);
        out.writeObject(_lastChild);
        out.writeInt(_childsCount);
        out.writeBoolean(_readOnly);
        if (_iterators != null) {
            int len = _iterators.length;
            out.writeInt(len);
            for (int i = 0; i < len; i++) {
                out.writeObject(_iterators[i]);
            }
        } else {
            out.writeInt(-1);
        }
    }

    /**
     */
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        _nextNode = (NodeProxy) in.readObject();
        _prevNode = (NodeProxy) in.readObject();
        _parent = (NodeProxy) in.readObject();
        _ownerDocument = (DocumentProxy) in.readObject();
        int n = in.readByte();
        if (n > 0) {
            _nodeName = in.readUTF();
        } else {
            _nodeName = null;
        }
        n = in.readByte();
        if (n > 0) {
            _nodeValue = in.readUTF();
        } else {
            _nodeValue = null;
        }
        _firstChild = (NodeProxy) in.readObject();
        _lastChild = (NodeProxy) in.readObject();
        _childsCount = in.readInt();
        _readOnly = in.readBoolean();
        int len = in.readInt();
        if (len > -1) {
            _iterators = new NodeIteratorListener[len];
            for (int i = 0; i < len; i++) {
                _iterators[i] = (NodeIteratorListener) in.readObject();
            }
        } else {
            _iterators = null;
        }
    }

    public boolean isSupported(String s, String s1) {
        throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR, "Node.getLocalName(): ozone's persistent DOM doesn't support DOM level 2 yet.");
    }
}
