package net.rsapollo.models;

import net.rsapollo.Cryption;
import net.rsapollo.library.*;
import net.rsapollo.server.*;
import net.rsapollo.combat.base.*;
import net.rsapollo.*;
import net.rsapollo.skill.*;
import net.rsapollo.skill.base.Combat;
import net.rsapollo.user.*;

/**
 * <!-- This isnt meant to be read raw. Please use the documentation to
 * correctly read this --> <i>No documentation has been added for this class</i>
 * <!-- Break --><br />
 * <hr width="80%" align="center" size="1" style="color: #FFFFFF;" />
 * <div align="center" style="font-weight: bold; font-size: 18px;">Notice</div>
 * This class is considered a base class, and therefore isnt setup to be
 * directly edited. So please, <b>Do not edit this file!</b> <!-- Break --><br />
 * <hr width="80%" align="center" size="1" style="color: #FFFFFF;" />
 * <br />
 * Apollo Server - RS Private Server<br />
 * Website: <a href="http://www.rsapollo.net/">http://www.rsapollo.net/</a><br />
 * Copyright (C) 2007 Kris <br />
 * <br />
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version. <br />
 * <br />
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details. <br />
 * <br />
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <a
 * href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.<br />
 * 
 * @author kris
 */
public class PlayerModel implements Runnable {

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_ATTACK = 0;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_DEFENCE = 1;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_STRENGTH = 2;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_HITPOINTS = 3;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_RANGE = 4;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_PRAYER = 5;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_MAGIC = 6;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_COOKING = 7;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_WOODCUTTING = 8;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_FLETCHING = 9;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_FISHING = 10;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_FIREMAKING = 11;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_CRAFTING = 12;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_SMITHING = 13;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_MINING = 14;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_HERBLORE = 15;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_AGILITY = 16;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_THIEVING = 17;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_SLAYER = 18;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_FARMING = 19;

    /**
	 * This refers to the slot where woodcutting is in the Level Array.
	 */
    public final int SKILL_RUNECRAFT = 20;

    public Woodcutting Woodcutting;

    public Mining Mining;

    public Thieving Thieving;

    public hObject object;

    public hNpc npc;

    public hItem item;

    public hPlayer player;

    public Update Update;

    public Packet Packet;

    public Data Data;

    public UI UI;

    public Control Control;

    public Walk Walk;

    public Animation Animation;

    public Combat Combat;

    public void initClasses() {
        Woodcutting = new Woodcutting(playerId);
        Mining = new Mining(playerId);
        Thieving = new Thieving(playerId);
        UI = new UI(this);
        Update = new Update(this);
        object = new hObject(this);
        npc = new hNpc(this);
        item = new hItem(this);
        player = new hPlayer(this);
        Packet = new Packet(this);
        Data = new Data(this);
        Control = new Control(this);
        Walk = new Walk(this);
        Animation = new Animation(this);
    }

    public int idle = 0;

    public boolean destroyed = false;

    public boolean objectUpdate = false;

    public int playerLook[] = new int[6];

    public int bankXremoveSlot = 0;

    public int bankXinterfaceID = 0;

    public int freezeDelay = 0;

    public int bankXremoveID = 0;

    public int hitDiff = -1;

    public static final int bufferSize = 5000;

    public java.net.Socket mySock;

    public java.io.InputStream in;

    public java.io.OutputStream out;

    public byte buffer[] = null;

    public int readPtr, writePtr;

    public Stream inStream = null, outStream = null;

    public Cryption inStreamDecryption = null, outStreamDecryption = null;

    public int lowMemoryVersion = 0;

    public int timeOutCounter = 0;

    public int returnCode = 2;

    /**
	 * Resets the players animation.
	 * 
	 * @author kris
	 */
    public void resetAnimation() {
        updateRequired = true;
        appearanceUpdateRequired = true;
    }

    public void shutdownError(String errorMessage) {
        Print.general("Fatal: " + errorMessage);
        destruct();
    }

    public void destruct() {
        try {
            Print.general("ClientHandler: Client " + playerName + " disconnected.");
            disconnected = true;
            if (in != null) in.close();
            if (out != null) out.close();
            mySock.close();
            mySock = null;
            in = null;
            out = null;
            inStream = null;
            outStream = null;
            isActive = false;
            synchronized (this) {
                notify();
            }
            buffer = null;
        } catch (java.io.IOException ioe) {
            ioe.printStackTrace();
        }
        playerListSize = 0;
        for (int i = 0; i < maxPlayerListSize; i++) playerList[i] = null;
        mapRegionX = mapRegionY = -1;
        currentX = currentY = 0;
        Data.save();
        handler.nullPlayer(playerId);
    }

    public void flushOutStream() {
        if (disconnected || outStream.currentOffset == 0) return;
        synchronized (this) {
            int maxWritePtr = (readPtr + bufferSize - 2) % bufferSize;
            for (int i = 0; i < outStream.currentOffset; i++) {
                buffer[writePtr] = outStream.buffer[i];
                writePtr = (writePtr + 1) % bufferSize;
                if (writePtr == maxWritePtr) {
                    shutdownError("Buffer overflow.");
                    disconnected = true;
                    return;
                }
            }
            outStream.currentOffset = 0;
            notify();
        }
    }

    public void directFlushOutStream() throws java.io.IOException {
        out.write(outStream.buffer, 0, outStream.currentOffset);
        outStream.currentOffset = 0;
    }

    public void fillInStream(int forceRead) throws java.io.IOException {
        inStream.currentOffset = 0;
        in.read(inStream.buffer, 0, forceRead);
    }

    public void run() {
        initClasses();
        Data.load();
        resetWalkingQueue();
        packetSize = 0;
        packetType = -1;
        readPtr = 0;
        writePtr = 0;
        int numBytesInBuffer, offset;
        while (!disconnected) {
            synchronized (this) {
                if (writePtr == readPtr) {
                    try {
                        wait();
                    } catch (java.lang.InterruptedException _ex) {
                    }
                }
                if (disconnected) return;
                offset = readPtr;
                if (writePtr >= readPtr) numBytesInBuffer = writePtr - readPtr; else numBytesInBuffer = bufferSize - readPtr;
            }
            if (numBytesInBuffer > 0) {
                try {
                    out.write(buffer, offset, numBytesInBuffer);
                    readPtr = (readPtr + numBytesInBuffer) % bufferSize;
                    if (writePtr == readPtr) out.flush();
                } catch (java.lang.Exception e) {
                    disconnected = true;
                }
            }
        }
    }

    public void sendMessage(String s) {
        outStream.createFrameVarSize(253);
        outStream.writeString(s);
        outStream.endFrameVarSize();
    }

    public void setSidebarInterface(int menuId, int form) {
        outStream.createFrame(71);
        outStream.writeWord(form);
        outStream.writeByteA(menuId);
    }

    public void setSkillLevel(int skillNum, int currentLevel, double XP) {
        outStream.createFrame(134);
        outStream.writeByte(skillNum);
        outStream.writeDWord_v1((int) XP);
        outStream.writeByte(currentLevel);
    }

    public void customCommand(String command) {
        if (command.startsWith("pos")) {
            sendMessage("Your coords are: " + absX + "(" + teleportToX + "), " + absY + "(" + teleportToY + ")");
        }
        if (command.startsWith("steal")) {
            Thieving.stealNPC(1, 100, 100);
        }
        if (playerRights < 2) return;
        if (command.startsWith("obj")) {
            try {
                int id = Integer.parseInt(command.substring(command.indexOf(" ") + 1, command.lastIndexOf(" ")));
                int dir = Integer.parseInt(command.substring(command.lastIndexOf(" ") + 1, command.length()));
                Main.Server.objectHandler.addObject(absX, absY, id, dir);
            } catch (Exception e) {
                sendMessage("Format: ::obj 123 -2");
            }
        } else if (command.startsWith("dobj")) {
            try {
                int area = Integer.parseInt(command.substring(command.indexOf(" ") + 1, command.length()));
                Main.Server.objectHandler.removeObject(absX, absY, area);
            } catch (Exception e) {
                sendMessage("Format: ::dobj 2");
            }
        } else if (command.startsWith("robj")) {
            try {
                int x = Integer.parseInt(command.substring(command.indexOf(" ") + 1, command.lastIndexOf(" ")));
                int y = Integer.parseInt(command.substring(command.lastIndexOf(" ") + 1, command.length()));
                Main.Server.objectHandler.removeObject(x, y, 0);
            } catch (Exception e) {
                sendMessage("Format: ::robj 2333(x) 123(y)");
            }
        }
    }

    public boolean buryBones(int fromSlot) {
        if (playerItems[fromSlot].qty != 1 || playerItems[fromSlot].id < 1) return false;
        int buryItem = playerItems[fromSlot].id;
        int buryXP = 4;
        if ((buryItem - 1) == 532 && (buryItem - 1) == 3125 && (buryItem - 1) == 3127 && (buryItem - 1) == 3128 && (buryItem - 1) == 3129 && (buryItem - 1) == 3130 && (buryItem - 1) == 3132 && (buryItem - 1) == 3133) {
            buryXP = 15;
        } else if ((buryItem - 1) == 536) {
            buryXP = 72;
        } else if ((buryItem - 1) == 534) {
            buryXP = 30;
        } else if ((buryItem - 1) == 4812) {
            buryXP = 25;
        } else if ((buryItem - 1) == 4830) {
            buryXP = 348;
        } else if ((buryItem - 1) == 4832) {
            buryXP = 384;
        } else if ((buryItem - 1) == 4834) {
            buryXP = 560;
        }
        if (addSkillXP(buryXP, 5)) {
            item.deleteItem((buryItem - 1), fromSlot, 1);
            return true;
        }
        return false;
    }

    public boolean addSkillXP(double amount, int skill) {
        if (amount + playerXP[skill] < 0 || playerXP[skill] > 2080040703) {
            sendMessage("Max XP value reached");
            return false;
        }
        int oldLevel = getLevelForXP(playerXP[skill]);
        playerXP[skill] += (amount * Configuration.XPRate);
        if (oldLevel < getLevelForXP(playerXP[skill])) {
            playerLevel[skill] = getLevelForXP(playerXP[skill]);
            updateRequired = true;
            appearanceUpdateRequired = true;
        }
        setSkillLevel(skill, playerLevel[skill], playerXP[skill]);
        return true;
    }

    public int getXPForLevel(int level) {
        int points = 0;
        int output = 0;
        for (int lvl = 1; lvl <= level; lvl++) {
            points += Math.floor((double) lvl + 300.0 * Math.pow(2.0, (double) lvl / 7.0));
            if (lvl >= level) return output;
            output = (int) Math.floor(points / 4);
        }
        return 0;
    }

    public int getLevelForXP(double exp) {
        int points = 0;
        int output = 0;
        for (int lvl = 1; lvl <= 99; lvl++) {
            points += Math.floor((double) lvl + 300.0 * Math.pow(2.0, (double) lvl / 7.0));
            output = (int) Math.floor(points / 4);
            if (output >= exp) return lvl;
        }
        return 0;
    }

    public boolean playerHasItem(int itemID) {
        for (int i = 0; i < playerItems.length; i++) if (playerItems[i].id == itemID) return true;
        return false;
    }

    public void openUpBank() {
        outStream.createFrame(248);
        outStream.writeWordA(5292);
        outStream.writeWord(5063);
        item.resetTempItems();
    }

    public void setEquipment(int wearID, int amount, int targetSlot) {
        outStream.createFrameVarSizeWord(34);
        outStream.writeWord(1688);
        outStream.writeByte(targetSlot);
        outStream.writeWord(wearID + 1);
        if (amount > 254) {
            outStream.writeByte(255);
            outStream.writeDWord(amount);
        } else {
            outStream.writeByte(amount);
        }
        outStream.endFrameVarSizeWord();
        playerEquipment[targetSlot] = new ItemModel(wearID);
        playerEquipment[targetSlot].qty = amount;
        updateRequired = true;
        appearanceUpdateRequired = true;
    }

    public boolean wear(int wearID, int slot) {
        int targetSlot = 0;
        if (playerItems[slot].id == wearID) {
            if (itemType(wearID).equalsIgnoreCase("cape")) targetSlot = 1; else if (itemType(wearID).equalsIgnoreCase("hat")) targetSlot = 0; else if (itemType(wearID).equalsIgnoreCase("amulet")) targetSlot = 2; else if (itemType(wearID).equalsIgnoreCase("arrows")) targetSlot = 13; else if (itemType(wearID).equalsIgnoreCase("body")) targetSlot = 4; else if (itemType(wearID).equalsIgnoreCase("shield")) targetSlot = 5; else if (itemType(wearID).equalsIgnoreCase("legs")) targetSlot = 7; else if (itemType(wearID).equalsIgnoreCase("gloves")) targetSlot = 9; else if (itemType(wearID).equalsIgnoreCase("boots")) targetSlot = 10; else if (itemType(wearID).equalsIgnoreCase("ring")) targetSlot = 12; else targetSlot = 3;
            int wearAmount = playerItems[slot].qty;
            if (wearAmount < 1) return false;
            if (slot >= 0 && wearID >= 0) {
                item.deleteItem(wearID, slot, wearAmount);
                if (playerEquipment[targetSlot].id != wearID && playerEquipment[targetSlot].id >= 0) item.addItem(playerEquipment[targetSlot].id, playerEquipment[targetSlot].qty); else if (Server.itemHandler.defaults[wearID].stack && playerEquipment[targetSlot].id == wearID) wearAmount = playerEquipment[targetSlot].id + wearAmount; else if (playerEquipment[targetSlot].id >= 0) item.addItem(playerEquipment[targetSlot].id, playerEquipment[targetSlot].qty);
            }
            outStream.createFrameVarSizeWord(34);
            outStream.writeWord(1688);
            outStream.writeByte(targetSlot);
            outStream.writeWord(wearID + 1);
            if (wearAmount > 254) {
                outStream.writeByte(255);
                outStream.writeDWord(wearAmount);
            } else {
                outStream.writeByte(wearAmount);
            }
            outStream.endFrameVarSizeWord();
            playerEquipment[targetSlot].id = wearID;
            playerEquipment[targetSlot].qty = wearAmount;
            updateRequired = true;
            appearanceUpdateRequired = true;
            return true;
        } else return false;
    }

    public String itemType(int item) {
        for (int i = 0; i < ItemModel.capes.length; i++) {
            if (item == ItemModel.capes[i]) return "cape";
        }
        for (int i = 0; i < ItemModel.hats.length; i++) {
            if (item == ItemModel.hats[i]) return "hat";
        }
        for (int i = 0; i < ItemModel.boots.length; i++) {
            if (item == ItemModel.boots[i]) return "boots";
        }
        for (int i = 0; i < ItemModel.gloves.length; i++) {
            if (item == ItemModel.gloves[i]) return "gloves";
        }
        for (int i = 0; i < ItemModel.shields.length; i++) {
            if (item == ItemModel.shields[i]) return "shield";
        }
        for (int i = 0; i < ItemModel.amulets.length; i++) {
            if (item == ItemModel.amulets[i]) return "amulet";
        }
        for (int i = 0; i < ItemModel.arrows.length; i++) {
            if (item == ItemModel.arrows[i]) return "arrows";
        }
        for (int i = 0; i < ItemModel.rings.length; i++) {
            if (item == ItemModel.rings[i]) return "ring";
        }
        for (int i = 0; i < ItemModel.body.length; i++) {
            if (item == ItemModel.body[i]) return "body";
        }
        for (int i = 0; i < ItemModel.legs.length; i++) {
            if (item == ItemModel.legs[i]) return "legs";
        }
        return "weapon";
    }

    public void remove(int wearID, int slot) {
        if (item.addItem(playerEquipment[slot].id, playerEquipment[slot].qty)) {
            playerEquipment[slot].id = -1;
            playerEquipment[slot].qty = 0;
            outStream.createFrame(34);
            outStream.writeWord(6);
            outStream.writeWord(1688);
            outStream.writeByte(slot);
            outStream.writeWord(0);
            outStream.writeByte(0);
            updateRequired = true;
            appearanceUpdateRequired = true;
        }
    }

    public void TeleTo(String s) {
        if (s == "Varrock") {
            teleportToX = 3210;
            teleportToY = 3424;
            heightLevel = 0;
        } else if (s == "Falador") {
            teleportToX = 2964;
            teleportToY = 3378;
            heightLevel = 0;
        } else if (s == "Lumby") {
            teleportToX = 3222;
            teleportToY = 3218;
            heightLevel = 0;
        } else if (s == "Camelot") {
            teleportToX = 2757;
            teleportToY = 3477;
            heightLevel = 0;
        } else if (s == "Ardougne") {
            teleportToX = 2662;
            teleportToY = 3305;
            heightLevel = 0;
        } else if (s == "Watchtower") {
            teleportToX = 2549;
            teleportToY = 3113;
            heightLevel = 2;
        } else if (s == "Trollheim") {
            teleportToX = 2890;
            teleportToY = 3677;
            heightLevel = 0;
        }
        updateRequired = true;
        appearanceUpdateRequired = true;
    }

    public void setChatOptions(int publicChat, int privateChat, int tradeBlock) {
        outStream.createFrame(206);
        outStream.writeByte(publicChat);
        outStream.writeByte(publicChat);
        outStream.writeByte(tradeBlock);
    }

    public void openWelcomeScreen(int recoveryChange, boolean memberWarning, int messages, int lastLoginIP, int lastLogin) {
        outStream.createFrame(176);
        outStream.writeByteC(recoveryChange);
        outStream.writeWordA(messages);
        outStream.writeByte(memberWarning ? 1 : 0);
        outStream.writeDWord_v2(lastLoginIP);
        outStream.writeWord(lastLogin);
    }

    public void setClientConfig(int id, int state) {
        outStream.createFrame(36);
        outStream.writeWordBigEndian(id);
        outStream.writeByte(state);
    }

    public void initializeClientConfiguration() {
        setClientConfig(18, 1);
        setClientConfig(19, 0);
        setClientConfig(25, 0);
        setClientConfig(43, 0);
        setClientConfig(44, 0);
        setClientConfig(75, 0);
        setClientConfig(83, 0);
        setClientConfig(84, 0);
        setClientConfig(85, 0);
        setClientConfig(86, 0);
        setClientConfig(87, 0);
        setClientConfig(88, 0);
        setClientConfig(89, 0);
        setClientConfig(90, 0);
        setClientConfig(91, 0);
        setClientConfig(92, 0);
        setClientConfig(93, 0);
        setClientConfig(94, 0);
        setClientConfig(95, 0);
        setClientConfig(96, 0);
        setClientConfig(97, 0);
        setClientConfig(98, 0);
        setClientConfig(99, 0);
        setClientConfig(100, 0);
        setClientConfig(101, 0);
        setClientConfig(104, 0);
        setClientConfig(106, 0);
        setClientConfig(108, 0);
        setClientConfig(115, 0);
        setClientConfig(143, 0);
        setClientConfig(153, 0);
        setClientConfig(156, 0);
        setClientConfig(157, 0);
        setClientConfig(158, 0);
        setClientConfig(166, 0);
        setClientConfig(167, 0);
        setClientConfig(168, 0);
        setClientConfig(169, 0);
        setClientConfig(170, 0);
        setClientConfig(171, 0);
        setClientConfig(172, 0);
        setClientConfig(173, 0);
        setClientConfig(174, 0);
        setClientConfig(203, 0);
        setClientConfig(210, 0);
        setClientConfig(211, 0);
        setClientConfig(261, 0);
        setClientConfig(262, 0);
        setClientConfig(263, 0);
        setClientConfig(264, 0);
        setClientConfig(265, 0);
        setClientConfig(266, 0);
        setClientConfig(268, 0);
        setClientConfig(269, 0);
        setClientConfig(270, 0);
        setClientConfig(271, 0);
        setClientConfig(280, 0);
        setClientConfig(286, 0);
        setClientConfig(287, 0);
        setClientConfig(297, 0);
        setClientConfig(298, 0);
        setClientConfig(301, 01);
        setClientConfig(304, 01);
        setClientConfig(309, 01);
        setClientConfig(311, 01);
        setClientConfig(312, 01);
        setClientConfig(313, 01);
        setClientConfig(330, 01);
        setClientConfig(331, 01);
        setClientConfig(342, 01);
        setClientConfig(343, 01);
        setClientConfig(344, 01);
        setClientConfig(345, 01);
        setClientConfig(346, 01);
        setClientConfig(353, 01);
        setClientConfig(354, 01);
        setClientConfig(355, 01);
        setClientConfig(356, 01);
        setClientConfig(361, 01);
        setClientConfig(362, 01);
        setClientConfig(363, 01);
        setClientConfig(377, 01);
        setClientConfig(378, 01);
        setClientConfig(379, 01);
        setClientConfig(380, 01);
        setClientConfig(383, 01);
        setClientConfig(388, 01);
        setClientConfig(391, 01);
        setClientConfig(393, 01);
        setClientConfig(399, 01);
        setClientConfig(400, 01);
        setClientConfig(406, 01);
        setClientConfig(408, 01);
        setClientConfig(414, 01);
        setClientConfig(417, 01);
        setClientConfig(423, 01);
        setClientConfig(425, 01);
        setClientConfig(427, 01);
        setClientConfig(433, 01);
        setClientConfig(435, 01);
        setClientConfig(436, 01);
        setClientConfig(437, 01);
        setClientConfig(439, 01);
        setClientConfig(440, 01);
        setClientConfig(441, 01);
        setClientConfig(442, 01);
        setClientConfig(443, 01);
        setClientConfig(445, 01);
        setClientConfig(446, 01);
        setClientConfig(449, 01);
        setClientConfig(452, 01);
        setClientConfig(453, 01);
        setClientConfig(455, 01);
        setClientConfig(464, 01);
        setClientConfig(465, 01);
        setClientConfig(470, 01);
        setClientConfig(482, 01);
        setClientConfig(486, 01);
        setClientConfig(491, 01);
        setClientConfig(492, 01);
        setClientConfig(493, 01);
        setClientConfig(496, 01);
        setClientConfig(497, 01);
        setClientConfig(498, 01);
        setClientConfig(499, 01);
        setClientConfig(502, 01);
        setClientConfig(503, 01);
        setClientConfig(504, 01);
        setClientConfig(505, 01);
        setClientConfig(506, 01);
        setClientConfig(507, 01);
        setClientConfig(508, 01);
        setClientConfig(509, 01);
        setClientConfig(510, 01);
        setClientConfig(511, 01);
        setClientConfig(512, 01);
        setClientConfig(515, 01);
        setClientConfig(518, 01);
        setClientConfig(520, 01);
        setClientConfig(521, 01);
        setClientConfig(524, 01);
        setClientConfig(525, 01);
        setClientConfig(531, 01);
    }

    public void initialize() {
        for (int i = 0; i < playerEquipment.length; i++) playerEquipment[i] = null;
        outStream.createFrame(249);
        outStream.writeByteA(1);
        outStream.writeWordBigEndianA(playerId);
        setChatOptions(0, 0, 0);
        for (int i = 0; i < playerLevel.length; i++) setSkillLevel(i, playerLevel[i], playerXP[i]);
        outStream.createFrame(107);
        setSidebarInterface(1, 3917);
        setSidebarInterface(2, 638);
        setSidebarInterface(3, 3213);
        setSidebarInterface(4, 1644);
        setSidebarInterface(5, 5608);
        setSidebarInterface(6, 1151);
        setSidebarInterface(7, 12855);
        setSidebarInterface(8, 5065);
        setSidebarInterface(9, 5715);
        setSidebarInterface(10, 2449);
        setSidebarInterface(11, 4445);
        setSidebarInterface(12, 147);
        setSidebarInterface(13, 6299);
        setSidebarInterface(0, 2423);
        if (playerRights >= 2) {
            outStream.createFrameVarSize(104);
            outStream.writeByteC(1);
            outStream.writeByteA(1);
            outStream.writeString("@lre@Moderate");
            outStream.endFrameVarSize();
        }
        outStream.createFrameVarSize(104);
        outStream.writeByteC(4);
        outStream.writeByteA(1);
        outStream.writeString("@lre@Trade with");
        outStream.endFrameVarSize();
        outStream.createFrameVarSize(104);
        outStream.writeByteC(5);
        outStream.writeByteA(1);
        outStream.writeString("@lre@Stats");
        outStream.endFrameVarSize();
        item.resetItems();
        item.resetBank();
        for (int i = 0; i < playerEquipment.length; i++) {
            if (playerEquipment[i] != null && playerEquipment[i].init) setEquipment(playerEquipment[i].id, 1, i); else setEquipment(-1, 0, i);
        }
        sendMessage("Welcome " + playerName + " to Apollo");
        flushOutStream();
        UI.frame126("@red@No quest yet...", 7332);
        UI.frame126("Setting 4", 12585);
        UI.frame126("Off", 12588);
        UI.frame126("On", 12589);
        UI.setInterfaceWalkable(6673);
        UI.setInterfaceWalkable(6568);
        item.addItem(1351, 1);
        item.addItem(995, 10000);
        handler.updatePlayer(this, outStream);
        handler.updateNPC(this, outStream);
        Server.objectHandler.refreshSingle(this);
    }

    public static final int packetSizes[] = { 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 6, 2, 2, 0, 0, 2, 0, 6, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 0, 0, 2, 2, 6, 0, 6, 0, -1, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 2, 2, 8, 6, 0, -1, 0, 6, 0, 0, 0, 0, 0, 1, 4, 6, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, -1, 0, 0, 13, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 1, 0, 6, 0, 0, 0, -1, 0, 2, 6, 0, 4, 6, 8, 0, 6, 0, 0, 0, 2, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 1, 2, 0, 2, 6, 0, 0, 0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 3, 0, 2, 0, 0, 8, 1, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 7, 8, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, -1, 0, 6, 0, 1, 0, 0, 0, 6, 0, 6, 8, 1, 0, 0, 4, 0, 0, 0, 0, -1, 0, -1, 4, 0, 0, 6, 6, 0, 0, 0 };

    public int packetSize = 0, packetType = -1;

    public int somejunk;

    public void println_debug(String str) {
        System.out.println("[player-" + playerId + "]: " + str);
    }

    public void println(String str) {
        System.out.println("[player-" + playerId + "]: " + str);
    }

    public void initPlayer(java.net.Socket s, int playID) {
        playerId = playID;
        mySock = s;
        try {
            in = s.getInputStream();
            out = s.getOutputStream();
        } catch (java.io.IOException ioe) {
            Print.general("Radiance Server: Exception!");
            destruct();
        }
        outStream = new Stream(new byte[bufferSize]);
        outStream.currentOffset = 0;
        inStream = new Stream(new byte[bufferSize]);
        inStream.currentOffset = 0;
        readPtr = writePtr = 0;
        buffer = new byte[bufferSize];
    }

    public PlayerModel() {
        for (int i = 0; i < playerBankSize; i++) bankItems[i] = null;
        pHead = 3;
        pTorso = 19;
        pArms = 29;
        pHands = 35;
        pLegs = 39;
        pFeet = 44;
        teleportToX = 3216;
        teleportToY = 3384;
        heightLevel = 0;
        absX = absY = -1;
        mapRegionX = mapRegionY = -1;
        currentX = currentY = 0;
    }

    public boolean initialized = false;

    public boolean disconnected = false;

    public boolean isActive = false;

    public boolean isKicked = false;

    public int actionTimer = 0;

    public int actionAmount = 0;

    public String actionName = "";

    public String connectedFrom = "";

    public String connectedIP = "";

    public String lastConnectionFrom = "";

    public String globalMessage = "";

    public int tradeWith = 0;

    public int tradeFromID = 0;

    public String tradeFrom = "";

    public int tradeWaitingTime = 0;

    public boolean tradeAccepted = false;

    public boolean takeAsNote = false;

    public int playerId = -1;

    public String playerName = null;

    public String playerPass = null;

    public int playerRights;

    public PlayerHandler handler = null;

    public int maxItemAmount = 2000000000;

    public ItemModel[] playerItems = new ItemModel[28];

    public int playerBankSize = 120;

    public ItemModel[] bankItems = new ItemModel[800];

    public boolean bankNotes = false;

    public int pHead;

    public int pTorso;

    public int pArms;

    public int pHands;

    public int pLegs;

    public int pFeet;

    public ItemModel[] playerEquipment = new ItemModel[14];

    public int playerHat = 0;

    public int playerCape = 1;

    public int playerAmulet = 2;

    public int playerWeapon = 3;

    public int playerChest = 4;

    public int playerShield = 5;

    public int playerLegs = 7;

    public int playerHands = 9;

    public int playerFeet = 10;

    public int playerRing = 12;

    public int playerArrows = 13;

    public int[] playerLevel = new int[21];

    public double[] playerXP = new double[21];

    public static final int maxPlayerListSize = PlayerHandler.maxPlayers;

    public PlayerModel playerList[] = new PlayerModel[maxPlayerListSize];

    public int playerListSize = 0;

    public byte playerInListBitmap[] = new byte[(PlayerHandler.maxPlayers + 7) >> 3];

    public boolean withinDistance(PlayerModel otherPlr) {
        if (heightLevel != otherPlr.heightLevel) return false;
        int deltaX = otherPlr.absX - absX, deltaY = otherPlr.absY - absY;
        return deltaX <= 15 && deltaX >= -16 && deltaY <= 15 && deltaY >= -16;
    }

    public int mapRegionX, mapRegionY;

    public int absX, absY;

    public int currentX, currentY;

    public int heightLevel;

    public boolean updateRequired = true;

    public static final int walkingQueueSize = 50;

    public int walkingQueueX[] = new int[walkingQueueSize], walkingQueueY[] = new int[walkingQueueSize];

    public int wQueueReadPtr = 0;

    public int wQueueWritePtr = 0;

    public boolean isRunning = false;

    public int teleportToX = -1, teleportToY = -1;

    public void resetWalkingQueue() {
        wQueueReadPtr = wQueueWritePtr = 0;
        for (int i = 0; i < walkingQueueSize; i++) {
            walkingQueueX[i] = currentX;
            walkingQueueY[i] = currentY;
        }
    }

    public void addToWalkingQueue(int x, int y) {
        int next = (wQueueWritePtr + 1) % walkingQueueSize;
        if (next == wQueueWritePtr) return;
        walkingQueueX[wQueueWritePtr] = x;
        walkingQueueY[wQueueWritePtr] = y;
        wQueueWritePtr = next;
    }

    public int getNextWalkingDirection() {
        if (wQueueReadPtr == wQueueWritePtr) return -1;
        int dir;
        do {
            dir = Misc.direction(currentX, currentY, walkingQueueX[wQueueReadPtr], walkingQueueY[wQueueReadPtr]);
            if (dir == -1) wQueueReadPtr = (wQueueReadPtr + 1) % walkingQueueSize; else if ((dir & 1) != 0) {
                println_debug("Invalid waypoint in walking queue!");
                resetWalkingQueue();
                return -1;
            }
        } while (dir == -1 && wQueueReadPtr != wQueueWritePtr);
        if (dir == -1) return -1;
        dir >>= 1;
        currentX += Misc.directionDeltaX[dir];
        currentY += Misc.directionDeltaY[dir];
        absX += Misc.directionDeltaX[dir];
        absY += Misc.directionDeltaY[dir];
        return dir;
    }

    public boolean didTeleport = false;

    public boolean mapRegionDidChange = false;

    public int dir1 = -1, dir2 = -1;

    public boolean createItems = false;

    public int poimiX = 0, poimiY = 0;

    public byte cachedPropertiesBitmap[] = new byte[(PlayerHandler.maxPlayers + 7) >> 3];

    public boolean appearanceUpdateRequired = true;

    public static Stream playerProps;

    static {
        playerProps = new Stream(new byte[100]);
    }

    public void appendPlayerAppearance(Stream str) {
        playerProps.currentOffset = 0;
        playerProps.writeByte(0);
        playerProps.writeByte(0);
        if (playerEquipment[playerHat] != null && playerEquipment[playerHat].id > 1) playerProps.writeWord(0x200 + playerEquipment[playerHat].id); else playerProps.writeByte(0);
        if (playerEquipment[playerCape] != null && playerEquipment[playerCape].id > 1) playerProps.writeWord(0x200 + playerEquipment[playerCape].id); else playerProps.writeByte(0);
        if (playerEquipment[playerAmulet] != null && playerEquipment[playerAmulet].id > 1) playerProps.writeWord(0x200 + playerEquipment[playerAmulet].id); else playerProps.writeByte(0);
        if (playerEquipment[playerWeapon] != null && playerEquipment[playerWeapon].id > 1) playerProps.writeWord(0x200 + playerEquipment[playerWeapon].id); else playerProps.writeByte(0);
        if (playerEquipment[playerChest] != null && playerEquipment[playerChest].id > 1) playerProps.writeWord(0x200 + playerEquipment[playerChest].id); else playerProps.writeWord(0x100 + pTorso);
        if (playerEquipment[playerShield] != null && playerEquipment[playerShield].id > 1) playerProps.writeWord(0x200 + playerEquipment[playerShield].id); else playerProps.writeByte(0);
        if (playerEquipment[playerChest] != null && !playerEquipment[playerChest].isPlatebody) playerProps.writeWord(0x100 + pArms); else playerProps.writeByte(0);
        if (playerEquipment[playerLegs] != null && playerEquipment[playerLegs].id > 1) playerProps.writeWord(0x200 + playerEquipment[playerLegs].id); else playerProps.writeWord(0x100 + pLegs);
        if (playerEquipment[playerHat] != null && !playerEquipment[playerHat].isHelm && !playerEquipment[playerHat].isMask) playerProps.writeWord(0x100 + pHead); else playerProps.writeByte(0);
        if (playerEquipment[playerHands] != null && playerEquipment[playerHands].id > 1) playerProps.writeWord(0x200 + playerEquipment[playerHands].id); else playerProps.writeWord(0x100 + pHands);
        if (playerEquipment[playerFeet] != null && playerEquipment[playerFeet].id > 1) playerProps.writeWord(0x200 + playerEquipment[playerFeet].id); else playerProps.writeWord(0x100 + pFeet);
        playerProps.writeByte(0);
        playerProps.writeByte(7);
        playerProps.writeByte(8);
        playerProps.writeByte(9);
        playerProps.writeByte(5);
        playerProps.writeByte(0);
        playerProps.writeWord(Animation.emote);
        playerProps.writeWord(0x337);
        playerProps.writeWord(0x333);
        playerProps.writeWord(0x334);
        playerProps.writeWord(0x335);
        playerProps.writeWord(0x336);
        playerProps.writeWord(0x338);
        playerProps.writeQWord(Misc.playerNameToInt64(playerName));
        int combatLevel = (int) ((double) playerLevel[0] * 0.32707 + (double) playerLevel[1] * 0.249 + (double) playerLevel[2] * 0.324 + (double) playerLevel[3] * 0.25 + (double) playerLevel[5] * 0.124);
        playerProps.writeByte(combatLevel);
        playerProps.writeWord(0);
        str.writeByteC(playerProps.currentOffset);
        str.writeBytes(playerProps.buffer, playerProps.currentOffset, 0);
    }

    public boolean chatTextUpdateRequired = false;

    public byte chatText[] = new byte[4096], chatTextSize = 0;

    public int chatTextEffects = 0, chatTextColor = 0;

    public void appendPlayerChatText(Stream str) {
        str.writeWordBigEndian(((chatTextColor & 0xFF) << 8) + (chatTextEffects & 0xFF));
        str.writeByte(playerRights);
        str.writeByteC(chatTextSize);
        str.writeBytes_reverse(chatText, chatTextSize, 0);
    }

    public void appendPlayerUpdateBlock(Stream str) {
        if (!updateRequired && !chatTextUpdateRequired) return;
        int updateMask = 0;
        if (chatTextUpdateRequired) updateMask |= 0x80;
        if (appearanceUpdateRequired) updateMask |= 0x10;
        if (updateMask >= 0x100) {
            updateMask |= 0x40;
            str.writeByte(updateMask & 0xFF);
            str.writeByte(updateMask >> 8);
        } else str.writeByte(updateMask);
        if (chatTextUpdateRequired) appendPlayerChatText(str);
        if (appearanceUpdateRequired) appendPlayerAppearance(str);
    }

    public void clearUpdateFlags() {
        updateRequired = false;
        chatTextUpdateRequired = false;
        appearanceUpdateRequired = false;
    }

    public static int newWalkCmdX[] = new int[walkingQueueSize];

    public static int newWalkCmdY[] = new int[walkingQueueSize];

    public static int newWalkCmdSteps = 0;

    public static boolean newWalkCmdIsRunning = false;

    public static int travelBackX[] = new int[walkingQueueSize];

    public static int travelBackY[] = new int[walkingQueueSize];

    public static int numTravelBackSteps = 0;

    public void newTrade() {
        System.out.println(playerName + ": Opens a new trade with " + tradeFrom + "!");
        tradeFrom = "";
        tradeFromID = 0;
        tradeWaitingTime = 0;
    }

    public void sendQuest(String s, int id) {
        outStream.createFrameVarSizeWord(126);
        outStream.writeString(s);
        outStream.writeWordA(id);
        outStream.endFrameVarSizeWord();
    }

    public void updateStats() {
        int online = Server.playerHandler.onlinePlayers();
        int localo = Server.playerHandler.onlinePlayers(absX, absY);
        String onlines = "";
        for (int i = (3 - (online + "").length()); i > 0; i--) onlines += "  ";
        try {
            onlines = onlines.substring(0, onlines.length() - 1);
        } catch (StringIndexOutOfBoundsException se) {
        }
        String localos = "";
        for (int i = (3 - (localo + "").length()); i > 0; i--) localos += "   ";
        UI.frame126("@dbl@@whi@Apollo Alpha Testing...", 6569);
        UI.frame126("@whi@                          " + onlines + "Players: " + online, 6570);
        UI.frame126("@whi@" + localos + "Local Players: " + localo, 6572);
        UI.frame126("@gre@           Safe Zone", 6664);
    }

    public boolean withinDistance(NpcModel npc) {
        if (heightLevel != npc.heightLevel) return false;
        if (npc.respawnNPC) return false;
        int deltaX = npc.absX - absX, deltaY = npc.absY - absY;
        return deltaX <= 15 && deltaX >= -16 && deltaY <= 15 && deltaY >= -16;
    }
}
