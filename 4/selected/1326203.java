package com.javampire.util.dao.db;

import com.javampire.util.Visitable;
import com.javampire.util.Visitor;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.IOException;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;

/**
 * Implements generic DB access.
 *
 * @author <a href="mailto:cnagy@ecircle.de">Csaba Nagy</a>
 * @version $Revision: 1.2 $ $Date: 2007/05/10 17:50:56 $
 */
public class DBNode<T> implements RandomAccessDataNode<T>, Visitable<T> {

    private final Class<T> recordClass;

    private final String tableName;

    private final DBNodeFactory factory;

    private final List<FieldDescriptor> fieldDescriptors;

    private final Map<String, FieldDescriptor> descriptorMap;

    private final List<FieldDescriptor> keyFields;

    private final List<FieldDescriptor> autoGeneratedFields;

    private final T[] buffer;

    private final String LOAD_SQL;

    private final String WALK_THROUGH_SQL;

    private final String LOOKUP_SQL;

    private final String DELETE_SQL;

    private final String INSERT_SQL;

    private final String UPDATE_SQL;

    private final String LOAD_AUTOGENERATED_FIELDS_SQL;

    private int bufferStart;

    private int bufferPosition;

    private int bufferLength;

    private int recordCount;

    DBNode(Class<T> recordClass, DBNodeFactory factory) throws IntrospectionException {
        this.recordClass = recordClass;
        this.factory = factory;
        if (!recordClass.isAnnotationPresent(Table.class)) {
            throw new IllegalArgumentException("No table annotation found on class: " + recordClass);
        }
        final Table tableAnnotation = recordClass.getAnnotation(Table.class);
        tableName = tableAnnotation.name();
        final BeanInfo beanInfo = Introspector.getBeanInfo(recordClass);
        PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();
        fieldDescriptors = new ArrayList<FieldDescriptor>(propertyDescriptors.length);
        descriptorMap = new HashMap<String, FieldDescriptor>(propertyDescriptors.length);
        keyFields = new ArrayList<FieldDescriptor>();
        autoGeneratedFields = new ArrayList<FieldDescriptor>();
        StringBuilder fieldList = new StringBuilder();
        StringBuilder updateList = new StringBuilder();
        StringBuilder insertParams = new StringBuilder();
        StringBuilder pkFieldList = new StringBuilder();
        StringBuilder pkCondition = new StringBuilder();
        StringBuilder autogeneratedFieldList = new StringBuilder();
        for (PropertyDescriptor descriptor : propertyDescriptors) {
            final Method readMethod = descriptor.getReadMethod();
            final Method writeMethod = descriptor.getWriteMethod();
            if (readMethod == null || writeMethod == null) continue;
            final Class<?> propertyType = descriptor.getPropertyType();
            final Field fieldAnnotation = readMethod.getAnnotation(Field.class);
            if (fieldAnnotation == null) continue;
            DBType dbType = fieldAnnotation.dbType();
            if (dbType == DBType.UNKNOWN) {
                dbType = DBType.getDefaultFromClass(propertyType);
            }
            if (!fieldDescriptors.isEmpty()) {
                fieldList.append(", ");
                insertParams.append(", ");
            }
            final String dbName = fieldAnnotation.dbName();
            fieldList.append(dbName);
            final boolean isPkField = fieldAnnotation.isPK();
            if (isPkField) {
                if (!keyFields.isEmpty()) {
                    pkFieldList.append(", ");
                    pkCondition.append(" and ");
                }
                pkFieldList.append(dbName);
                pkCondition.append(dbName).append(" = ?");
            } else {
                if (updateList.length() > 0) {
                    updateList.append(", ");
                }
                updateList.append(dbName).append(" = ?");
            }
            final String sequenceName = fieldAnnotation.sequenceName();
            boolean autogenerated = sequenceName.length() > 0;
            if (autogenerated) {
                if (!autoGeneratedFields.isEmpty()) {
                    autogeneratedFieldList.append(", ");
                }
                autogeneratedFieldList.append(factory.nextSyntax(sequenceName));
            }
            insertParams.append("?");
            final FieldDescriptor fieldDescriptor = new FieldDescriptor(propertyType, readMethod, writeMethod, dbType, dbName, isPkField, autogenerated);
            if (isPkField) {
                keyFields.add(fieldDescriptor);
            }
            if (autogenerated) {
                autoGeneratedFields.add(fieldDescriptor);
            }
            fieldDescriptors.add(fieldDescriptor);
            descriptorMap.put(descriptor.getName(), fieldDescriptor);
        }
        if (keyFields.isEmpty()) {
            throw new IllegalArgumentException("No primary key found in record class: " + recordClass);
        }
        StringBuilder insertSql = new StringBuilder("insert into ");
        insertSql.append(tableName).append("(").append(fieldList);
        insertSql.append(") values (").append(insertParams).append(")");
        INSERT_SQL = insertSql.toString();
        StringBuilder updateSql = new StringBuilder("update ");
        updateSql.append(tableName).append(" set ").append(updateList);
        updateSql.append(" where ").append(pkCondition);
        UPDATE_SQL = updateSql.toString();
        StringBuilder loadAutogeneratedFieldsSql = new StringBuilder("select ");
        loadAutogeneratedFieldsSql.append(autogeneratedFieldList);
        LOAD_AUTOGENERATED_FIELDS_SQL = loadAutogeneratedFieldsSql.toString();
        StringBuilder deleteSql = new StringBuilder("delete from ");
        deleteSql.append(tableName).append(" where ").append(pkCondition);
        DELETE_SQL = deleteSql.toString();
        StringBuilder loadSql = new StringBuilder("select ");
        loadSql.append(fieldList).append(" from ");
        loadSql.append(tableName);
        WALK_THROUGH_SQL = loadSql.toString();
        loadSql.append(" order by ").append(pkFieldList);
        loadSql.append(" limit 100 offset ");
        LOAD_SQL = loadSql.toString();
        StringBuilder lookupSql = new StringBuilder("select ");
        lookupSql.append(fieldList).append(" from ").append(tableName);
        lookupSql.append(" where ").append(pkCondition);
        LOOKUP_SQL = lookupSql.toString();
        buffer = (T[]) Array.newInstance(recordClass, 100);
        bufferLength = bufferStart = bufferPosition = 0;
        recordCount = -1;
    }

    public void writeRecord(final T record) throws IOException {
        if (!autoGeneratedFields.isEmpty()) {
            loadAutogeneratedFields(record);
        }
        new QueryUtil(factory, INSERT_SQL) {

            public void setParameters(PreparedStatement statement) throws IOException, SQLException {
                int i = 1;
                for (FieldDescriptor fieldDescriptor : fieldDescriptors) {
                    final Object value = readField(fieldDescriptor, record);
                    final int jdbcType = fieldDescriptor.getDbType().getJdbcType();
                    statement.setObject(i++, value, jdbcType);
                }
            }
        }.execute();
        invalidateBuffer();
        if (recordCount != -1) recordCount++;
    }

    private void loadAutogeneratedFields(final T record) throws IOException {
        new QueryUtil(factory, LOAD_AUTOGENERATED_FIELDS_SQL) {

            public Object processResultSet(ResultSet resultSet) throws IOException, SQLException {
                if (!resultSet.next()) {
                    throw new IllegalStateException("No results for autogenerated fields: " + autoGeneratedFields);
                }
                return loadRecord(resultSet, record, autoGeneratedFields);
            }
        }.execute();
    }

    public void flush() throws IOException {
    }

    public T lookup(final Object... idValues) throws IOException {
        return (T) new QueryUtil(factory, LOOKUP_SQL) {

            public void setParameters(PreparedStatement statement) throws SQLException {
                int i = 1;
                for (Object crtId : idValues) {
                    final int jdbcType = keyFields.get(i - 1).getDbType().getJdbcType();
                    statement.setObject(i++, crtId, jdbcType);
                }
            }

            public Object processResultSet(ResultSet resultSet) throws IOException, SQLException {
                if (!resultSet.next()) return null;
                return loadRecord(resultSet, null, fieldDescriptors);
            }
        }.execute();
    }

    public int update(final T record) throws IOException {
        int result = (Integer) new QueryUtil(factory, UPDATE_SQL) {

            public void setParameters(PreparedStatement statement) throws IOException, SQLException {
                int i = 1;
                for (FieldDescriptor crtDescriptor : fieldDescriptors) {
                    if (crtDescriptor.isPkField()) continue;
                    final int jdbcType = crtDescriptor.getDbType().getJdbcType();
                    statement.setObject(i++, readField(crtDescriptor, record), jdbcType);
                }
                for (FieldDescriptor crtDescriptor : keyFields) {
                    final int jdbcType = crtDescriptor.getDbType().getJdbcType();
                    statement.setObject(i++, readField(crtDescriptor, record), jdbcType);
                }
            }
        }.execute();
        invalidateBuffer();
        return result;
    }

    public void truncate() throws IOException {
        new QueryUtil(factory, "truncate " + tableName).execute();
        invalidateBuffer();
        recordCount = 0;
    }

    public int delete(final Object... idValues) throws IOException {
        int result = (Integer) new QueryUtil(factory, DELETE_SQL) {

            public void setParameters(PreparedStatement statement) throws SQLException {
                int i = 1;
                for (Object crtId : idValues) {
                    final int jdbcType = keyFields.get(i - 1).getDbType().getJdbcType();
                    statement.setObject(i++, crtId, jdbcType);
                }
            }
        }.execute();
        invalidateBuffer();
        if (recordCount != -1) recordCount -= result;
        return result;
    }

    public int deleteByExample(final T example) throws IOException {
        StringBuilder queryList = new StringBuilder();
        final ArrayList<Object> params = new ArrayList<Object>();
        final ArrayList<DBType> dbTypes = new ArrayList<DBType>();
        for (FieldDescriptor crtDescriptor : fieldDescriptors) {
            final Object crtValue;
            crtValue = readField(crtDescriptor, example);
            if (crtValue != null) {
                if (queryList.length() > 0) queryList.append(" and ");
                queryList.append(crtDescriptor.getDbName()).append(" = ?");
                params.add(crtValue);
                dbTypes.add(crtDescriptor.getDbType());
            }
        }
        String SQL = "delete from " + tableName;
        if (queryList.length() > 0) {
            SQL += " where " + queryList;
        }
        return (Integer) new QueryUtil(factory, SQL) {

            public void setParameters(PreparedStatement statement) throws SQLException {
                for (int i = 0; i < params.size(); i++) {
                    final Object crtParam = params.get(i);
                    final int jdbcType = dbTypes.get(i).getJdbcType();
                    statement.setObject(i + 1, crtParam, jdbcType);
                }
            }
        }.execute();
    }

    public List<T> findByExample(final T example, final T nullFieldExample) throws IOException {
        StringBuilder fieldList = new StringBuilder();
        StringBuilder queryList = new StringBuilder();
        final ArrayList<FieldDescriptor> descriptorList = new ArrayList<FieldDescriptor>();
        final ArrayList<FieldDescriptor> nullFiledList = new ArrayList<FieldDescriptor>();
        final ArrayList<Object> params = new ArrayList<Object>();
        final ArrayList<DBType> dbTypes = new ArrayList<DBType>();
        for (FieldDescriptor crtDescriptor : fieldDescriptors) {
            final Object crtValue;
            if (readField(crtDescriptor, nullFieldExample) != null) {
                if (queryList.length() > 0) queryList.append(" and ");
                queryList.append(crtDescriptor.getDbName()).append(" is null");
                nullFiledList.add(crtDescriptor);
            } else if ((crtValue = readField(crtDescriptor, example)) == null) {
                if (fieldList.length() > 0) fieldList.append(", ");
                fieldList.append(crtDescriptor.getDbName());
                descriptorList.add(crtDescriptor);
            } else {
                if (queryList.length() > 0) queryList.append(" and ");
                queryList.append(crtDescriptor.getDbName()).append(" = ?");
                params.add(crtValue);
                dbTypes.add(crtDescriptor.getDbType());
            }
        }
        if (fieldList.length() == 0) {
            throw new IOException("The example is a complete bean, nothing to look up");
        }
        String SQL = "select " + fieldList + " from " + tableName;
        if (queryList.length() > 0) {
            SQL += " where " + queryList;
        }
        final List<T> result = new ArrayList<T>();
        new QueryUtil(factory, SQL) {

            public void setParameters(PreparedStatement statement) throws SQLException {
                for (int i = 0; i < params.size(); i++) {
                    final Object crtParam = params.get(i);
                    final int jdbcType = dbTypes.get(i).getJdbcType();
                    statement.setObject(i + 1, crtParam, jdbcType);
                }
            }

            public void processRow(ResultSet resultSet) throws IOException, SQLException {
                T record = newRecord();
                copy(example, record);
                for (FieldDescriptor fieldDescriptor : nullFiledList) {
                    setField(fieldDescriptor, record, null);
                }
                result.add(loadRecord(resultSet, record, descriptorList));
            }
        }.execute();
        return result;
    }

    public void walkThrough(final Visitor<T> visitor) throws IOException {
        walkThrough(visitor, new String[0]);
    }

    public void walkThrough(final Visitor<T> visitor, String... orderByProperties) throws IOException {
        String sql = WALK_THROUGH_SQL;
        if (orderByProperties.length > 0) {
            sql += " order by";
            for (int i = 0; i < orderByProperties.length; i++) {
                final FieldDescriptor fieldDescriptor = descriptorMap.get(orderByProperties[i]);
                if (i > 0) {
                    sql += ",";
                }
                sql += " " + fieldDescriptor.getDbName();
            }
        }
        new QueryUtil(factory, sql) {

            T record = null;

            @Override
            public void setParameters(PreparedStatement statement) throws IOException, SQLException {
                super.setParameters(statement);
                statement.setFetchSize(50);
            }

            public void processRow(ResultSet resultSet) throws IOException, SQLException {
                record = loadRecord(resultSet, record, fieldDescriptors);
                visitor.visit(record);
            }
        }.execute();
    }

    public boolean seek(int recordId) throws IOException {
        if (recordId == getRecordId()) return true;
        int newPosition = recordId - bufferStart;
        if (newPosition >= 0 && newPosition < bufferLength) {
            bufferPosition = newPosition;
            return true;
        }
        if (recordId >= getRecordCount()) return false;
        bufferStart = recordId;
        bufferPosition = bufferLength = 0;
        return true;
    }

    public boolean hasNext() throws IOException {
        if (bufferPosition < bufferLength) return true;
        return getRecordId() < getRecordCount();
    }

    public T next(T record) throws IOException {
        if (record == null) record = newRecord();
        if (bufferPosition < bufferLength) {
            copy(buffer[bufferPosition++], record);
            return record;
        }
        bufferStart = getRecordId();
        bufferPosition = 0;
        bufferLength = 0;
        final String sql = LOAD_SQL + bufferStart;
        new QueryUtil(factory, sql) {

            public void processRow(ResultSet resultSet) throws SQLException, IOException {
                buffer[bufferLength++] = loadRecord(resultSet, null, fieldDescriptors);
            }
        }.execute();
        if (bufferPosition < bufferLength) {
            copy(buffer[bufferPosition++], record);
            return record;
        }
        throw new IOException("No more records to read");
    }

    public int getRecordCount() throws IOException {
        if (recordCount != -1) return recordCount;
        recordCount = (Integer) new QueryUtil(factory, "select count(*) from " + tableName) {

            public Object processResultSet(ResultSet resultSet) throws SQLException {
                if (!resultSet.next()) return 0;
                return resultSet.getInt(1);
            }
        }.execute();
        return recordCount;
    }

    public int getRecordId() {
        return bufferStart + bufferPosition;
    }

    public void close() {
        bufferLength = bufferPosition = 0;
        Arrays.fill(buffer, null);
    }

    public T newRecord() {
        try {
            return recordClass.newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void copy(T record, T destination) {
        for (FieldDescriptor fieldDescriptor : fieldDescriptors) {
            try {
                fieldDescriptor.getWriteMethod().invoke(destination, readField(fieldDescriptor, record));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private T loadRecord(ResultSet resultSet, T record, List<FieldDescriptor> descriptors) throws IOException, SQLException {
        if (record == null) record = newRecord();
        int i = 1;
        for (FieldDescriptor fieldDescriptor : descriptors) {
            setField(fieldDescriptor, record, resultSet.getObject(i++));
        }
        return record;
    }

    private Object readField(FieldDescriptor crtDescriptor, T record) throws IOException {
        if (crtDescriptor == null || record == null) return null;
        try {
            return crtDescriptor.getReadMethod().invoke(record);
        } catch (IllegalAccessException e) {
            throw new IOException(e);
        } catch (InvocationTargetException e) {
            throw new IOException(e);
        }
    }

    private void setField(FieldDescriptor fieldDescriptor, T record, Object value) throws IOException {
        try {
            fieldDescriptor.getWriteMethod().invoke(record, value);
        } catch (IllegalAccessException e) {
            throw new IOException(e);
        } catch (InvocationTargetException e) {
            throw new IOException(e);
        }
    }

    private void invalidateBuffer() {
        bufferStart = getRecordId();
        if (bufferLength > 0) {
            Arrays.fill(buffer, 0, bufferLength, null);
        }
        bufferPosition = bufferLength = 0;
    }
}
