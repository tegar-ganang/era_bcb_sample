package com.xenoage.zong.io.pino10.out;

import static com.xenoage.kernel.Range.range;
import static com.xenoage.util.CollectionUtils.set;
import static com.xenoage.util.math.Fraction.fr;
import static com.xenoage.util.xml.XMLWriter.addAttribute;
import static com.xenoage.util.xml.XMLWriter.addElement;
import static com.xenoage.util.xml.XMLWriter.createEmptyDocument;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Set;
import javax.sound.midi.MidiSystem;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import com.xenoage.util.CommandLine;
import com.xenoage.util.FileUtils;
import com.xenoage.util.MathUtils;
import com.xenoage.util.annotations.NeverNull;
import com.xenoage.util.logging.Log;
import com.xenoage.util.logging.LogLevel;
import com.xenoage.util.math.Fraction;
import com.xenoage.util.math.Point2f;
import com.xenoage.util.xml.XMLWriter;
import com.xenoage.util.zip.ZipUtils;
import com.xenoage.zong.Zong;
import com.xenoage.zong.converter.Converter;
import com.xenoage.zong.core.Score;
import com.xenoage.zong.documents.ScoreDoc;
import com.xenoage.zong.io.FileFormat;
import com.xenoage.zong.io.ScoreDocFileOutput;
import com.xenoage.zong.io.midi.out.MidiConverter;
import com.xenoage.zong.io.midi.out.MidiTime;
import com.xenoage.zong.io.midi.out.SequenceContainer;
import com.xenoage.zong.io.midi.out.SynthManager;
import com.xenoage.zong.io.sampled.out.MidiToWaveRenderer;
import com.xenoage.zong.layout.Layout;
import com.xenoage.zong.layout.Page;
import com.xenoage.zong.layout.frames.Frame;
import com.xenoage.zong.layout.frames.ScoreFrame;
import com.xenoage.zong.musiclayout.BeatOffset;
import com.xenoage.zong.musiclayout.MeasureMarks;
import com.xenoage.zong.musiclayout.ScoreFrameLayout;
import com.xenoage.zong.musiclayout.stampings.StaffStamping;
import com.xenoage.zong.print.PNGPrinter;

/**
 * This class writes a Pinocchio 2010 file from a given {@link ScoreDoc}.
 * Both "pino10" and "pino10z" (compressed version) are supported.
 * 
 * When an additional parameter in the command line is found, namely
 * --pino10map {mapfile}", not a track for each staff is created, but
 * staves can be grouped to tracks.
 * 
 * @author Andreas Wenger
 */
public class Pinocchio2010ScoreDocumentFileOutput implements ScoreDocFileOutput {

    private class System {

        int page = 0;

        float top = Integer.MAX_VALUE;

        float bottom = Integer.MIN_VALUE;
    }

    private class Measure {

        int system = 0;

        float left = 0;

        float right = 0;

        HashMap<Fraction, Float> beats = new HashMap<Fraction, Float>();
    }

    /**
	 * Writes the given {@link ScoreDoc} to the given file.
	 */
    @Override
    public void write(ScoreDoc doc, OutputStream out, @NeverNull String filePath, FileFormat format) throws IOException {
        if (filePath == null) throw new IOException("File path is needed, because multiples files are written");
        File file = new File(filePath);
        PrintStream progressLogStream = java.lang.System.out;
        if (format.getID().equals("pino10z")) {
            progressLogStream.println("Creating temp folder...");
            File dir = FileUtils.createNewTempFolder();
            write(doc, dir, FileUtils.getNameWithoutExt(file) + ".pino10", progressLogStream);
            progressLogStream.println("Compressing to .pino10z file...");
            ZipUtils.compressAll(dir, file);
            FileUtils.deleteDirectory(dir);
        } else {
            write(doc, file.getParentFile(), file.getName(), progressLogStream);
        }
        progressLogStream.println("Done.");
    }

    public void write(ScoreDoc doc, File dir, String mainFileName, PrintStream progressLogStream) throws IOException {
        progressLogStream.println("Writing Pinocchio 2010 file...");
        FileUtils.writeFile("generated by " + Zong.getNameAndVersion(Converter.PROJECT_FIRST_NAME) + " on " + new Date(), new File(dir, mainFileName).getAbsolutePath());
        if (doc.getFilePath() != null) {
            progressLogStream.println("Copy MusicXML file...");
            FileUtils.copyFile(doc.getFilePath(), new File(dir, "score.xml").getAbsolutePath());
        }
        Layout layout = doc.getLayout();
        progressLogStream.println("Write pages...");
        writeProgress(progressLogStream, 0, false);
        for (int i = 0; i < layout.pages.size(); i++) {
            PNGPrinter.print(layout, i, new FileOutputStream(new File(dir, "page" + i + ".png")));
            writeProgress(progressLogStream, 1f * (i + 1) / layout.pages.size(), false);
        }
        writeProgress(progressLogStream, 1, true);
        progressLogStream.println("Write beat offsets...");
        XMLWriter.writeFile(createCursorDocument(doc.getScore(), layout), new FileOutputStream(new File(dir, "cursor.xml")));
        createMIDIAndMPMappingAndWAVs(doc.getScore(), dir, progressLogStream);
    }

    private Document createCursorDocument(Score score, Layout layout) {
        int measuresCount = score.getMeasuresCount();
        ArrayList<System> systems = new ArrayList<System>();
        ArrayList<Measure> measures = new ArrayList<Measure>();
        for (int i = 0; i < measuresCount; i++) {
            measures.add(new Measure());
        }
        int systemCount = 0;
        for (int iPage : range(layout.pages)) {
            Page page = layout.pages.get(iPage);
            for (Frame frame : page.frames) {
                if (frame instanceof ScoreFrame) {
                    Point2f absPos = frame.getAbsolutePosition(layout);
                    float offsetX = absPos.x - frame.getSize().width / 2;
                    float offsetY = absPos.y - frame.getSize().height / 2;
                    ScoreFrameLayout sfl = layout.getScoreFrameLayout((ScoreFrame) frame);
                    for (StaffStamping ss : sfl.getStaffStampings()) {
                        int systemIndex = systemCount + ss.getSystemIndex();
                        while (systems.size() - 1 < systemIndex) systems.add(new System());
                        System system = systems.get(systemIndex);
                        system.page = iPage;
                        system.top = Math.min(ss.position.y + offsetY, system.top);
                        system.bottom = Math.max(ss.position.y + (ss.linesCount - 1) * ss.is + offsetY, system.bottom);
                        for (MeasureMarks mm : ss.staffMarks.getMeasureMarks()) {
                            Measure measure = measures.get(ss.getStartMeasureIndex() + mm.getMeasure());
                            measure.system = systemIndex;
                            measure.left = mm.getStartMm() + offsetX;
                            measure.right = mm.getEndMm() + offsetX;
                            for (BeatOffset bo : mm.getBeatOffsets()) {
                                measure.beats.put(bo.getBeat(), bo.getOffsetMm());
                            }
                        }
                    }
                    systemCount += sfl.getFrameArrangement().getSystems().size();
                }
            }
        }
        Document xmlDoc = createEmptyDocument();
        Element eRoot = addElement("cursor", xmlDoc);
        Element eSystems = addElement("systems", eRoot);
        for (int i = 0; i < systems.size(); i++) {
            System system = systems.get(i);
            Element eSystem = addElement("system", eSystems);
            addAttribute(eSystem, "number", i);
            addAttribute(eSystem, "page", system.page);
            addAttribute(eSystem, "top", system.top);
            addAttribute(eSystem, "bottom", system.bottom);
        }
        Element eMeasures = addElement("measures", eRoot);
        for (int i = 0; i < measuresCount; i++) {
            Measure measure = measures.get(i);
            Element eMeasure = addElement("measure", eMeasures);
            addAttribute(eMeasure, "number", i);
            addAttribute(eMeasure, "system", measure.system);
            addAttribute(eMeasure, "left", measure.left);
            addAttribute(eMeasure, "right", measure.right);
            ArrayList<Fraction> sortedBeats = new ArrayList<Fraction>(measure.beats.keySet());
            Collections.sort(sortedBeats);
            for (Fraction beat : sortedBeats) {
                Element eBeat = addElement("beat", eMeasure);
                addAttribute(eBeat, "at", beat);
                addAttribute(eBeat, "x", measure.beats.get(beat));
            }
        }
        return xmlDoc;
    }

    private void createMIDIAndMPMappingAndWAVs(Score score, File dir, PrintStream progressLogStream) throws IOException {
        progressLogStream.println("Write Midi file...");
        SequenceContainer sc = MidiConverter.convertToSequence(score, true, false, fr(1, 1));
        int[] types = MidiSystem.getMidiFileTypes(sc.sequence);
        int type = 0;
        if (types.length != 0) {
            type = types[types.length - 1];
        }
        MidiSystem.write(sc.sequence, type, new File(dir, "midi.mid"));
        progressLogStream.println("Write MPs map...");
        Document xmlDoc = createEmptyDocument();
        Element eRoot = addElement("midi", xmlDoc);
        Element eMPs = addElement("mps", eRoot);
        for (MidiTime time : sc.timePool) {
            Element eSystem = addElement("mp", eMPs);
            addAttribute(eSystem, "tick", time.tick);
            addAttribute(eSystem, "measure", time.mp.getMeasure());
            addAttribute(eSystem, "beat", time.mp.getBeat());
        }
        XMLWriter.writeFile(xmlDoc, new FileOutputStream(new File(dir, "midi.xml")));
        Pino10Map pino10Map = null;
        String[] args = CommandLine.getArgs();
        for (int i = 0; args != null && i < args.length - 1; i++) {
            if (args[i].equals("--pino10map")) {
                progressLogStream.println("Reading pino10map...");
                File pino10MapFile = new File(args[i + 1]);
                pino10Map = new Pino10Map(pino10MapFile);
                progressLogStream.println("Copy pino10map...");
                FileUtils.copyFile(pino10MapFile.getAbsolutePath(), new File(dir, pino10MapFile.getName()).getAbsolutePath());
                break;
            }
        }
        progressLogStream.println("Synthesize and write WAV files...");
        writeProgress(progressLogStream, 0, false);
        try {
            int[] lengths = new int[] { 3, 6, 8 };
            for (int articulation : range(0, 2)) {
                sc = MidiConverter.convertToSequence(score, false, false, fr(lengths[articulation], 8));
                int tracksCount = sc.sequence.getTracks().length;
                String art = (articulation == 0 ? "staccato" : articulation == 1 ? "normal" : "legato");
                MidiToWaveRenderer.render(SynthManager.getSoundbank(), sc.sequence, null, new File(dir, "all-" + art + ".wav"));
                if (pino10Map != null) {
                    int trackPos = 1;
                    int partsCount = pino10Map.partsStavesCount.size();
                    for (int iPart = 0; iPart < partsCount; iPart++) {
                        int stavesCount = pino10Map.partsStavesCount.get(iPart);
                        Set<Integer> tracks = set(0);
                        for (int i = 0; i < stavesCount; i++) tracks.add(trackPos + i);
                        trackPos += stavesCount;
                        MidiToWaveRenderer.render(SynthManager.getSoundbank(), sc.sequence, tracks, new File(dir, "part-" + iPart + "-" + art + ".wav"));
                        writeProgress(progressLogStream, 1f * (articulation * partsCount + iPart + 1) / (partsCount * 3), false);
                    }
                } else {
                    for (int iTrack = 1; iTrack < tracksCount; iTrack++) {
                        Set<Integer> tracks = set(0, iTrack);
                        MidiToWaveRenderer.render(SynthManager.getSoundbank(), sc.sequence, tracks, new File(dir, "part-" + iTrack + "-" + art + ".wav"));
                        writeProgress(progressLogStream, 1f * (articulation * tracksCount + iTrack + 1) / (tracksCount * 3), false);
                    }
                }
            }
            writeProgress(progressLogStream, 1, true);
        } catch (Exception ex) {
            ex.printStackTrace();
            Log.log(LogLevel.Warning, ex);
        }
    }

    private void writeProgress(PrintStream out, float progress, boolean newLine) {
        int length = 50;
        int x = (int) (MathUtils.clamp(progress, 0, 1) * length);
        out.print("|");
        for (int i = 0; i < x; i++) out.print("=");
        for (int i = 0; i < length - x; i++) out.print(" ");
        out.print("|\r");
        if (newLine) out.println();
    }
}
