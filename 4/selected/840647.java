package edu.ucsd.ncmir.nuages.tools.repros2visu;

import edu.ucsd.ncmir.nuages.utilities.SplitReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Date;

/**
 *
 * @author spl
 */
public class Repros2Visu {

    public static final int OBJ = 0;

    public static final int VERA = 1;

    public static final int IDX = 2;

    public static final int ACT = 3;

    public static final int OFF = 4;

    public static final int DXF = 5;

    public static final int AVS = 6;

    public static final int VRML = 7;

    public static final int INV = 8;

    public static final int STL = 9;

    private static final int LOWER = 0;

    private static final int UPPER = 1;

    private static final int ALL = 2;

    private static final int ADD = 0;

    private static final int SUB = 1;

    private static final int MAXVERTEX = 100000;

    private void MATRIX_MULT(double[] w, double[][] M, double[] v) {
        w[0] = M[0][0] * v[0] + M[0][1] * v[1] + M[0][2] * v[2] + M[0][3];
        w[1] = M[1][0] * v[0] + M[1][1] * v[1] + M[1][2] * v[2] + M[1][3];
        w[2] = M[2][0] * v[0] + M[2][1] * v[1] + M[2][2] * v[2] + M[2][3];
    }

    private void MATRIX_MULTV(double[] w, double[][] M, double[] v) {
        w[0] = M[0][0] * v[0] + M[0][1] * v[1] + M[0][2] * v[2];
        w[1] = M[1][0] * v[0] + M[1][1] * v[1] + M[1][2] * v[2];
        w[2] = M[2][0] * v[0] + M[2][1] * v[1] + M[2][2] * v[2];
    }

    private double VEC_LEN(double[] v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    }

    private void VEC_DIV(double[] v, double a) {
        v[0] /= a;
        v[1] /= a;
        v[2] /= a;
    }

    private void VEC_NORM(double[] v) {
        double l = VEC_LEN(v);
        VEC_DIV(v, l);
    }

    private int _maxvertex;

    private int _maxfacett;

    private boolean _mv_changed;

    private boolean _mf_changed;

    private int[] _remove_h = new int[100];

    private String[] _fnam = new String[6];

    private double _direction;

    private String _vertex_file_name;

    private String _tile_file_name;

    private String _normidx_file_name;

    private String _normal_file_name;

    private SplitReader _koord_file;

    private SplitReader _fac_file;

    private PrintStream _out_file;

    private PrintStream _vertex_file;

    private PrintStream _normal_file;

    private PrintStream _tile_file;

    private PrintStream _normidx_file;

    private int[] _fac_buffer = new int[3];

    private double[] _norm_buffer = new double[3];

    private int _koord_count = 0;

    private int _fac_count = 0;

    private boolean _remove_horizontal = false;

    private short _n_remove = 0;

    private short _n_nosmooth = 0;

    private int[] _nosmooth = new int[10];

    private short _plane_counter = 0;

    private int _nb_slices = 0;

    private int _nb_sections = 0;

    private int _out_format = OBJ;

    private boolean _no_weight = false;

    private int _obj_offset = 0;

    private String _obj_name = "object";

    private String _header = "";

    private boolean _mmult = false;

    private double[][] _matrix = new double[][] { { 1.0, 0.0, 0.0, 0.0 }, { 0.0, 1.0, 0.0, 0.0 }, { 0.0, 0.0, 1.0, 0.0 }, { 0.0, 0.0, 0.0, 1.0 } };

    private int[] _idx_fac_buffer;

    private int _idx_count = 0;

    public void process() throws FileNotFoundException, IOException {
        FacSlice facett0;
        FacSlice facett1;
        FacSlice fac0;
        FacSlice fac1;
        FacSlice help_fac;
        Plane plane0;
        Plane plane1;
        Plane plane2;
        Plane pl0;
        Plane pl1;
        Plane pl2;
        Plane help_pl;
        int i;
        int j;
        boolean ns = false;
        int nb_idx_fac;
        int[] do_next = new int[] { 1 };
        String date = new Date().toString();
        _mf_changed = _mv_changed = false;
        _maxvertex = MAXVERTEX;
        _maxfacett = 4 * (_maxvertex - 1);
        if (_mv_changed && !_mf_changed) _maxfacett = 4 * (_maxvertex - 1);
        _fac_file = new SplitReader(_fnam[0]);
        _koord_file = new SplitReader(_fnam[1]);
        _nb_sections = Integer.parseInt(_koord_file.getTokens()[1]);
        _out_file = new PrintStream(_fnam[2]);
        _nb_slices = Integer.parseInt(_fac_file.getTokens()[0]);
        if (_nb_slices != _nb_sections - 1) throw new AssertionError("error: " + _nb_sections + "sections vs " + _nb_slices + " slices");
        switch(_out_format) {
            case OBJ:
                {
                    _out_file.printf("# File generated by nuages-repros\n");
                    _out_file.printf("# %s\n", date);
                    if (_header.length() != 0) _out_file.printf("# %s\n", _header);
                    _out_file.printf("# %d slices\n", _nb_slices);
                    _out_file.printf("g %s\n", _obj_name);
                    break;
                }
            case VRML:
            case INV:
                {
                    if (_out_format == INV) {
                        _out_file.printf("#Inventor V2.0 ascii\n\n");
                        _out_format = VRML;
                    } else _out_file.printf("#VRML V1.0 ascii\n\n");
                    _out_file.printf("Separator {\n");
                    _out_file.printf("Info { string \" Generated by NUAGES \n");
                    _out_file.printf(" %s \"}\n\n", date);
                    if (_header.length() != 0) _out_file.printf("Info { string \" %s \"}\n\n", _header);
                    _out_file.printf("ShapeHints {\n  vertexOrdering  COUNTERCLOCKWISE\n");
                    _out_file.printf("  faceType CONVEX\n}\n\n");
                    _out_file.printf("# %d slice[s]\n", _nb_slices);
                    vertex_normal_face_open();
                    _vertex_file.printf("Coordinate3{ point[\n");
                    _normal_file.printf("Normal{ vector [\n");
                    _tile_file.printf("IndexedFaceSet{ coordIndex[\n");
                    _normidx_file.printf("normalIndex [\n");
                    break;
                }
            case OFF:
                _out_file.printf("# File generated by nuages-repros\n");
                _out_file.printf("# %s", date);
                if (_header.length() != 0) _out_file.printf("# %s\n", _header);
                _out_file.printf("# %d slices\n", _nb_slices);
                _out_file.printf("# off file with per vertex normal\n");
                _out_file.printf("NOFF\n");
                vertex_face_open();
                break;
            case STL:
                _n_nosmooth = 0;
                _out_file.printf("SOLID\n");
                break;
            case DXF:
                _n_nosmooth = 0;
                _out_file.printf("999\nFile generated by nuages-repros\n");
                _out_file.printf("999\n%s", date);
                if (_header.length() != 0) _out_file.printf("999\n%s\n", _header);
                _out_file.printf("  0\nSECTION\n  2\nHEADER\n  0\nENDSEC\n");
                _out_file.printf("  0\nSECTION\n  2\nENTITIES\n  0\n");
                break;
            case VERA:
                _out_file.printf("( * File generated by nuages-repros\n");
                _out_file.printf("   %s* )\n", date);
                if (_header.length() != 0) _out_file.printf("( * %s * )\n", _header);
                break;
            case IDX:
                if (_mmult) throw new AssertionError("IDX format: -matrix not supported.");
                if (_header.length() != 0) _out_file.printf("%s\n", _header);
                _out_file.printf("S %d\n", _nb_slices);
                break;
            case ACT:
                vertex_face_open();
                break;
            case AVS:
                _out_file.printf("smooth\n");
                vertex_face_open();
                break;
        }
        pl0 = plane0 = new Plane(_maxvertex, _maxfacett);
        pl1 = plane1 = new Plane(_maxvertex, _maxfacett);
        pl2 = plane2 = new Plane(_maxvertex, _maxfacett);
        fac0 = facett0 = new FacSlice(_maxfacett);
        fac1 = facett1 = new FacSlice(_maxfacett);
        fac0.nb = 0;
        fac0.nb0 = 0;
        fac0.nb01 = 0;
        fac0.nb1 = 0;
        pl0.start = 0;
        pl0.stop = 0;
        _fac_buffer[0] = -1;
        read_points(pl1);
        init(pl1);
        for (i = 0; i < _nb_slices; i++) {
            read_points(pl2);
            init(pl2);
            _plane_counter++;
            read_facettes(fac1, pl1, pl2);
            this._log_stream.printf("slice #%d\n", i + 1);
            elim_double(fac0, fac1);
            for (j = 0; j < _n_nosmooth; j++) if (_nosmooth[j] == _plane_counter) {
                ns = true;
                break;
            }
            if (ns) {
                if (_plane_counter == 1) {
                    switch(_out_format) {
                        case VERA:
                            write_vera_facettes(fac1, pl1, pl2, LOWER);
                            eliminate_horizontal(fac1, pl1, pl2, LOWER);
                            break;
                        case OFF:
                            write_off_points(pl1, LOWER);
                            write_off_facettes(fac1, pl1, pl2, LOWER);
                            eliminate_horizontal(fac1, pl1, pl2, LOWER);
                            norm_(fac1, pl1, pl2);
                            write_off_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case AVS:
                            write_avs_points(pl1, LOWER);
                            write_avs_facettes(fac1, pl1, pl2, LOWER);
                            eliminate_horizontal(fac1, pl1, pl2, LOWER);
                            norm_(fac1, pl1, pl2);
                            write_avs_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case ACT:
                            write_act_points(pl1, LOWER);
                            write_act_facettes(fac1, pl1, pl2, LOWER);
                            eliminate_horizontal(fac1, pl1, pl2, LOWER);
                            norm_(fac1, pl1, pl2);
                            write_act_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case OBJ:
                            write_obj_points(pl1, LOWER);
                            write_obj_facettes(fac1, pl1, pl2, LOWER);
                            eliminate_horizontal(fac1, pl1, pl2, LOWER);
                            norm_(fac1, pl1, pl2);
                            write_obj_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case VRML:
                            write_vrml_points(pl1, LOWER);
                            write_vrml_facettes(fac1, pl1, pl2, LOWER);
                            eliminate_horizontal(fac1, pl1, pl2, LOWER);
                            norm_(fac1, pl1, pl2);
                            write_vrml_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case IDX:
                            nb_idx_fac = calc_index_facettes(fac1, pl1, pl2, LOWER);
                            write_index_points(pl1, LOWER, 0);
                            save_index_facettes(fac1, pl1, pl2, LOWER);
                            eliminate_horizontal(fac1, pl1, pl2, LOWER);
                            norm_(fac1, pl1, pl2);
                            write_index_points(pl1, ALL, -1);
                            do_next[0] = 0;
                            shift_indices(pl1, pl2, ADD);
                            break;
                        default:
                            throw new AssertionError("option -n currently not supported with first or last section.");
                    }
                } else {
                    norm_2(fac1, pl1, pl2);
                    switch(_out_format) {
                        case VERA:
                            write_vera_facettes(fac0, pl0, pl1, ALL);
                            norm_(fac1, pl1, pl2);
                            break;
                        case IDX:
                            nb_idx_fac = calc_index_facettes(fac0, pl1, pl2, ALL);
                            write_index_facettes(fac0, pl0, pl1, ALL, do_next, nb_idx_fac);
                            write_index_points(pl1, ALL, 0);
                            norm_(fac1, pl1, pl2);
                            write_index_points(pl1, ALL, -1);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case AVS:
                            write_avs_facettes(fac0, pl0, pl1, ALL);
                            write_avs_points(pl1, ALL);
                            norm_(fac1, pl1, pl2);
                            write_avs_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case ACT:
                            write_act_facettes(fac0, pl0, pl1, ALL);
                            write_act_points(pl1, ALL);
                            norm_(fac1, pl1, pl2);
                            write_act_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case VRML:
                            write_vrml_facettes(fac0, pl0, pl1, ALL);
                            write_vrml_points(pl1, ALL);
                            norm_(fac1, pl1, pl2);
                            write_vrml_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case OBJ:
                            write_obj_facettes(fac0, pl0, pl1, ALL);
                            write_obj_points(pl1, ALL);
                            norm_(fac1, pl1, pl2);
                            write_obj_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                        case OFF:
                            write_off_facettes(fac0, pl0, pl1, ALL);
                            write_off_points(pl1, ALL);
                            norm_(fac1, pl1, pl2);
                            write_off_points(pl1, ALL);
                            shift_indices(pl1, pl2, ADD);
                            break;
                    }
                }
                ns = false;
            } else {
                norm_(fac1, pl1, pl2);
                switch(_out_format) {
                    case VERA:
                        write_vera_facettes(fac0, pl0, pl1, ALL);
                        break;
                    case STL:
                        write_stl_facettes(fac0, pl0, pl1);
                        break;
                    case DXF:
                        write_dxf_facettes(fac0, pl0, pl1);
                        break;
                    case ACT:
                        write_act_points(pl1, ALL);
                        write_act_facettes(fac0, pl0, pl1, ALL);
                        break;
                    case IDX:
                        nb_idx_fac = calc_index_facettes(fac0, pl1, pl2, ALL);
                        if (i > 0) write_index_facettes(fac0, pl0, pl1, ALL, do_next, nb_idx_fac);
                        write_index_points(pl1, ALL, 1);
                        break;
                    case OFF:
                        write_off_points(pl1, ALL);
                        write_off_facettes(fac0, pl0, pl1, ALL);
                        break;
                    case OBJ:
                        write_obj_points(pl1, ALL);
                        write_obj_facettes(fac0, pl0, pl1, ALL);
                        break;
                    case VRML:
                        write_vrml_points(pl1, ALL);
                        write_vrml_facettes(fac0, pl0, pl1, ALL);
                        break;
                    case AVS:
                        write_avs_points(pl1, ALL);
                        write_avs_facettes(fac0, pl0, pl1, ALL);
                        break;
                }
            }
            help_fac = fac0;
            fac0 = fac1;
            fac1 = help_fac;
            help_pl = pl0;
            pl0 = pl1;
            pl1 = pl2;
            pl2 = help_pl;
        }
        fac1.nb = 0;
        for (j = 0; j < _n_nosmooth; j++) if (_nosmooth[j] == _plane_counter + 1) {
            ns = true;
            break;
        }
        if (ns) {
            switch(_out_format) {
                case VERA:
                    write_vera_facettes(fac0, pl0, pl1, UPPER);
                    eliminate_horizontal(fac0, pl0, pl1, UPPER);
                    norm_(fac1, pl1, pl2);
                    write_vera_facettes(fac0, pl0, pl1, ALL);
                    break;
                case OFF:
                    shift_indices(pl1, pl2, ADD);
                    write_off_facettes(fac0, pl0, pl1, UPPER);
                    shift_indices(pl1, pl2, SUB);
                    eliminate_horizontal(fac0, pl0, pl1, UPPER);
                    norm_(fac1, pl1, pl2);
                    write_off_points(pl1, ALL);
                    write_off_facettes(fac0, pl0, pl1, ALL);
                    write_off_points(pl1, UPPER);
                    shift_indices(pl1, pl2, ADD);
                    break;
                case OBJ:
                    shift_indices(pl1, pl2, ADD);
                    write_obj_facettes(fac0, pl0, pl1, UPPER);
                    shift_indices(pl1, pl2, SUB);
                    eliminate_horizontal(fac0, pl0, pl1, UPPER);
                    norm_(fac1, pl1, pl2);
                    write_obj_points(pl1, ALL);
                    write_obj_facettes(fac0, pl0, pl1, ALL);
                    write_obj_points(pl1, UPPER);
                    shift_indices(pl1, pl2, ADD);
                    break;
                case VRML:
                    shift_indices(pl1, pl2, ADD);
                    write_vrml_facettes(fac0, pl0, pl1, UPPER);
                    shift_indices(pl1, pl2, SUB);
                    eliminate_horizontal(fac0, pl0, pl1, UPPER);
                    norm_(fac1, pl1, pl2);
                    write_vrml_points(pl1, ALL);
                    write_vrml_facettes(fac0, pl0, pl1, ALL);
                    write_vrml_points(pl1, UPPER);
                    shift_indices(pl1, pl2, ADD);
                    break;
                case IDX:
                    nb_idx_fac = calc_index_facettes(fac0, pl1, pl2, UPPER);
                    shift_indices(pl1, pl2, ADD);
                    write_index_facettes(fac0, pl0, pl1, UPPER, do_next, nb_idx_fac);
                    do_next[0] = 0;
                    shift_indices(pl1, pl2, SUB);
                    eliminate_horizontal(fac0, pl0, pl1, UPPER);
                    norm_(fac1, pl1, pl2);
                    write_index_facettes(fac0, pl0, pl1, ALL, do_next, nb_idx_fac);
                    write_index_points(pl1, ALL, 0);
                    write_index_points(pl1, UPPER, -1);
                    shift_indices(pl1, pl2, ADD);
                    break;
                case ACT:
                    shift_indices(pl1, pl2, ADD);
                    write_act_facettes(fac0, pl0, pl1, UPPER);
                    shift_indices(pl1, pl2, SUB);
                    eliminate_horizontal(fac0, pl0, pl1, UPPER);
                    norm_(fac1, pl1, pl2);
                    write_act_points(pl1, ALL);
                    write_act_facettes(fac0, pl0, pl1, ALL);
                    write_act_points(pl1, UPPER);
                    shift_indices(pl1, pl2, ADD);
                    break;
                case AVS:
                    shift_indices(pl1, pl2, ADD);
                    write_avs_facettes(fac0, pl0, pl1, UPPER);
                    shift_indices(pl1, pl2, SUB);
                    eliminate_horizontal(fac0, pl0, pl1, UPPER);
                    norm_(fac1, pl1, pl2);
                    write_avs_points(pl1, ALL);
                    write_avs_facettes(fac0, pl0, pl1, ALL);
                    write_avs_points(pl1, UPPER);
                    shift_indices(pl1, pl2, ADD);
                    break;
                default:
                    throw new AssertionError("option -n currently not supported with first or last section");
            }
        } else {
            norm_(fac1, pl1, pl2);
            switch(_out_format) {
                case VERA:
                    write_vera_facettes(fac0, pl0, pl1, ALL);
                    break;
                case STL:
                    write_stl_facettes(fac0, pl0, pl1);
                    break;
                case DXF:
                    write_dxf_facettes(fac0, pl0, pl1);
                    break;
                case ACT:
                    write_act_points(pl1, ALL);
                    write_act_facettes(fac0, pl0, pl1, ALL);
                    break;
                case IDX:
                    nb_idx_fac = calc_index_facettes(fac0, pl1, pl2, ALL);
                    write_index_facettes(fac0, pl0, pl1, ALL, do_next, nb_idx_fac);
                    write_index_points(pl1, ALL, 1);
                    break;
                case OBJ:
                    write_obj_points(pl1, ALL);
                    write_obj_facettes(fac0, pl0, pl1, ALL);
                    break;
                case VRML:
                    write_vrml_points(pl1, ALL);
                    write_vrml_facettes(fac0, pl0, pl1, ALL);
                    break;
                case OFF:
                    write_off_points(pl1, ALL);
                    write_off_facettes(fac0, pl0, pl1, ALL);
                    break;
                case AVS:
                    write_avs_points(pl1, ALL);
                    write_avs_facettes(fac0, pl0, pl1, ALL);
                    break;
            }
        }
        _koord_file.close();
        _fac_file.close();
        switch(_out_format) {
            case ACT:
                _out_file.printf("%s = Creer_Polyedre ( \"%s\", %d, %d, %d );\n", _obj_name, _obj_name, _fac_count, _koord_count, _koord_count);
                _tile_file.printf("Fin_Poly ( %s, ROSE, METALLIQUE, OPAQUE );\n", _obj_name);
                vertex_face_close();
                break;
            case OFF:
                _out_file.printf("%d %d 1\n", _koord_count, _fac_count);
                vertex_face_close();
                break;
            case VRML:
                _out_file.printf("# %d vertices %d triangles\n\n", _koord_count, _fac_count);
                _vertex_file.printf("] }\n");
                _normal_file.printf("] }\n");
                _tile_file.printf("]\n");
                _normidx_file.printf("] }\n}\n");
                vertex_normal_face_close();
                break;
            case DXF:
                _out_file.printf("ENDSEC\n  0\nEOF\n");
                _out_file.close();
                break;
            case STL:
                _out_file.printf("ENDSOLID\n");
                _out_file.close();
                break;
            case AVS:
                _out_file.printf("%d\n", _koord_count);
                vertex_face_close();
                break;
            default:
                _out_file.close();
                break;
        }
        this._log_stream.printf("nb of triangles: %d\n", _fac_count);
    }

    /********************************************************************
     *   Read points of one cross section.                              *
     ********************************************************************/
    private void read_points(Plane pl) throws IOException {
        double z;
        int i;
        int nb_pts;
        String[] tokens = this._koord_file.getTokens();
        nb_pts = Integer.parseInt(tokens[1]);
        z = Double.parseDouble(tokens[3]);
        if (nb_pts >= _maxvertex) throw new AssertionError("Vertex overflow ( > " + this._maxvertex + " ) use option -max_vertex.");
        pl.start = _koord_count;
        pl.z = z;
        for (i = 0; i < nb_pts; i++) {
            tokens = this._koord_file.getTokens();
            pl.point[i][0] = Double.parseDouble(tokens[0]);
            pl.point[i][1] = Double.parseDouble(tokens[1]);
        }
        _koord_count = _koord_count + nb_pts;
        pl.stop = _koord_count;
    }

    /********************************************************************
     * Read the triangles of one slice.                                 *
     ********************************************************************/
    private void read_facettes(FacSlice fac, Plane pl1, Plane pl2) throws IOException {
        int j;
        int i = 0;
        boolean delete1 = false;
        boolean delete2 = false;
        int type;
        if (pl1.z < pl2.z) _direction = 1.0; else _direction = -1.0;
        String[] tokens;
        tokens = this._fac_file.getTokens();
        fac.nb = Integer.parseInt(tokens[0]);
        if (fac.nb > _maxfacett) throw new AssertionError("Triangle overflow ( " + fac.nb + " )   use option -max_facett");
        fac.nb0 = fac.nb01 = fac.nb1 = 0;
        for (i = 0; i < _n_remove; i++) {
            if (_plane_counter == _remove_h[i]) delete1 = true;
            if (_plane_counter + 1 == _remove_h[i]) delete2 = true;
        }
        for (i = 0; i < fac.nb; i++) {
            type = 0;
            tokens = this._fac_file.getTokens();
            _fac_buffer[0] = Integer.parseInt(tokens[0]);
            _fac_buffer[1] = Integer.parseInt(tokens[1]);
            _fac_buffer[2] = Integer.parseInt(tokens[2]);
            _norm_buffer[0] = Double.parseDouble(tokens[3]);
            _norm_buffer[1] = Double.parseDouble(tokens[4]);
            _norm_buffer[2] = Double.parseDouble(tokens[5]);
            for (j = 0; j < 3; j++) {
                fac.fac[i][j] = _fac_buffer[j] - 2;
                type += (_fac_buffer[j] - 2) & 0x1;
            }
            for (j = 0; j < 3; j++) fac.fnorm[i][j] = _norm_buffer[j];
            if ((this._remove_horizontal && (type == 0 || type == 3)) || (delete1 && (type == 0)) || (delete2 && (type == 3))) {
                i--;
                fac.nb--;
                continue;
            }
            switch(type) {
                case 0:
                    {
                        fac.nb0++;
                        break;
                    }
                case 1:
                case 2:
                    {
                        fac.nb01++;
                        break;
                    }
                case 3:
                    {
                        fac.nb1++;
                        break;
                    }
            }
        }
    }

    /********************************************************************
     *  Eliminate the horizontal faces between slice0 and slice1        *
     *  which occur twice. The first point of such a triangle           *
     *  is set to -1, the first component of the normal to 100000.0     *
     ********************************************************************/
    private void elim_double(FacSlice fac0, FacSlice fac1) {
        int i;
        int j;
        int k;
        int old = 0;
        for (i = fac0.nb0 + fac0.nb01; i < fac0.nb; i++) for (k = 0, j = old; k < fac1.nb0; k++, j = (j == fac1.nb0 - 1) ? 0 : j + 1) if (fac0.fac[i][0] == (fac1.fac[j][0] | 0x1) && fac0.fac[i][1] == (fac1.fac[j][1] | 0x1) && fac0.fac[i][2] == (fac1.fac[j][2] | 0x1)) {
            fac0.fac[i][0] = -1;
            fac0.fnorm[i][0] = Double.MAX_VALUE;
            fac1.fac[j][0] = -1;
            fac1.fnorm[j][0] = Double.MAX_VALUE;
            old = j + 1;
            break;
        }
    }

    /********************************************************************
     *  calculate the average normals of points pl1                     *
     ********************************************************************/
    private void norm_(FacSlice fac, Plane pl1, Plane pl2) {
        int i;
        int j;
        int p;
        int plane;
        Plane[] pl = new Plane[2];
        int ncount;
        double zahl;
        double norm0;
        double norm1;
        double norm2;
        Snode pn;
        double norm;
        double[] v1 = new double[3];
        double[] v2 = new double[3];
        double[] winkel = new double[3];
        double winkelsumme;
        pl[0] = pl1;
        pl[1] = pl2;
        for (i = 0; i < fac.nb; i++) {
            if (fac.fac[i][0] >= 0) {
                for (j = 0; j < 3; j++) {
                    plane = fac.fac[i][j] & 1;
                    p = fac.fac[i][(j + 1) % 3] & 1;
                    v1[0] = pl[p].point[(fac.fac[i][(j + 1) % 3] >> 1)][0] - pl[plane].point[(fac.fac[i][j] >> 1)][0];
                    v1[1] = pl[p].point[(fac.fac[i][(j + 1) % 3] >> 1)][1] - pl[plane].point[(fac.fac[i][j] >> 1)][1];
                    v1[2] = pl[p].z - pl[plane].z;
                    p = fac.fac[i][(j + 2) % 3] & 1;
                    v2[0] = pl[p].point[(fac.fac[i][(j + 2) % 3] >> 1)][0] - pl[plane].point[(fac.fac[i][j] >> 1)][0];
                    v2[1] = pl[p].point[(fac.fac[i][(j + 2) % 3] >> 1)][1] - pl[plane].point[(fac.fac[i][j] >> 1)][1];
                    v2[2] = pl[p].z - pl[plane].z;
                    norm = Math.sqrt((v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]) * (v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]));
                    if (norm == 0.0) {
                        fac.fnorm[i][0] = Double.MAX_VALUE;
                        fac.fac[i][0] = -1;
                        this._log_stream.printf("triangle %d flat\n", i + 1);
                        break;
                    }
                    winkel[j] = (v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]) / norm;
                    if (winkel[j] == 1.0 || winkel[j] == -1.0) {
                        this._log_stream.printf("triangle %d flat\n", i + 1);
                        fac.fnorm[i][0] = Double.MAX_VALUE;
                        fac.fac[i][0] = -1;
                        break;
                    }
                }
            }
            if (fac.fac[i][0] >= 0) for (j = 0; j < 3; j++) {
                plane = fac.fac[i][j] & 1;
                pn = new Snode();
                pn.fac = i;
                pn.base = fac.fnorm;
                pn.angle = Math.acos(winkel[j]) * 180.0 / Math.PI;
                pn.next = pl[plane].simplist[fac.fac[i][j] >> 1];
                pl[plane].simplist[fac.fac[i][j] >> 1] = pn;
            }
        }
        for (i = 0; i < pl1.stop - pl1.start; ++i) {
            pn = pl1.simplist[i];
            ncount = 0;
            norm0 = 0.;
            norm1 = 0.;
            norm2 = 0.;
            winkelsumme = 0.0;
            if (_no_weight) while (pn != null) {
                pn.angle = 1.0;
                if (pn.base[pn.fac][0] < Double.MAX_VALUE) winkelsumme = winkelsumme + pn.angle;
                pn = pn.next;
            } else while (pn != null) {
                if (pn.base[pn.fac][0] < Double.MAX_VALUE) winkelsumme = winkelsumme + pn.angle;
                pn = pn.next;
            }
            pn = pl1.simplist[i];
            while (pn != null) {
                if (pn.base[pn.fac][0] < Double.MAX_VALUE) {
                    norm0 = norm0 + pn.base[pn.fac][0] * pn.angle / winkelsumme;
                    norm1 = norm1 + pn.base[pn.fac][1] * pn.angle / winkelsumme;
                    norm2 = norm2 + pn.base[pn.fac][2] * pn.angle / winkelsumme;
                    ++ncount;
                }
                pn = pn.next;
            }
            if (ncount == 0) ncount = 1;
            zahl = Math.sqrt(norm0 * norm0 + norm1 * norm1 + norm2 * norm2);
            if (zahl == 0.0) zahl = 1.0;
            pl1.pnorm[i][0] = norm0 / zahl;
            pl1.pnorm[i][1] = norm1 / zahl;
            pl1.pnorm[i][2] = norm2 / zahl;
        }
    }

    /********************************************************************
     * initialisation of pl.simplist                                    *
     ********************************************************************/
    private void init(Plane pl) {
        int i;
        for (i = 0; i < pl.stop - pl.start; i++) pl.simplist[i] = null;
    }

    /********************************************************************
     *  Looks for the correct sens of the points of triangle i with     *
     *  respect to its normal                                           *
     ********************************************************************/
    private void normal(int i, FacSlice fac, Plane[] pl) {
        int j;
        int h;
        int plane;
        double[][] p = new double[3][3];
        double[] p1p2 = new double[3];
        double[] p1p3 = new double[3];
        for (j = 0; j < 3; j++) {
            plane = fac.fac[i][j] & 1;
            p[j][0] = pl[plane].point[fac.fac[i][j] >> 1][0];
            p[j][1] = pl[plane].point[fac.fac[i][j] >> 1][1];
            p[j][2] = pl[plane].z;
        }
        p1p2[0] = p[1][0] - p[0][0];
        p1p2[1] = p[1][1] - p[0][1];
        p1p2[2] = p[1][2] - p[0][2];
        p1p3[0] = p[2][0] - p[0][0];
        p1p3[1] = p[2][1] - p[0][1];
        p1p3[2] = p[2][2] - p[0][2];
        if ((p1p2[1] * p1p3[2] - p1p2[2] * p1p3[1]) * fac.fnorm[i][0] + (p1p2[2] * p1p3[0] - p1p2[0] * p1p3[2]) * fac.fnorm[i][1] + (p1p2[0] * p1p3[1] - p1p2[1] * p1p3[0]) * fac.fnorm[i][2] < 0) {
            h = fac.fac[i][0];
            fac.fac[i][0] = fac.fac[i][1];
            fac.fac[i][1] = h;
        }
    }

    /********************************************************************
     *calculate the av. normals of points pl1 without considering fac   *
     ********************************************************************/
    private void norm_2(FacSlice fac, Plane pl1, Plane pl2) {
        int i;
        Plane[] pl = new Plane[2];
        int ncount;
        double zahl;
        double norm0;
        double norm1;
        double norm2;
        Snode pn;
        double winkelsumme;
        pl[0] = pl1;
        pl[1] = pl2;
        for (i = 0; i < pl1.stop - pl1.start; ++i) {
            pn = pl1.simplist[i];
            ncount = 0;
            norm0 = 0.;
            norm1 = 0.;
            norm2 = 0.;
            winkelsumme = 0.0;
            if (_no_weight) while (pn != null) {
                pn.angle = 1.0;
                if (pn.base[pn.fac][0] < Double.MAX_VALUE) winkelsumme = winkelsumme + pn.angle;
                pn = pn.next;
            } else while (pn != null) {
                if (pn.base[pn.fac][0] < Double.MAX_VALUE) winkelsumme = winkelsumme + pn.angle;
                pn = pn.next;
            }
            pn = pl1.simplist[i];
            while (pn != null) {
                if (pn.base[pn.fac][0] < Double.MAX_VALUE) {
                    norm0 = norm0 + pn.base[pn.fac][0] * pn.angle / winkelsumme;
                    norm1 = norm1 + pn.base[pn.fac][1] * pn.angle / winkelsumme;
                    norm2 = norm2 + pn.base[pn.fac][2] * pn.angle / winkelsumme;
                    ++ncount;
                }
                pn = pn.next;
            }
            if (ncount == 0) ncount = 1;
            zahl = Math.sqrt(norm0 * norm0 + norm1 * norm1 + norm2 * norm2);
            if (zahl == 0.0) zahl = 1.0;
            pl1.pnorm[i][0] = norm0 / zahl;
            pl1.pnorm[i][1] = norm1 / zahl;
            pl1.pnorm[i][2] = norm2 / zahl;
        }
        init(pl1);
    }

    /********************************************************************
     * write coords and gouraud-normals to act_file                     *
     *                                                                  *
     ********************************************************************/
    private void write_act_points(Plane pl, int m) {
        int i;
        if (!_mmult) {
            for (i = 0; i < pl.stop - pl.start; i++) {
                _vertex_file.printf("Add_Point( %s, %g, %g, %g );\n", _obj_name, pl.point[i][0], pl.point[i][1], pl.z);
                switch(m) {
                    case ALL:
                        {
                            _vertex_file.printf("Add_Vecteur( %s, %g, %g, %g );\n", _obj_name, pl.pnorm[i][0], pl.pnorm[i][1], pl.pnorm[i][2]);
                            break;
                        }
                    case LOWER:
                        {
                            _vertex_file.printf("Add_Vecteur( %s, 0.0 0.0 %.1f );\n", _obj_name, -_direction);
                            break;
                        }
                    case UPPER:
                        {
                            _vertex_file.printf("Add_Vecteur( %s, 0.0 0.0 %.1f );\n", _obj_name, _direction);
                            break;
                        }
                }
            }
        } else {
            double[] tmp = new double[3];
            double[] tmp1 = new double[3];
            for (i = 0; i < pl.stop - pl.start; i++) {
                tmp1[0] = pl.point[i][0];
                tmp1[1] = pl.point[i][1];
                tmp1[2] = pl.z;
                MATRIX_MULT(tmp, _matrix, tmp1);
                _vertex_file.printf("Add_Point( %s, %g, %g, %g );\n", _obj_name, tmp[0], tmp[1], tmp[2]);
                switch(m) {
                    case ALL:
                        {
                            tmp1[0] = pl.pnorm[i][0];
                            tmp1[1] = pl.pnorm[i][1];
                            tmp1[2] = pl.pnorm[i][2];
                            break;
                        }
                    case LOWER:
                        {
                            tmp1[0] = tmp1[1] = 0.0;
                            tmp1[2] = -_direction;
                            break;
                        }
                    case UPPER:
                        {
                            tmp1[0] = tmp1[1] = 0.0;
                            tmp1[2] = _direction;
                            break;
                        }
                }
                MATRIX_MULTV(tmp, _matrix, tmp1);
                VEC_NORM(tmp);
                _vertex_file.printf("Add_Vecteur( %s, %g, %g, %g );\n", _obj_name, tmp[0], tmp[1], tmp[2]);
            }
        }
    }

    /********************************************************************
     * write triangles and gouraud-normals to act_file                  *
     *                                                                  *
     ********************************************************************/
    private void write_act_facettes(FacSlice fac, Plane pl1, Plane pl2, int m) {
        int i;
        int j;
        int p;
        int[] offset = new int[2];
        Plane[] pl = new Plane[2];
        int p0;
        int p1;
        int p2;
        pl[0] = pl1;
        pl[1] = pl2;
        offset[0] = pl1.start;
        offset[1] = pl2.start;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) {
                normal(i, fac, pl);
                _tile_file.printf("Add_Face( %s, 3", _obj_name);
                for (j = 0; j < 3; j++) {
                    p = fac.fac[i][j] & 1;
                    _tile_file.printf(", %d, %d", (fac.fac[i][j] >> 1) + offset[p], (fac.fac[i][j] >> 1) + offset[p]);
                }
                _tile_file.printf(" );\n");
                _fac_count++;
            }
        }
    }

    /********************************************************************
     * write triangles and gouraud-normals to out_file only write       *
     * lower horizontal ( m=0 ) or upper horizontal ( m=1 ) faces       *
     ********************************************************************/
    private void write_vera_facettes(FacSlice fac, Plane pl0, Plane pl1, int m) {
        int i;
        int j;
        int p;
        int p0;
        int p1;
        int p2;
        Plane[] pl = new Plane[2];
        pl[0] = pl0;
        pl[1] = pl1;
        if (!_mmult) {
            for (i = 0; i < fac.nb; i++) {
                if (fac.fac[i][0] >= 0) {
                    p0 = fac.fac[i][0] & 1;
                    p1 = fac.fac[i][1] & 1;
                    p2 = fac.fac[i][2] & 1;
                    if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) {
                        _out_file.printf("PA\n");
                        normal(i, fac, pl);
                        for (j = 0; j < 3; j++) {
                            p = fac.fac[i][j] & 1;
                            _out_file.printf("%.2f %.2f %.2f\n", pl[p].point[fac.fac[i][j] >> 1][0], pl[p].point[fac.fac[i][j] >> 1][1], pl[p].z);
                        }
                        for (j = 0; j < 3; j++) {
                            p = fac.fac[i][j] & 1;
                            _out_file.printf(" %g %g %g", fac.fnorm[i][0], fac.fnorm[i][1], fac.fnorm[i][2]);
                        }
                        _out_file.printf("\n");
                        _fac_count++;
                    }
                }
            }
        } else {
            double[] tmp = new double[3];
            double[] tmp1 = new double[3];
            for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
                p0 = fac.fac[i][0] & 1;
                p1 = fac.fac[i][1] & 1;
                p2 = fac.fac[i][2] & 1;
                if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) {
                    _out_file.printf("PA  ");
                    normal(i, fac, pl);
                    for (j = 0; j < 3; j++) {
                        p = fac.fac[i][j] & 1;
                        tmp1[0] = pl[p].point[fac.fac[i][j] >> 1][0];
                        tmp1[1] = pl[p].point[fac.fac[i][j] >> 1][1];
                        tmp1[2] = pl[p].z;
                        MATRIX_MULT(tmp, _matrix, tmp1);
                        _out_file.printf("%.2f %.2f %.2f\n    ", tmp[0], tmp[1], tmp[2]);
                    }
                    for (j = 0; j < 3; j++) {
                        p = fac.fac[i][j] & 1;
                        tmp1[0] = pl[p].pnorm[fac.fac[i][j] >> 1][0];
                        tmp1[1] = pl[p].pnorm[fac.fac[i][j] >> 1][1];
                        tmp1[2] = pl[p].pnorm[fac.fac[i][j] >> 1][2];
                        MATRIX_MULTV(tmp, _matrix, tmp1);
                        VEC_NORM(tmp);
                        _out_file.printf(" %g %g %g", tmp[0], tmp[1], tmp[2]);
                    }
                    _out_file.printf("\n");
                    _fac_count++;
                }
            }
        }
    }

    public void setFacetFile(String facet_file) {
        this._fnam[0] = facet_file;
    }

    public void setCoordinateFile(String coord_file) {
        this._fnam[1] = coord_file;
    }

    public void setOutputFile(String output_file) {
        this._fnam[2] = output_file;
    }

    public void setFacetFile(File facet_file) {
        this._fnam[0] = facet_file.getPath();
    }

    public void setCoordinateFile(File coord_file) {
        this._fnam[1] = coord_file.getPath();
    }

    public void setOutputFile(File output_file) {
        this._fnam[2] = output_file.getPath();
    }

    private PrintStream _log_stream = System.out;

    public void setLogStream(PrintStream log_stream) {
        this._log_stream = log_stream;
    }

    public void enableRemoveHorizontal() {
        this._remove_horizontal = true;
    }

    public void setNoSmooth(int value) {
        this._nosmooth[this._n_nosmooth++] = value;
    }

    public void setMatrix(double[][] umatrix) {
        for (int j = 0; j < umatrix.length; j++) for (int i = 0; i < umatrix[0].length; i++) this._matrix[j][i] = umatrix[j][i];
    }

    public void setRemoveH(int value) {
        this._remove_h[this._n_remove++] = value;
    }

    public void setOutputFormat(int format) {
        this._out_format = format;
    }

    public void setObjectOffset(int offset) {
        this._obj_offset = offset;
    }

    public void setMaxVertices(int max_vertex) {
        this._maxvertex = max_vertex;
        this._mv_changed = true;
    }

    public void setmaxFacets(int max_facets) {
        this._maxfacett = max_facets;
        this._mf_changed = true;
    }

    public void enableNoWeight() {
        this._no_weight = true;
    }

    public void setObjectName(String object_name) {
        this._obj_name = object_name;
    }

    public void setHeader(String header_string) {
        this._header = header_string;
    }

    /********************************************************************/
    private void write_index_facettes(FacSlice fac, Plane pl1, Plane pl2, int m, int[] n, int nb) {
        int i;
        int j;
        int p;
        int[] offset = new int[2];
        int count = 0;
        Plane[] pl = new Plane[2];
        int p0;
        int p1;
        int p2;
        pl[0] = pl1;
        pl[1] = pl2;
        offset[0] = pl1.start;
        offset[1] = pl2.start;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) count++;
        if (_idx_count != 0) {
            write_saved_facettes(count + _idx_count);
            n[0] = 0;
        }
        if (n[0] == 1) _out_file.printf("T %d\n", nb); else n[0] = 1;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) {
                normal(i, fac, pl);
                for (j = 0; j < 3; j++) {
                    p = fac.fac[i][j] & 1;
                    _out_file.printf(" %d", (fac.fac[i][j] >> 1) + offset[p]);
                }
                _out_file.printf("\n");
                _fac_count++;
            }
        }
    }

    /********************************************************************
     * write coords and gouraud-normals to index_file                   *
     *  duplicates the vertices				                *
     ********************************************************************/
    private void write_index_points(Plane pl, int m, int n) {
        int i;
        switch(n) {
            case 0:
                {
                    _out_file.printf("V %d  z %g\n", 2 * (pl.stop - pl.start), pl.z);
                    break;
                }
            case 1:
                {
                    _out_file.printf("V %d  z  %g\n", pl.stop - pl.start, pl.z);
                    break;
                }
        }
        for (i = 0; i < pl.stop - pl.start; i++) {
            _out_file.printf("%g %g ", pl.point[i][0], pl.point[i][1]);
            switch(m) {
                case ALL:
                    {
                        _out_file.printf("%g %g %g\n", pl.pnorm[i][0], pl.pnorm[i][1], pl.pnorm[i][2]);
                        break;
                    }
                case LOWER:
                    {
                        _out_file.printf(" 0.0 0.0 %.1f\n", -_direction);
                        break;
                    }
                case UPPER:
                    {
                        _out_file.printf(" 0.0 0.0 %.1f\n", _direction);
                        break;
                    }
            }
        }
    }

    /********************************************************************
     * eliminate lower horizontal ( m=0 ) or upper horizontal ( m=1 )   *
     * faces                                                            *
     ********************************************************************/
    private void eliminate_horizontal(FacSlice fac, Plane pl0, Plane pl1, int m) {
        int i;
        int p0;
        int p1;
        int p2;
        Plane[] pl = new Plane[2];
        pl[0] = pl0;
        pl[1] = pl1;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if (p0 == m && p1 == m && p2 == m) {
                fac.fac[i][0] = -1;
                fac.fnorm[i][0] = Double.MAX_VALUE;
            }
        }
    }

    /********************************************************************
     * write triangles and gouraud-normals to index_file                *
     *                                                                  *
     ********************************************************************/
    private void write_obj_facettes(FacSlice fac, Plane pl1, Plane pl2, int m) {
        int i;
        int j;
        int p;
        int[] offset = new int[2];
        int count = 0;
        Plane[] pl = new Plane[2];
        int p0;
        int p1;
        int p2;
        pl[0] = pl1;
        pl[1] = pl2;
        offset[0] = pl1.start;
        offset[1] = pl2.start;
        if (fac.nb == 0) return;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) count++;
        }
        _out_file.printf("#%d triangles\n", count);
        _out_file.printf("s 1\n");
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) {
                normal(i, fac, pl);
                _out_file.printf("f");
                for (j = 0; j < 3; j++) {
                    p = fac.fac[i][j] & 1;
                    _out_file.printf(" %d//%d", (fac.fac[i][j] >> 1) + offset[p] + 1 + _obj_offset, (fac.fac[i][j] >> 1) + offset[p] + 1 + _obj_offset);
                }
                _out_file.printf("\n");
                _fac_count++;
            }
        }
    }

    /********************************************************************/
    private void write_obj_points(Plane pl, int m) {
        int i;
        _out_file.printf("# %d vertices  z= %f\n", pl.stop - pl.start, pl.z);
        if (!_mmult) for (i = 0; i < pl.stop - pl.start; i++) {
            _out_file.printf("v %g %g %g\n", pl.point[i][0], pl.point[i][1], pl.z);
            switch(m) {
                case ALL:
                    {
                        _out_file.printf("vn %g %g %g\n", pl.pnorm[i][0], pl.pnorm[i][1], pl.pnorm[i][2]);
                        break;
                    }
                case LOWER:
                    {
                        _out_file.printf("vn 0.0 0.0 %.1f\n", -_direction);
                        break;
                    }
                case UPPER:
                    {
                        _out_file.printf("vn 0.0 0.0 %.1f\n", _direction);
                        break;
                    }
            }
        } else {
            double[] tmp = new double[3];
            double[] tmp1 = new double[3];
            for (i = 0; i < pl.stop - pl.start; i++) {
                tmp1[0] = pl.point[i][0];
                tmp1[1] = pl.point[i][1];
                tmp1[2] = pl.z;
                MATRIX_MULT(tmp, _matrix, tmp1);
                _out_file.printf("v %g %g %g\n", tmp[0], tmp[1], tmp[2]);
                switch(m) {
                    case ALL:
                        {
                            tmp1[0] = pl.pnorm[i][0];
                            tmp1[1] = pl.pnorm[i][1];
                            tmp1[2] = pl.pnorm[i][2];
                            break;
                        }
                    case LOWER:
                        {
                            tmp1[0] = tmp1[1] = 0.0;
                            tmp1[2] = -_direction;
                            break;
                        }
                    case UPPER:
                        {
                            tmp1[0] = tmp1[1] = 0.0;
                            tmp1[2] = _direction;
                            break;
                        }
                }
                MATRIX_MULTV(tmp, _matrix, tmp1);
                VEC_NORM(tmp);
                _out_file.printf("vn %g %g %g\n", tmp[0], tmp[1], tmp[2]);
            }
        }
    }

    private void vertex_face_open() throws FileNotFoundException {
        this._vertex_file_name = this._fnam[2] + "_vertices";
        this._vertex_file = new PrintStream(this._vertex_file_name);
        this._tile_file_name = this._fnam[2] + "_faces";
        this._tile_file = new PrintStream(this._tile_file_name);
    }

    private void vertex_normal_face_open() throws FileNotFoundException {
        vertex_face_open();
        this._normal_file_name = _fnam[2] + "_normals";
        this._normal_file = new PrintStream(this._normal_file_name);
        this._normidx_file_name = _fnam[2] + "_normidx";
        this._normidx_file = new PrintStream(this._normidx_file_name);
    }

    private void vertex_face_close() throws IOException {
        _out_file.close();
        _tile_file.close();
        _vertex_file.close();
        FileOutputStream outstream = this.openAppendableStream(this._fnam[2]);
        this.appendAndDelete(outstream, this._vertex_file_name);
        this.appendAndDelete(outstream, this._tile_file_name);
        outstream.close();
    }

    private FileOutputStream openAppendableStream(String filename) throws FileNotFoundException {
        File outfile = new File(filename);
        return new FileOutputStream(outfile, true);
    }

    private void appendAndDelete(FileOutputStream outstream, String file) throws FileNotFoundException, IOException {
        FileInputStream input = new FileInputStream(file);
        byte[] buffer = new byte[65536];
        int l;
        while ((l = input.read(buffer)) != -1) outstream.write(buffer, 0, l);
        input.close();
        new File(file).delete();
    }

    private void vertex_normal_face_close() throws FileNotFoundException, IOException {
        _out_file.close();
        _tile_file.close();
        _vertex_file.close();
        _normal_file.close();
        _normidx_file.close();
        FileOutputStream outstream = this.openAppendableStream(this._fnam[2]);
        this.appendAndDelete(outstream, this._vertex_file_name);
        this.appendAndDelete(outstream, this._normal_file_name);
        this.appendAndDelete(outstream, this._tile_file_name);
        this.appendAndDelete(outstream, this._normidx_file_name);
        outstream.close();
    }

    /********************************************************************
     * write triangles  to out_file                                     *
     *                                                                  *
     ********************************************************************/
    private void write_dxf_facettes(FacSlice fac, Plane pl0, Plane pl1) {
        int i;
        int p;
        Plane[] pl = new Plane[2];
        pl[0] = pl0;
        pl[1] = pl1;
        if (!_mmult) {
            for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
                _out_file.printf("3DFACE\n  8\n%s\n", _obj_name);
                normal(i, fac, pl);
                p = fac.fac[i][0] & 1;
                _out_file.printf(" 10\n%.2f\n 20\n%.2f\n 30\n%.2f\n", pl[p].point[fac.fac[i][0] >> 1][0], pl[p].point[fac.fac[i][0] >> 1][1], pl[p].z);
                p = fac.fac[i][1] & 1;
                _out_file.printf(" 11\n%.2f\n 21\n%.2f\n 31\n%.2f\n", pl[p].point[fac.fac[i][1] >> 1][0], pl[p].point[fac.fac[i][1] >> 1][1], pl[p].z);
                p = fac.fac[i][2] & 1;
                _out_file.printf(" 12\n%.2f\n 22\n%.2f\n 32\n%.2f\n", pl[p].point[fac.fac[i][2] >> 1][0], pl[p].point[fac.fac[i][2] >> 1][1], pl[p].z);
                _out_file.printf(" 13\n%.2f\n 23\n%.2f\n 33\n%.2f\n  0\n", pl[p].point[fac.fac[i][2] >> 1][0], pl[p].point[fac.fac[i][2] >> 1][1], pl[p].z);
                _fac_count++;
            }
        } else {
            double[] tmp = new double[3];
            double[] tmp1 = new double[3];
            for (i = 0; i < fac.nb; i++) {
                if (fac.fac[i][0] >= 0) {
                    _out_file.printf("3DFACE\n  8\n%s\n", _obj_name);
                    normal(i, fac, pl);
                    p = fac.fac[i][0] & 1;
                    tmp1[0] = pl[p].point[fac.fac[i][0] >> 1][0];
                    tmp1[1] = pl[p].point[fac.fac[i][0] >> 1][1];
                    tmp1[2] = pl[p].z;
                    MATRIX_MULT(tmp, _matrix, tmp1);
                    _out_file.printf(" 10\n%.2f\n 20\n%.2f\n 30\n%.2f\n", tmp[0], tmp[1], tmp[2]);
                    p = fac.fac[i][1] & 1;
                    tmp1[0] = pl[p].point[fac.fac[i][1] >> 1][0];
                    tmp1[1] = pl[p].point[fac.fac[i][1] >> 1][1];
                    tmp1[2] = pl[p].z;
                    MATRIX_MULT(tmp, _matrix, tmp1);
                    _out_file.printf(" 11\n%.2f\n 21\n%.2f\n 31\n%.2f\n", tmp[0], tmp[1], tmp[2]);
                    p = fac.fac[i][2] & 1;
                    tmp1[0] = pl[p].point[fac.fac[i][2] >> 1][0];
                    tmp1[1] = pl[p].point[fac.fac[i][2] >> 1][1];
                    tmp1[2] = pl[p].z;
                    MATRIX_MULT(tmp, _matrix, tmp1);
                    _out_file.printf(" 12\n%.2f\n 22\n%.2f\n 32\n%.2f\n", tmp[0], tmp[1], tmp[2]);
                    _out_file.printf(" 13\n%.2f\n 23\n%.2f\n 33\n%.2f\n  0\n", tmp[0], tmp[1], tmp[2]);
                    _fac_count++;
                }
            }
        }
    }

    /********************************************************************
     * write coords and gouraud-normals to out_file                     *
     *                                                                  *
     ********************************************************************/
    private void write_avs_points(Plane pl, int m) {
        int i;
        if (!_mmult) for (i = 0; i < pl.stop - pl.start; i++) _vertex_file.printf("%g %g %g\n", pl.point[i][0], pl.point[i][1], pl.z); else {
            double[] tmp = new double[3];
            double[] tmp1 = new double[3];
            for (i = 0; i < pl.stop - pl.start; i++) {
                tmp1[0] = pl.point[i][0];
                tmp1[1] = pl.point[i][1];
                tmp1[2] = pl.z;
                MATRIX_MULT(tmp, _matrix, tmp1);
                _vertex_file.printf("O6 %g %g %g", tmp[0], tmp[1], tmp[2]);
            }
        }
    }

    /********************************************************************
     * write triangles and gouraud-normals to index_file                *
     *                                                                  *
     ********************************************************************/
    private void write_avs_facettes(FacSlice fac, Plane pl1, Plane pl2, int m) {
        int i;
        int j;
        int p;
        int[] offset = new int[2];
        int count = 0;
        Plane[] pl = new Plane[2];
        int p0;
        int p1;
        int p2;
        pl[0] = pl1;
        pl[1] = pl2;
        offset[0] = pl1.start;
        offset[1] = pl2.start;
        if (fac.nb == 0) return;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) {
                normal(i, fac, pl);
                _tile_file.printf("3\n");
                for (j = 0; j < 3; j++) {
                    p = fac.fac[i][j] & 1;
                    _tile_file.printf(" %d", (fac.fac[i][j] >> 1) + offset[p] + 1);
                }
                _tile_file.printf("\n");
                _fac_count++;
            }
        }
    }

    /********************************************************************
     * write coords and gouraud-normals to off_file                     *
     * duplicate points                                                 *
     ********************************************************************/
    private void write_off_points(Plane pl, int m) {
        int i;
        if (!_mmult) for (i = 0; i < pl.stop - pl.start; i++) {
            _vertex_file.printf("%g %g %g", pl.point[i][0], pl.point[i][1], pl.z);
            switch(m) {
                case ALL:
                    {
                        _vertex_file.printf(" %g %g %g\n", pl.pnorm[i][0], pl.pnorm[i][1], pl.pnorm[i][2]);
                        break;
                    }
                case LOWER:
                    {
                        _vertex_file.printf(" 0.0 0.0 %.1f\n", -_direction);
                        break;
                    }
                case UPPER:
                    {
                        _vertex_file.printf(" 0.0 0.0 %.1f\n", _direction);
                        break;
                    }
            }
        } else {
            double[] tmp = new double[3];
            double[] tmp1 = new double[3];
            for (i = 0; i < pl.stop - pl.start; i++) {
                tmp1[0] = pl.point[i][0];
                tmp1[1] = pl.point[i][1];
                tmp1[2] = pl.z;
                MATRIX_MULT(tmp, _matrix, tmp1);
                _vertex_file.printf("%g %g %g", tmp[0], tmp[1], tmp[2]);
                switch(m) {
                    case ALL:
                        {
                            tmp1[0] = pl.pnorm[i][0];
                            tmp1[1] = pl.pnorm[i][1];
                            tmp1[2] = pl.pnorm[i][2];
                            break;
                        }
                    case LOWER:
                        {
                            tmp1[0] = tmp1[1] = 0.0;
                            tmp1[2] = -_direction;
                            break;
                        }
                    case UPPER:
                        {
                            tmp1[0] = tmp1[1] = 0.0;
                            tmp1[2] = _direction;
                            break;
                        }
                }
                MATRIX_MULTV(tmp, _matrix, tmp1);
                VEC_NORM(tmp);
                _vertex_file.printf(" %g %g %g\n", tmp[0], tmp[1], tmp[2]);
            }
        }
    }

    /***************************************************************
      write triangles and gouraud-normals to off_file		
    *******************************************************************/
    private void write_off_facettes(FacSlice fac, Plane pl1, Plane pl2, int m) {
        int i;
        int j;
        int p;
        int[] offset = new int[2];
        Plane[] pl = new Plane[2];
        int p0;
        int p1;
        int p2;
        pl[0] = pl1;
        pl[1] = pl2;
        offset[0] = pl1.start;
        offset[1] = pl2.start;
        if (fac.nb == 0) return;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) {
                normal(i, fac, pl);
                _tile_file.printf("3");
                for (j = 0; j < 3; j++) {
                    p = fac.fac[i][j] & 1;
                    _tile_file.printf(" %d", (fac.fac[i][j] >> 1) + offset[p]);
                }
                _tile_file.printf("\n");
                _fac_count++;
            }
        }
    }

    private void shift_indices(Plane pl1, Plane pl2, int m) {
        int num;
        num = pl1.stop - pl1.start;
        if (m == 0) {
            pl1.start = pl1.start + num;
            pl2.start = pl2.start + num;
            pl1.stop = pl1.stop + num;
            pl2.stop = pl2.stop + num;
            _koord_count = _koord_count + num;
        } else {
            pl1.start = pl1.start - num;
            pl2.start = pl2.start - num;
            pl1.stop = pl1.stop - num;
            pl2.stop = pl2.stop - num;
            _koord_count = _koord_count - num;
        }
    }

    private int calc_index_facettes(FacSlice fac, Plane pl1, Plane pl2, int m) {
        int i;
        int[] offset = new int[2];
        int count = 0;
        Plane[] pl = new Plane[2];
        pl[0] = pl1;
        pl[1] = pl2;
        offset[0] = pl1.start;
        offset[1] = pl2.start;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) count++;
        return count;
    }

    private void save_index_facettes(FacSlice fac, Plane pl1, Plane pl2, int m) {
        int i;
        int[] offset = new int[2];
        int count = 0;
        Plane[] pl = new Plane[2];
        int p0;
        int p1;
        int p2;
        pl[0] = pl1;
        pl[1] = pl2;
        offset[0] = pl1.start;
        offset[1] = pl2.start;
        switch(m) {
            case LOWER:
            case UPPER:
                {
                    for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
                        p0 = fac.fac[i][0] & 1;
                        p1 = fac.fac[i][1] & 1;
                        p2 = fac.fac[i][2] & 1;
                        if (p0 == m && p1 == m && p2 == m) count++;
                    }
                    break;
                }
        }
        _idx_fac_buffer = new int[3 * count];
        _idx_count = count;
        count = 0;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if ((p0 == m && p1 == m && p2 == m)) {
                normal(i, fac, pl);
                _idx_fac_buffer[3 * count] = (fac.fac[i][0] >> 1) + offset[p0];
                _idx_fac_buffer[3 * count + 1] = (fac.fac[i][1] >> 1) + offset[p1];
                _idx_fac_buffer[3 * count + 2] = (fac.fac[i][2] >> 1) + offset[p2];
                count++;
            }
        }
    }

    private void write_saved_facettes(int nb) {
        int i;
        _out_file.printf("T %d\n", nb);
        for (i = 0; i < _idx_count; i++) {
            _out_file.printf("%d %d %d\n", _idx_fac_buffer[3 * i], _idx_fac_buffer[3 * i + 1], _idx_fac_buffer[3 * i + 2]);
            _fac_count++;
        }
        _idx_fac_buffer = null;
        _idx_count = 0;
    }

    /********************************************************************
     *                                                                  *
     ********************************************************************/
    private void write_vrml_facettes(FacSlice fac, Plane pl1, Plane pl2, int m) {
        int i;
        int j;
        int p;
        int[] offset = new int[2];
        int count = 0;
        Plane[] pl = new Plane[2];
        int p0;
        int p1;
        int p2;
        pl[0] = pl1;
        pl[1] = pl2;
        offset[0] = pl1.start;
        offset[1] = pl2.start;
        if (fac.nb == 0) return;
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) count++;
        }
        for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
            p0 = fac.fac[i][0] & 1;
            p1 = fac.fac[i][1] & 1;
            p2 = fac.fac[i][2] & 1;
            if ((m == ALL) || (p0 == m && p1 == m && p2 == m)) {
                normal(i, fac, pl);
                _tile_file.printf(" ");
                _normidx_file.printf(" ");
                for (j = 0; j < 3; j++) {
                    p = fac.fac[i][j] & 1;
                    _tile_file.printf(" %d,", (fac.fac[i][j] >> 1) + offset[p] + _obj_offset);
                    _normidx_file.printf(" %d,", (fac.fac[i][j] >> 1) + offset[p] + _obj_offset);
                }
                _tile_file.printf("-1,\n");
                _normidx_file.printf("-1,\n");
                _fac_count++;
            }
        }
    }

    /********************************************************************
     * write coords and gouraud-normals to index_file                   *
     * m=Upper/LOWER/ALL                                                *
     ********************************************************************/
    private void write_vrml_points(Plane pl, int m) {
        int i;
        if (!_mmult) for (i = 0; i < pl.stop - pl.start; i++) {
            _vertex_file.printf("%g %g %g,\n", pl.point[i][0], pl.point[i][1], pl.z);
            switch(m) {
                case ALL:
                    {
                        _normal_file.printf("%g %g %g,\n", pl.pnorm[i][0], pl.pnorm[i][1], pl.pnorm[i][2]);
                        break;
                    }
                case LOWER:
                    {
                        _normal_file.printf("0.0 0.0 %.1f,\n", -_direction);
                        break;
                    }
                case UPPER:
                    {
                        _normal_file.printf("0.0 0.0 %.1f,\n", _direction);
                        break;
                    }
            }
        } else {
            double[] tmp = new double[3];
            double[] tmp1 = new double[3];
            for (i = 0; i < pl.stop - pl.start; i++) {
                tmp1[0] = pl.point[i][0];
                tmp1[1] = pl.point[i][1];
                tmp1[2] = pl.z;
                MATRIX_MULT(tmp, _matrix, tmp1);
                _vertex_file.printf("%g %g %g,\n", tmp[0], tmp[1], tmp[2]);
                switch(m) {
                    case ALL:
                        {
                            tmp1[0] = pl.pnorm[i][0];
                            tmp1[1] = pl.pnorm[i][1];
                            tmp1[2] = pl.pnorm[i][2];
                            break;
                        }
                    case LOWER:
                        {
                            tmp1[0] = tmp1[1] = 0.0;
                            tmp1[2] = -_direction;
                            break;
                        }
                    case UPPER:
                        {
                            tmp1[0] = tmp1[1] = 0.0;
                            tmp1[2] = _direction;
                            break;
                        }
                }
                MATRIX_MULTV(tmp, _matrix, tmp1);
                VEC_NORM(tmp);
                _normal_file.printf("%g %g %g,\n", tmp[0], tmp[1], tmp[2]);
            }
        }
    }

    /********************************************************************
     * write triangles  to out_file                                     *
     *                                                                  *
     ********************************************************************/
    void write_stl_facettes(FacSlice fac, Plane pl0, Plane pl1) {
        int i;
        int p;
        Plane[] pl = new Plane[2];
        pl[0] = pl0;
        pl[1] = pl1;
        if (!_mmult) for (i = 0; i < fac.nb; i++) {
            if (fac.fac[i][0] >= 0) {
                normal(i, fac, pl);
                _out_file.printf("  FACET NORMAL %e %e %e\n", fac.fnorm[i][0], fac.fnorm[i][1], fac.fnorm[i][2]);
                _out_file.printf("    OUTER LOOP\n");
                p = fac.fac[i][0] & 1;
                _out_file.printf("      VERTEX   %e %e %e\n", pl[p].point[fac.fac[i][0] >> 1][0], pl[p].point[fac.fac[i][0] >> 1][1], pl[p].z);
                p = fac.fac[i][1] & 1;
                _out_file.printf("      VERTEX   %e %e %e\n", pl[p].point[fac.fac[i][1] >> 1][0], pl[p].point[fac.fac[i][1] >> 1][1], pl[p].z);
                p = fac.fac[i][2] & 1;
                _out_file.printf("      VERTEX   %e %e %e\n", pl[p].point[fac.fac[i][2] >> 1][0], pl[p].point[fac.fac[i][2] >> 1][1], pl[p].z);
                _fac_count++;
                _out_file.printf("    ENDLOOP\n");
                _out_file.printf("  ENDFACET\n");
            }
        } else {
            double[] tmp = new double[3];
            double[] tmp1 = new double[3];
            for (i = 0; i < fac.nb; i++) if (fac.fac[i][0] >= 0) {
                _out_file.printf("  FACET NORMAL %e %e %e\n", fac.fnorm[i][0], fac.fnorm[i][1], fac.fnorm[i][2]);
                _out_file.printf("    OUTER LOOP\n");
                normal(i, fac, pl);
                p = fac.fac[i][0] & 1;
                tmp1[0] = pl[p].point[fac.fac[i][0] >> 1][0];
                tmp1[1] = pl[p].point[fac.fac[i][0] >> 1][1];
                tmp1[2] = pl[p].z;
                MATRIX_MULT(tmp, _matrix, tmp1);
                _out_file.printf("      VERTEX   %e %e %e\n", tmp[0], tmp[1], tmp[2]);
                p = fac.fac[i][1] & 1;
                tmp1[0] = pl[p].point[fac.fac[i][1] >> 1][0];
                tmp1[1] = pl[p].point[fac.fac[i][1] >> 1][1];
                tmp1[2] = pl[p].z;
                MATRIX_MULT(tmp, _matrix, tmp1);
                _out_file.printf("      VERTEX   %e %e %e\n", tmp[0], tmp[1], tmp[2]);
                p = fac.fac[i][2] & 1;
                tmp1[0] = pl[p].point[fac.fac[i][2] >> 1][0];
                tmp1[1] = pl[p].point[fac.fac[i][2] >> 1][1];
                tmp1[2] = pl[p].z;
                MATRIX_MULT(tmp, _matrix, tmp1);
                _out_file.printf("      VERTEX   %e %e %e\n", tmp[0], tmp[1], tmp[2]);
                _fac_count++;
                _out_file.printf("    ENDLOOP\n");
                _out_file.printf("  ENDFACET\n");
            }
        }
    }

    public static void main(String[] argv) {
        try {
            Repros2Visu repros2visu = new Repros2Visu();
            repros2visu.setOutputFormat(Repros2Visu.IDX);
            repros2visu.enableRemoveHorizontal();
            repros2visu.setObjectName("object");
            repros2visu.setHeader("");
            repros2visu.setFacetFile("/home/spl/src/java/Nuages/nuages.tri");
            repros2visu.setCoordinateFile("/home/spl/src/java/Nuages/nuages.coord.new");
            repros2visu.setOutputFile("/home/spl/src/java/Nuages/nuages.out");
            repros2visu.process();
        } catch (IOException ex) {
            System.err.println(ex);
            ex.printStackTrace();
        }
    }
}
