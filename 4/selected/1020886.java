package gov.nasa.jpf.ts;

import gov.nasa.jpf.Config;
import gov.nasa.jpf.JPF;
import gov.nasa.jpf.jvm.ClassInfo;
import gov.nasa.jpf.jvm.FieldInfo;
import gov.nasa.jpf.jvm.bytecode.GETFIELD;
import gov.nasa.jpf.jvm.bytecode.Instruction;
import gov.nasa.jpf.jvm.bytecode.MONITORENTER;
import gov.nasa.jpf.jvm.bytecode.MONITOREXIT;
import gov.nasa.jpf.jvm.bytecode.PUTFIELD;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.logging.Logger;
import org.junit.runner.JUnitCore;

class RWSameFieldRace implements TestSubject {

    static Logger log = JPF.getLogger("gov.nasa.jpf.ts");

    private final TSVM tsvm;

    ArrayList<RaceCandidate> candidates = new ArrayList<RaceCandidate>();

    RWSameFieldRace(Config conf, TSVM tsvm) {
        this.tsvm = tsvm;
    }

    public int getNumberOfTestCandidates() {
        return candidates.size();
    }

    public String getDescription() {
        return "read/write race on same field";
    }

    protected boolean checkSameFieldRace(FieldInfo fi, Instruction insn, Class<?> race) {
        AccessOp raceOp = null;
        HashSet<Integer> released = null;
        for (AccessOp op : this.tsvm.trace) {
            if (op.insn instanceof MONITOREXIT) {
                if (raceOp == null) {
                    if (released == null) {
                        released = new HashSet<Integer>();
                    }
                    released.add(op.lockRef);
                }
            } else if ((op.fi == fi) && race.isInstance(op.insn)) {
                raceOp = op;
            } else if (op.insn instanceof MONITORENTER) {
                if (raceOp != null) {
                    if (released == null || !released.contains(op.lockRef)) {
                        raceOp = null;
                        break;
                    } else {
                        released.remove(op.lockRef);
                    }
                }
            }
        }
        if (raceOp != null) {
            Instruction rdInsn, wrInsn;
            if (insn instanceof PUTFIELD) {
                wrInsn = insn;
                rdInsn = raceOp.getInstruction();
            } else {
                wrInsn = raceOp.getInstruction();
                rdInsn = insn;
            }
            candidates.add(new RaceCandidate(tsvm.getCurrentCall(), tsvm.getTrace(), fi, rdInsn, wrInsn));
            return true;
        } else {
            return false;
        }
    }

    public boolean checkRead(FieldInfo fi, Instruction insn) {
        return checkSameFieldRace(fi, insn, PUTFIELD.class);
    }

    public boolean checkWrite(FieldInfo fi, Instruction insn) {
        return checkSameFieldRace(fi, insn, GETFIELD.class);
    }

    List<String> getTestMethodNames() {
        ArrayList<String> list = new ArrayList<String>();
        for (RaceCandidate candidate : candidates) {
            list.add("test_" + candidate.getJNIMethodName());
        }
        return list;
    }

    public File createJPFDriver(String jpfBaseDir, String testDir, String testPackage, ClassInfo ciTest) {
        String baseName = ciTest.getName().replace(".", "_");
        String testCls = "Test_" + baseName + "_JPF";
        String listenerCls = ".tools.PreciseRaceDetector";
        PrintWriter pw = null;
        File file = new File(testDir, testCls + ".java");
        try {
            FileWriter fw = new FileWriter(file);
            pw = new PrintWriter(fw);
            pw.println("/**********************************************************");
            pw.println(" * JPF test driver generated by TSVM");
            pw.println(" * target class: " + ciTest.getName());
            pw.println(" * test subject: " + getDescription());
            pw.println(" * date:         " + new Date());
            pw.println(" **********************************************************/");
            if (testPackage != null) {
                pw.println("package " + testPackage + ';');
            }
            pw.println();
            pw.println("import org.junit.Test;");
            pw.println("import org.junit.runner.JUnitCore;");
            pw.println("import gov.nasa.jpf.jvm.TestJPF;");
            pw.println();
            pw.println("public class " + testCls + " extends TestJPF {");
            pw.println();
            pw.println("  static final String TEST_CLASS = \"Test_" + baseName + "\";");
            pw.println("  static final String LISTENER_CLASS = \"" + listenerCls + "\";");
            pw.println("  static final String JPF_BASEDIR = \"" + jpfBaseDir + "\";");
            pw.println();
            pw.println("  public static void main (String[] args) {");
            pw.println("    JUnitCore.main( TEST_CLASS + \"_JPF\");");
            pw.println("  }");
            pw.println();
            pw.println("//--- test methods");
            pw.println();
            for (String tname : getTestMethodNames()) {
                pw.println("  @Test");
                pw.println("  public void " + tname + "() {");
                pw.println("    String[] args= {\"+jpf.basedir=\" + JPF_BASEDIR,");
                pw.println("                    \"+jpf.listener=\" + LISTENER_CLASS,");
                pw.println("                    TEST_CLASS, \"" + tname + "\"};");
                pw.println("    runJPFnoException(args);");
                pw.println("  }");
                pw.println();
            }
            pw.println("}");
            return file;
        } catch (IOException iox) {
            log.warning("error writing raw test file" + iox);
        } finally {
            if (pw != null) {
                pw.close();
            }
        }
        return null;
    }

    public File createRawTest(String testDir, String testPackage, ClassInfo ciTest) {
        String cname = ciTest.getName();
        String baseName = ciTest.getSimpleName();
        String testCls = "Test_" + cname.replace(".", "_");
        PrintWriter pw = null;
        File file = new File(testDir, testCls + ".java");
        try {
            FileWriter fw = new FileWriter(file);
            pw = new PrintWriter(fw);
            pw.println("/**********************************************************");
            pw.println(" * raw test generated by TSVM");
            pw.println(" * target class: " + cname);
            pw.println(" * test subject: " + getDescription());
            pw.println(" * date:         " + new Date());
            pw.println(" **********************************************************/");
            if (testPackage != null) {
                pw.println("package " + testPackage + ';');
            }
            pw.println();
            pw.println("import gov.nasa.jpf.jvm.RawTest;");
            pw.println("import " + cname + ";");
            pw.println();
            pw.println("public class " + testCls + " extends RawTest {");
            int i = 1;
            for (RaceCandidate candidate : candidates) {
                pw.println();
                pw.println("  /*********************************************** test #" + i++);
                candidate.printOn(pw);
                pw.println("  ********************************************************/");
                pw.println();
                candidate.printTestMethodOn(pw);
                pw.println();
            }
            pw.println();
            pw.println("  public static void main (String[] args) {");
            pw.println("    " + testCls + " t = new " + testCls + "();");
            pw.println("    if (!runSelectedTest(args,t)){");
            pw.println("      runAllTests(args,t);");
            pw.println("    }");
            pw.println("  }");
            pw.println("}");
            return file;
        } catch (IOException iox) {
            log.warning("error writing raw test file" + iox);
        } finally {
            if (pw != null) {
                pw.close();
            }
        }
        return null;
    }

    public void printCandidatesOn(PrintWriter pw) {
        pw.println("check for potential read/write races on same fields");
        if (candidates.size() == 0) {
            pw.println("no test candidates found");
        } else {
            pw.println("number of potential test candidates: " + candidates.size());
            int i = 1;
            for (RaceCandidate candidate : candidates) {
                pw.println();
                pw.println("--- test #" + i++);
                candidate.printOn(pw);
            }
        }
    }
}
