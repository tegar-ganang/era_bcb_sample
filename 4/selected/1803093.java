package edu.rice.cs.astgen;

import java.util.*;
import edu.rice.cs.plt.iter.IterUtil;
import edu.rice.cs.plt.tuple.Pair;
import edu.rice.cs.astgen.Types.*;

public class TextSerializationGenerator extends CodeGenerator {

    private final String readerClassName;

    private final String nodeReaderName;

    private final Set<TypeName> helpers;

    public TextSerializationGenerator(ASTModel ast) {
        super(ast);
        if (ast.topTypes().size() == 1) {
            NodeType top = IterUtil.first(ast.topTypes());
            readerClassName = top.name() + "Reader";
            nodeReaderName = "read" + upperCaseFirst(top.name());
        } else {
            readerClassName = "TreeNodeReader";
            nodeReaderName = "readTreeNode";
        }
        helpers = new LinkedHashSet<TypeName>();
    }

    public Iterable<Class<? extends CodeGenerator>> dependencies() {
        return IterUtil.make(WalkMethodGenerator.class, TabPrintWriterGenerator.class);
    }

    public void generateInterfaceMembers(TabPrintWriter writer, NodeInterface i) {
        if (ast.isTop(i)) {
            writer.startLine("/** Generate a human-readable representation that can be deserialized. */");
            writer.startLine("public java.lang.String serialize();");
            writer.startLine("/** Generate a human-readable representation that can be deserialized. */");
            writer.startLine("public void serialize(java.io.Writer writer);");
        }
    }

    public void generateClassMembers(TabPrintWriter writer, NodeClass c) {
        if (ast.isTopClass(c)) {
            writer.startLine("/** Generate a human-readable representation that can be deserialized. */");
            writer.startLine("public java.lang.String serialize() {");
            writer.indent();
            writer.startLine("java.io.StringWriter w = new java.io.StringWriter();");
            writer.startLine("walk(new LosslessStringWalker(w, 2));");
            writer.startLine("return w.toString();");
            writer.unindent();
            writer.startLine("}");
            writer.startLine("/** Generate a human-readable representation that can be deserialized. */");
            writer.startLine("public void serialize(java.io.Writer writer) {");
            writer.indent();
            writer.startLine("walk(new LosslessStringWalker(writer, 2));");
            writer.unindent();
            writer.startLine("}");
            writer.println();
        }
    }

    public void generateAdditionalCode() {
        TabPrintWriter writer = new TabPrintWriter(options.createFileInOutDir("LosslessStringWalker.java"), 2);
        options.outputPackageStatement(writer);
        copyFromResource(writer, "LosslessStringWalker.java", "package");
        writer.close();
        writer = options.createJavaSourceInOutDir(readerClassName);
        writer.startLine("/** A utility class for deserializing a node description generated by ");
        writer.startLine("  * serialize(java.io.Writer).");
        writer.startLine("  */");
        writer.startLine("@SuppressWarnings(\"unused\")");
        writer.startLine("public class " + readerClassName + " {");
        writer.indent();
        writer.println();
        String returnType;
        if (ast.topTypes().size() == 1) {
            returnType = IterUtil.first(ast.topTypes()).name();
        } else {
            returnType = "java.lang.Object";
        }
        writer.startLine("public static " + returnType + " read(java.lang.String s)");
        writer.print(" throws java.io.IOException {");
        writer.indent();
        writer.startLine("return read(new java.io.StringReader(s));");
        writer.unindent();
        writer.startLine("}");
        writer.println();
        writer.startLine("public static " + returnType + " read(java.io.Reader r)");
        writer.print(" throws java.io.IOException {");
        writer.indent();
        writer.startLine("return new " + readerClassName + "(new java.io.BufferedReader(r))." + nodeReaderName + "();");
        writer.unindent();
        writer.startLine("}");
        writer.println();
        writer.startLine("protected java.io.BufferedReader in;");
        writer.startLine("protected char currentChar=' ';");
        writer.println();
        writer.startLine("protected " + readerClassName + "(java.io.BufferedReader r) { in = r; }");
        writer.println();
        writer.startLine("public " + returnType + " " + nodeReaderName + "()");
        writer.print(" throws java.io.IOException {");
        writer.indent();
        writer.startLine("java.lang.String name = readWord();");
        writer.startLine("if (name.equals(\"_\")) return null;");
        for (NodeClass c : ast.classes()) {
            if (!c.isAbstract()) {
                writer.startLine("if (name.equals(\"" + c.name() + ":\"))");
                writer.print(" return read" + upperCaseFirst(c.name()) + "Body();");
            }
        }
        writer.startLine("throw error();");
        writer.unindent();
        writer.startLine("}");
        writer.println();
        for (NodeClass c : ast.classes()) {
            if (!c.isAbstract()) {
                generateReadMethod(c, writer);
            }
        }
        writer.println();
        for (TypeName t : helpers) {
            generateHelper(t, writer);
        }
        copyFromResource(writer, "ReaderMethods.txt", null);
        writer.unindent();
        writer.startLine("}");
        writer.println();
        writer.close();
    }

    /** Generate a method to read a tree node of the given type. */
    protected void generateReadMethod(NodeClass c, TabPrintWriter writer) {
        writer.startLine("private " + c.name() + " read" + upperCaseFirst(c.name()) + "Body()");
        writer.print(" throws java.io.IOException {");
        writer.indent();
        for (Field f : c.allFields(ast)) {
            writer.startLine("readFieldDelim(\"" + f.name() + " = \");");
            Pair<String, Boolean> readVal = elementReadString(f.type(), true);
            if (readVal.second()) {
                writer.startLine("@SuppressWarnings(\"unchecked\") ");
            } else {
                writer.startLine();
            }
            writer.print(f.type().name() + " read_" + f.name() + " = " + readVal.first() + ";");
        }
        writer.startLine("return new " + c.name() + "(");
        boolean first = true;
        for (Field f : c.allFields(ast)) {
            if (first) {
                first = false;
            } else {
                writer.print(", ");
            }
            writer.print("read_" + f.name());
        }
        writer.print(");");
        writer.unindent();
        writer.startLine("}");
        writer.println();
    }

    /** Generate a helper read method for values of the given type. */
    protected void generateHelper(TypeName t, final TabPrintWriter writer) {
        writer.startLine("private " + t.name() + " read" + t.identifierName() + "()");
        writer.print(" throws java.io.IOException {");
        writer.indent();
        t.accept(new TypeNameVisitor<Void>() {

            public Void forTreeNode(ClassName t) {
                throw error(t);
            }

            public Void forPrimitive(PrimitiveName t) {
                throw error(t);
            }

            public Void forString(ClassName t) {
                throw error(t);
            }

            public Void forGeneralClass(ClassName t) {
                throw error(t);
            }

            private RuntimeException error(TypeName t) {
                return new IllegalArgumentException("Unexpected type for helper method: " + t.name());
            }

            public Void forPrimitiveArray(PrimitiveArrayName t) {
                String boxedName = t.elementType().boxed().name();
                String readElt = elementReadString(t.elementType(), false).first();
                String accumType = "java.util.ArrayList<" + boxedName + ">";
                writer.startLine(accumType + " accum = new " + accumType + "();");
                writer.startLine("java.lang.String word = readWord();");
                writer.startLine("if (!word.equals(\"{\")) throw error();");
                writer.startLine("word = readWord();");
                writer.startLine("while (word.equals(\"*\")) {");
                writer.indent();
                writer.startLine("accum.add(" + readElt + ");");
                writer.startLine("word = readWord();");
                writer.unindent();
                writer.startLine("}");
                writer.startLine("if (!word.equals(\"}\")) throw error();");
                writer.startLine(t.name() + " result = new " + t.elementType().name() + "[accum.size()];");
                writer.startLine("int i = 0;");
                writer.startLine("for (" + boxedName + " elt : accum) result[i++] = elt;");
                writer.startLine("return result;");
                return null;
            }

            public Void forReferenceArray(ReferenceArrayName t) {
                handleSequence(t);
                return null;
            }

            public Void forSequenceClass(SequenceClassName t) {
                handleSequence(t);
                return null;
            }

            private void handleSequence(SequenceName t) {
                Pair<String, Boolean> readElt = elementReadString(t.elementType(), false);
                writer.startLine("readExpected(\"{\");");
                writer.startLine(t.accumulator("accum"));
                writer.startLine("while (readMoreListElements()) {");
                writer.indent();
                if (readElt.second()) {
                    writer.startLine("@SuppressWarnings(\"unchecked\")");
                    writer.startLine(t.elementType().name() + " elt_result = " + readElt.first() + ";");
                    writer.startLine(t.addToAccumulator("accum", "elt_result"));
                } else {
                    writer.startLine(t.addToAccumulator("accum", readElt.first()));
                }
                writer.unindent();
                writer.startLine("}");
                writer.startLine("return " + t.constructor("accum") + ";");
            }

            public Void forOptionClass(OptionClassName t) {
                Pair<String, Boolean> readElt = elementReadString(t.elementType(), false);
                writer.startLine("if (readOptionHeader()) {");
                writer.indent();
                if (readElt.second()) {
                    writer.startLine("@SuppressWarnings(\"unchecked\")");
                }
                writer.startLine(t.elementType().name() + " elt_result = " + readElt.first() + ";");
                writer.startLine("readExpected(\")\");");
                writer.startLine("return " + t.nonEmptyConstructor("elt_result") + ";");
                writer.unindent();
                writer.startLine("}");
                writer.startLine("else { return " + t.emptyConstructor() + "; }");
                return null;
            }

            public Void forTupleClass(TupleClassName t) {
                List<TypeName> elementTypes = t.elementTypes();
                List<String> elements = new ArrayList<String>(elementTypes.size());
                writer.startLine("c = readCharWord();");
                writer.startLine("if (c != '(') throw error();");
                for (int i = 0; i < elementTypes.size(); i++) {
                    if (i > 0) {
                        writer.startLine("c = readCharWord();");
                        writer.startLine("if (c != ',') throw error();");
                    }
                    TypeName eltT = elementTypes.get(i);
                    Pair<String, Boolean> readElt = elementReadString(eltT, false);
                    String resultName = "elt_result_" + i;
                    elements.add(resultName);
                    if (readElt.second()) {
                        writer.startLine("@SuppressWarnings(\"unchecked\")");
                    }
                    writer.startLine(eltT.name() + " " + resultName + " = " + readElt.first() + ";");
                }
                writer.startLine("c = readCharWord();");
                writer.startLine("if (c != ')') throw error();");
                writer.startLine("return " + t.constructor(elements) + ";");
                return null;
            }
        });
        writer.unindent();
        writer.startLine("}");
        writer.println();
    }

    /**
   * Produce an expression for reading an object of the given type.  The boolean return value indicates
   * whether the expression contains an unchecked cast.
   */
    protected Pair<String, Boolean> elementReadString(TypeName elt, final boolean addHelpers) {
        return elt.accept(new TypeNameVisitor<Pair<String, Boolean>>() {

            public Pair<String, Boolean> forTreeNode(ClassName t) {
                return Pair.make("(" + t.name() + ") " + nodeReaderName + "()", false);
            }

            public Pair<String, Boolean> forPrimitive(PrimitiveName t) {
                String eltName = t.name();
                String method;
                if (eltName.equals("boolean")) {
                    method = "readBoolean()";
                } else if (eltName.equals("char")) {
                    method = "readChar()";
                } else if (eltName.equals("byte")) {
                    method = "readByte()";
                } else if (eltName.equals("short")) {
                    method = "readShort()";
                } else if (eltName.equals("int")) {
                    method = "readInt()";
                } else if (eltName.equals("long")) {
                    method = "readLong()";
                } else if (eltName.equals("float")) {
                    method = "readFloat()";
                } else if (eltName.equals("double")) {
                    method = "readDouble()";
                } else {
                    throw new RuntimeException("Unrecognized primitive: " + eltName);
                }
                return Pair.make(method, false);
            }

            public Pair<String, Boolean> forString(ClassName t) {
                return Pair.make("readString()", false);
            }

            public Pair<String, Boolean> forPrimitiveArray(PrimitiveArrayName t) {
                return callHelper(t);
            }

            public Pair<String, Boolean> forReferenceArray(ReferenceArrayName t) {
                if (addHelpers) {
                    t.elementType().accept(this);
                }
                return callHelper(t);
            }

            public Pair<String, Boolean> forSequenceClass(SequenceClassName t) {
                if (addHelpers) {
                    t.elementType().accept(this);
                }
                return callHelper(t);
            }

            public Pair<String, Boolean> forOptionClass(OptionClassName t) {
                if (addHelpers) {
                    t.elementType().accept(this);
                }
                return callHelper(t);
            }

            public Pair<String, Boolean> forTupleClass(TupleClassName t) {
                if (addHelpers) {
                    for (TypeName elt : t.elementTypes()) {
                        elt.accept(this);
                    }
                }
                return callHelper(t);
            }

            protected Pair<String, Boolean> callHelper(TypeName t) {
                if (addHelpers) {
                    helpers.add(t);
                }
                return Pair.make("read" + t.identifierName() + "()", false);
            }

            public Pair<String, Boolean> forGeneralClass(ClassName t) {
                return Pair.make("(" + t.name() + ") readUnknownObject()", !IterUtil.isEmpty(t.typeArguments()));
            }
        });
    }
}
