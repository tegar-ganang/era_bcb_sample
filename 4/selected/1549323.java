package freemind.main;

import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.text.BadLocationException;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.InputSource;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.DefaultHandler;

/** */
public class HtmlTools {

    public static final String NBSP = "Â ";

    private static Logger logger;

    private static HtmlTools sInstance = new HtmlTools();

    private static final Pattern HTML_PATTERN = Pattern.compile("(?s)^\\s*<\\s*html.*?>.*");

    private static final Pattern FIND_TAGS_PATTERN = Pattern.compile("([^<]*)(<[^>]+>)");

    private static final Pattern SLASHED_TAGS_PATTERN = Pattern.compile("<((" + "br|area|base|basefont|" + "bgsound|button|col|colgroup|embed|hr" + "|img|input|isindex|keygen|link|meta" + "|object|plaintext|spacer|wbr" + ")(\\s[^>]*)?)/>");

    private static final Pattern TAGS_PATTERN = Pattern.compile("(?s)<[^><]*>");

    public static final String SP = "&#160;";

    /**
     * 
     */
    private HtmlTools() {
        super();
        logger = Resources.getInstance().getLogger(HtmlTools.class.getName());
    }

    public static HtmlTools getInstance() {
        return sInstance;
    }

    public String toXhtml(String htmlText) {
        if (!isHtmlNode(htmlText)) {
            return null;
        }
        logger.fine("Enter toXhtml with " + htmlText);
        StringReader reader = new StringReader(htmlText);
        StringWriter writer = new StringWriter();
        try {
            XHTMLWriter.html2xhtml(reader, writer);
            String resultXml = writer.toString();
            if (!isWellformedXml(resultXml)) {
                return toXMLEscapedText(htmlText);
            }
            logger.fine("Leave toXhtml with " + resultXml);
            return resultXml;
        } catch (IOException e) {
            freemind.main.Resources.getInstance().logException(e);
        } catch (BadLocationException e) {
            freemind.main.Resources.getInstance().logException(e);
        }
        htmlText = htmlText.replaceAll("<", "&gt;");
        htmlText = htmlText.replaceAll(">", "&lt;");
        logger.fine("Leave toXhtml with fallback " + htmlText);
        return htmlText;
    }

    public String toHtml(String xhtmlText) {
        return SLASHED_TAGS_PATTERN.matcher(xhtmlText).replaceAll("<$1>");
    }

    public static class IndexPair {

        public int originalStart;

        public int originalEnd;

        public int replacedStart;

        public int replacedEnd;

        public boolean mIsTag;

        public boolean mIsAlreadyAppended = false;

        /**
         * @param pIsTag TODO
         */
        public IndexPair(int pOriginalStart, int pOriginalEnd, int pReplacedStart, int pReplacedEnd, boolean pIsTag) {
            super();
            originalStart = pOriginalStart;
            originalEnd = pOriginalEnd;
            replacedStart = pReplacedStart;
            replacedEnd = pReplacedEnd;
            mIsTag = pIsTag;
        }

        /**
         * generated by CodeSugar http://sourceforge.net/projects/codesugar */
        public String toString() {
            StringBuffer buffer = new StringBuffer();
            buffer.append("[IndexPair:");
            buffer.append(" originalStart: ");
            buffer.append(originalStart);
            buffer.append(" originalEnd: ");
            buffer.append(originalEnd);
            buffer.append(" replacedStart: ");
            buffer.append(replacedStart);
            buffer.append(" replacedEnd: ");
            buffer.append(replacedEnd);
            buffer.append(" is a tag: ");
            buffer.append(mIsTag);
            buffer.append("]");
            return buffer.toString();
        }
    }

    /** Replaces text in node content without replacing tags.
     * fc, 19.12.06: This method is very difficult. If you have a simplier
     * method, please supply it. But look that it complies with FindTextTests!!!
     */
    public String getReplaceResult(Pattern pattern, String replacement, String text) {
        ArrayList splittedStringList = new ArrayList();
        String stringWithoutTags = null;
        {
            StringBuffer sb = new StringBuffer();
            Matcher matcher = FIND_TAGS_PATTERN.matcher(text);
            int lastMatchEnd = 0;
            while (matcher.find()) {
                String textWithoutTag = matcher.group(1);
                int replStart = sb.length();
                matcher.appendReplacement(sb, "$1");
                IndexPair indexPair;
                if (textWithoutTag.length() > 0) {
                    indexPair = new IndexPair(lastMatchEnd, matcher.end(1), replStart, sb.length(), false);
                    lastMatchEnd = matcher.end(1);
                    splittedStringList.add(indexPair);
                }
                replStart = sb.length();
                indexPair = new IndexPair(lastMatchEnd, matcher.end(2), replStart, sb.length(), true);
                lastMatchEnd = matcher.end(2);
                splittedStringList.add(indexPair);
            }
            int replStart = sb.length();
            matcher.appendTail(sb);
            if (sb.length() != replStart) {
                IndexPair indexPair = new IndexPair(lastMatchEnd, text.length(), replStart, sb.length(), false);
                splittedStringList.add(indexPair);
            }
            stringWithoutTags = sb.toString();
        }
        StringBuffer sbResult = new StringBuffer();
        for (Iterator iter = splittedStringList.iterator(); iter.hasNext(); ) {
            IndexPair pair = (IndexPair) iter.next();
            if (pair.mIsTag) append(sbResult, text, pair.originalStart, pair.originalEnd); else {
                Matcher matcher = pattern.matcher(text.substring(pair.originalStart, pair.originalEnd));
                int mStart = 0;
                int mEnd = 0;
                int mEndOld = 0;
                int mStartOld = 0;
                while (matcher.find()) {
                    mStart = matcher.start();
                    mEnd = matcher.end();
                    append(sbResult, text, pair.originalStart + mEndOld, pair.originalStart + mStart);
                    sbResult.append(replacement);
                    mEndOld = mEnd;
                    mStartOld = mStart;
                }
                append(sbResult, text, pair.originalStart + mEndOld, pair.originalEnd);
            }
        }
        return sbResult.toString();
    }

    /**
     * Need to program this, as the stringbuffer method 
     * appears in java 1.5 first.
     *  */
    private void append(StringBuffer pSbResult, String pText, int pStart, int pEnd) {
        pSbResult.append(pText.substring(pStart, pEnd));
    }

    public int getMinimalOriginalPosition(int pI, ArrayList pListOfIndices) {
        for (Iterator iter = pListOfIndices.iterator(); iter.hasNext(); ) {
            IndexPair pair = (IndexPair) iter.next();
            if (pI >= pair.replacedStart && pI <= pair.replacedEnd) {
                return pair.originalStart + pI - pair.replacedStart;
            }
        }
        throw new IllegalArgumentException("Position " + pI + " not found.");
    }

    /**
	 * @return the maximal index i such that pI is mapped to i by removing all
	 *         tags from the original input.
	 */
    public int getMaximalOriginalPosition(int pI, ArrayList pListOfIndices) {
        for (int i = pListOfIndices.size() - 1; i >= 0; --i) {
            IndexPair pair = (IndexPair) pListOfIndices.get(i);
            if (pI >= pair.replacedStart) {
                if (!pair.mIsTag) {
                    return pair.originalStart + pI - pair.replacedStart;
                } else {
                    return pair.originalEnd;
                }
            }
        }
        throw new IllegalArgumentException("Position " + pI + " not found.");
    }

    /**
     */
    public static boolean isHtmlNode(String text) {
        for (int i = 0; i < text.length(); i++) {
            final char ch = text.charAt(i);
            if (ch == '<') {
                break;
            }
            if (!Character.isWhitespace(ch) || i == text.length()) {
                return false;
            }
        }
        return HTML_PATTERN.matcher(text.toLowerCase(Locale.ENGLISH)).matches();
    }

    public static String unicodeToHTMLUnicodeEntity(String text) {
        StringBuffer result = new StringBuffer((int) (text.length() * 1.2));
        int intValue;
        char myChar;
        for (int i = 0; i < text.length(); ++i) {
            myChar = text.charAt(i);
            intValue = (int) text.charAt(i);
            if (intValue < 32 || intValue > 126) {
                result.append("&#x").append(Integer.toString(intValue, 16)).append(';');
            } else {
                result.append(myChar);
            }
        }
        return result.toString();
    }

    /**
	 * Converts XML unicode entity-encoded characters into plain Java unicode
	 * characters; for example, ''&amp;#xff;'' gets converted. Removes all
	 * XML-invalid entity characters, such as &amp;#xb;.
	 * 
	 * @param text
	 *            input
	 * @return the converted output.
	 */
    public static String unescapeHTMLUnicodeEntity(String text) {
        StringBuffer result = new StringBuffer(text.length());
        StringBuffer entity = new StringBuffer();
        boolean readingEntity = false;
        char myChar;
        char entityChar;
        for (int i = 0; i < text.length(); ++i) {
            myChar = text.charAt(i);
            if (readingEntity) {
                if (myChar == ';') {
                    if (entity.charAt(0) == '#') {
                        try {
                            if (entity.charAt(1) == 'x') {
                                entityChar = (char) Integer.parseInt(entity.substring(2), 16);
                            } else {
                                entityChar = (char) Integer.parseInt(entity.substring(1), 10);
                            }
                            if (isXMLValidCharacter(entityChar)) result.append(entityChar);
                        } catch (NumberFormatException e) {
                            result.append('&').append(entity).append(';');
                        }
                    } else {
                        result.append('&').append(entity).append(';');
                    }
                    entity.setLength(0);
                    readingEntity = false;
                } else {
                    if (isXMLValidCharacter(myChar)) entity.append(myChar);
                }
            } else {
                if (myChar == '&') {
                    readingEntity = true;
                } else {
                    if (isXMLValidCharacter(myChar)) result.append(myChar);
                }
            }
        }
        if (entity.length() > 0) {
            result.append('&').append(entity).append(';');
        }
        return result.toString();
    }

    /** Removes all tags (<..>) from a string if it starts with "<html>..." to make it compareable.
     */
    public static String removeHtmlTagsFromString(String text) {
        if (HtmlTools.isHtmlNode(text)) {
            return removeAllTagsFromString(text);
        } else {
            return text;
        }
    }

    public static String removeAllTagsFromString(String text) {
        return TAGS_PATTERN.matcher(text).replaceAll("");
    }

    public static String htmlToPlain(String text) {
        return htmlToPlain(text, true);
    }

    public static String htmlToPlain(String text, boolean strictHTMLOnly) {
        if (strictHTMLOnly && !isHtmlNode(text)) {
            return text;
        }
        String intermediate = text.replaceAll("(?ims)[\n\t]", "").replaceAll("(?ims) +", " ").replaceAll("(?ims)<br.*?>", "\n").replaceAll("(?ims)<p.*?>", "\n\n").replaceAll("(?ims)<div.*?>", "\n").replaceAll("(?ims)<tr.*?>", "\n").replaceAll("(?ims)<dt.*?>", "\n").replaceAll("(?ims)<dd.*?>", "\n   ").replaceAll("(?ims)<td.*?>", " ").replaceAll("(?ims)<[uo]l.*?>", "\n").replaceAll("(?ims)<li.*?>", "\n   * ").replaceAll("(?ims) *</[^>]*>", "").replaceAll("(?ims)<[^/][^>]*> *", "").replaceAll("^\n+", "").trim();
        intermediate = HtmlTools.unescapeHTMLUnicodeEntity(intermediate);
        intermediate = intermediate.replaceAll("(?ims)&lt;", "<").replaceAll("(?ims)&gt;", ">").replaceAll("(?ims)&quot;", "\"").replaceAll("(?ims)&nbsp;", " ");
        return intermediate.replaceAll("(?ims)&amp;", "&");
    }

    public static String plainToHTML(String text) {
        char myChar;
        String textTabsExpanded = text.replaceAll("\t", "         ");
        StringBuffer result = new StringBuffer(textTabsExpanded.length());
        int lengthMinus1 = textTabsExpanded.length() - 1;
        result.append("<html><body><p>");
        for (int i = 0; i < textTabsExpanded.length(); ++i) {
            myChar = textTabsExpanded.charAt(i);
            switch(myChar) {
                case '&':
                    result.append("&amp;");
                    break;
                case '<':
                    result.append("&lt;");
                    break;
                case '>':
                    result.append("&gt;");
                    break;
                case ' ':
                    if (i > 0 && i < lengthMinus1 && (int) textTabsExpanded.charAt(i - 1) > 32 && (int) textTabsExpanded.charAt(i + 1) > 32) {
                        result.append(' ');
                    } else {
                        result.append("&nbsp;");
                    }
                    break;
                case '\n':
                    result.append("<br>");
                    break;
                default:
                    result.append(myChar);
            }
        }
        return result.toString();
    }

    public static String toXMLUnescapedText(String text) {
        return text.replaceAll("&lt;", "<").replaceAll("&gt;", ">").replaceAll("&quot;", "\"").replaceAll("&amp;", "&");
    }

    public static String toXMLEscapedTextExpandingWhitespace(String text) {
        text = text.replaceAll("\t", "         ");
        int len = text.length();
        StringBuffer result = new StringBuffer(len);
        char myChar;
        for (int i = 0; i < len; ++i) {
            myChar = text.charAt(i);
            switch(myChar) {
                case '&':
                    result.append("&amp;");
                    break;
                case '<':
                    result.append("&lt;");
                    break;
                case '>':
                    result.append("&gt;");
                    break;
                case ' ':
                    if (i > 0 && i < len - 1 && (int) text.charAt(i - 1) > 32 && (int) text.charAt(i + 1) > 32) {
                        result.append(' ');
                    } else {
                        result.append("&nbsp;");
                    }
                    break;
                default:
                    result.append(myChar);
            }
        }
        return result.toString();
    }

    public static String toXMLEscapedText(String text) {
        return text.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("\"", "&quot;");
    }

    /**
     * @return true, if well formed XML.
     */
    public boolean isWellformedXml(String xml) {
        try {
            SAXParserFactory factory = SAXParserFactory.newInstance();
            factory.setValidating(false);
            factory.newSAXParser().parse(new InputSource(new StringReader(xml)), new DefaultHandler());
            return true;
        } catch (SAXParseException e) {
            logger.log(Level.SEVERE, "XmlParseError on line " + e.getLineNumber() + " of " + xml, e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "XmlParseError", e);
        }
        return false;
    }

    public static String replaceIllegalXmlCharacters(String fileContents) {
        fileContents = fileContents.replaceAll("&#x0*[Aa];", "\n");
        fileContents = fileContents.replaceAll("&#x0*1?[0-9A-Fa-f];", "");
        fileContents = fileContents.replaceAll("&#0*[1-2]?[0-9];", "");
        fileContents = fileContents.replaceAll("&#0*3[0-1];", "");
        return fileContents;
    }

    /**
	 * Determines whether the character is valid in XML. Invalid characters
	 * include most of the range x00-x1F, and more. 
	 * @see http://www.w3.org/TR/2000/REC-xml-20001006#NT-Char.
	 */
    public static boolean isXMLValidCharacter(char character) {
        return character >= 0x20 && character <= 0xD7FF || character == 0x9 || character == 0xA || character == 0xD || character >= 0xE000 && character <= 0xFFFD || character >= 0x10000 && character <= 0x10FFFF;
    }

    public static String removeInvalidXmlCharacters(String text) {
        StringBuffer result = new StringBuffer(text.length());
        StringBuffer entity = new StringBuffer();
        boolean readingEntity = false;
        char myChar;
        char entityChar;
        for (int i = 0; i < text.length(); ++i) {
            myChar = text.charAt(i);
            if (readingEntity) {
                if (myChar == ';') {
                    if (entity.charAt(0) == '#') {
                        try {
                            if (entity.charAt(1) == 'x') {
                                entityChar = (char) Integer.parseInt(entity.substring(2), 16);
                            } else {
                                entityChar = (char) Integer.parseInt(entity.substring(1), 10);
                            }
                            if (isXMLValidCharacter(entityChar)) result.append('&').append(entity).append(';');
                        } catch (NumberFormatException e) {
                            result.append('&').append(entity).append(';');
                        }
                    } else {
                        result.append('&').append(entity).append(';');
                    }
                    entity.setLength(0);
                    readingEntity = false;
                } else {
                    entity.append(myChar);
                }
            } else {
                if (myChar == '&') {
                    readingEntity = true;
                } else {
                    if (isXMLValidCharacter(myChar)) result.append(myChar);
                }
            }
        }
        if (entity.length() > 0) {
            result.append('&').append(entity).append(';');
        }
        return result.toString();
    }

    public static String extractHtmlBody(String output) {
        if (output.startsWith("<html")) {
            output = output.substring(6);
        }
        int start = output.indexOf("<body");
        if (start == -1) {
            start = output.indexOf('>') + 1;
        } else {
            start = output.indexOf('>', start + 5) + 1;
        }
        int end = output.indexOf("</body>");
        if (end == -1) {
            end = output.indexOf("</html>");
        }
        if (end == -1) {
            end = output.length();
        }
        output = output.substring(start, end);
        return output;
    }

    public static String replaceSpacesToNonbreakableSpaces(String input) {
        StringBuffer result = new StringBuffer(input.length());
        boolean readingSpaces = false;
        char myChar;
        for (int i = 0; i < input.length(); ++i) {
            myChar = input.charAt(i);
            if (myChar == ' ') {
                if (readingSpaces) {
                    result.append(NBSP);
                } else {
                    result.append(myChar);
                    readingSpaces = true;
                }
            } else {
                readingSpaces = false;
                result.append(myChar);
            }
        }
        return result.toString();
    }
}
