package net.sf.jpkgmk.pkgmap;

import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import net.sf.jpkgmk.AbstractFileCreatorAdapter;
import net.sf.jpkgmk.DefaultFileHandler;
import net.sf.jpkgmk.FileHandler;
import net.sf.jpkgmk.PackageException;
import net.sf.jpkgmk.util.ObjectUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * pkgmap is an ASCII file that provides a complete listing of the package contents. 
 * It is automatically generated by pkgmk(1) using the information in the prototype(4) file.
 * 
 * Representation of a package map file (called "pkgmap" on the filesystem).
 * The pkgmap file is a packing list, where each item in the package is defined and its size and 
 * checksum are stored. The size and checksum help in determining that the package has not 
 * been tampered with. The various items in the pkgmap are recognized by their ftype entry as shown here.
 * 
 * See 
 * <a href="http://docs.sun.com/app/docs/doc/805-6338">sun docs</a>
 * <a href="http://www.cs.biu.ac.il/cgi-bin/man?pkgmap+4">http://www.cs.biu.ac.il/cgi-bin/man?pkgmap+4</a> and
 * <a href="http://www.sun.com/bigadmin/features/techtips/package_components.jsp">http://www.sun.com/bigadmin/features/techtips/package_components.jsp</a>
 * <a href="http://www.softpanorama.org/Solaris/Packages/index.shtml">http://www.softpanorama.org/Solaris/Packages/index.shtml</a>.
 * 
 * @author gommma (gommma AT users.sourceforge.net)
 * @author Last changed by: $Author: gommma $
 * @version $Revision: 2 $ $Date: 2008-08-20 15:14:19 -0400 (Wed, 20 Aug 2008) $
 * @since 1.0
 */
public class PkgMap extends AbstractFileCreatorAdapter {

    /**
     * Integer constant for the value {@value}
     */
    private static final Integer ONE = Integer.valueOf(1);

    /**
	 * The name of the file on the filesystem
	 */
    public static final String PKGMAP = "pkgmap";

    private Log log = LogFactory.getLog(PkgMap.class);

    /**
	 * Set holding all entries of the package map
	 */
    private List<PkgMapEntry> pkgMapEntryList = new ArrayList<PkgMapEntry>();

    private PkgMapEntryHeader header;

    /**
	 */
    public PkgMap() {
        super();
    }

    @Override
    public FileHandler getFileHandler(File targetDir) {
        DefaultFileHandler fileCreator = new DefaultFileHandler(targetDir, PKGMAP);
        return fileCreator;
    }

    public void writeContent(Writer writer) throws IOException {
        if (this.header == null) {
            throw new IllegalStateException("Before creating the pkgmap, the header must be set via setHeader().");
        }
        header.write(writer);
        sort(this.pkgMapEntryList);
        for (Iterator<PkgMapEntry> iter = this.pkgMapEntryList.iterator(); iter.hasNext(); ) {
            PkgMapEntry entry = (PkgMapEntry) iter.next();
            entry.write(writer);
        }
        writer.flush();
    }

    /**
	 * Sorts the given list of pkgmap entries.
	 * <p>
	 * As defined in the sun docs:
	 * &quot;The package objects in pkgmap are listed in alphabetical order by class and by path name to
	 * reduce the time it takes to install the package.&quot;
	 * </p>
	 * @param pkgMapEntryList2
	 */
    void sort(List<PkgMapEntry> pkgMapEntryList2) {
        log.debug("<entering> sort(List<PkgMapEntry>)");
        List<EntryCommentAssociation> entryCommandAssocList = createEntryCommandAssoc(pkgMapEntryList2);
        List<PkgMapEntry> entryListWithoutComments = filterComments(pkgMapEntryList2);
        Collections.sort(entryListWithoutComments, new PkgMapEntrySorter());
        List<PkgMapEntry> fullResultList = addCommentsIfNeeded(entryListWithoutComments, entryCommandAssocList);
        this.pkgMapEntryList = fullResultList;
    }

    private List<PkgMapEntry> addCommentsIfNeeded(List<PkgMapEntry> entryListWithoutComments, List<EntryCommentAssociation> entryCommandAssocList) {
        List<PkgMapEntry> resultList = new ArrayList<PkgMapEntry>();
        for (PkgMapEntry currentEntry : entryListWithoutComments) {
            for (EntryCommentAssociation entryCommentAssoc : entryCommandAssocList) {
                if (entryCommentAssoc.getEntry().equals(currentEntry)) {
                    resultList.addAll(entryCommentAssoc.getCommentList());
                    break;
                }
            }
            resultList.add(currentEntry);
        }
        return resultList;
    }

    private List<PkgMapEntry> filterComments(List<PkgMapEntry> pkgMapEntryList2) {
        List<PkgMapEntry> resultList = new ArrayList<PkgMapEntry>();
        for (PkgMapEntry pkgMapEntry : pkgMapEntryList2) {
            if (!(pkgMapEntry instanceof PkgMapEntryComment)) {
                resultList.add(pkgMapEntry);
            }
        }
        return resultList;
    }

    private List<EntryCommentAssociation> createEntryCommandAssoc(List<PkgMapEntry> pkgMapEntryList2) {
        List<EntryCommentAssociation> assocList = new ArrayList<EntryCommentAssociation>();
        List<PkgMapEntryComment> commentList = new ArrayList<PkgMapEntryComment>();
        for (PkgMapEntry entry : pkgMapEntryList2) {
            if (entry instanceof PkgMapEntryComment) {
                commentList.add((PkgMapEntryComment) entry);
            } else {
                AbstractPkgMapEntry mapEntry = (AbstractPkgMapEntry) entry;
                if (!commentList.isEmpty()) {
                    EntryCommentAssociation entryCommentAssoc = new EntryCommentAssociation(mapEntry, commentList);
                    assocList.add(entryCommentAssoc);
                    commentList = new ArrayList<PkgMapEntryComment>();
                } else {
                    log.debug("Comment list is empty. No need to create a comment association for current entry.");
                }
            }
        }
        return assocList;
    }

    /**
	 * @return Unmodifiable list of the pkgmap entries
	 */
    public List<PkgMapEntry> getPkgMapEntries() {
        return Collections.unmodifiableList(this.pkgMapEntryList);
    }

    /**
	 * Adds all the given entries to this pkgmap object.
	 * @param pkgMapEntryList
	 */
    public void addAll(List<PkgMapEntry> pkgMapEntryList) {
        for (Iterator<PkgMapEntry> iterator = pkgMapEntryList.iterator(); iterator.hasNext(); ) {
            PkgMapEntry pkgMapEntry = iterator.next();
            this.add(pkgMapEntry);
        }
    }

    /**
	 * Adds a prototype entry. Does <b>not</b> create the physical file yet
	 * @param entry
	 * @return Returns <code>true</code> if the entry was added successfully.
	 */
    public void add(PkgMapEntry entry) {
        log.debug("Adding entry: " + entry);
        if (PkgMapEntryHeader.class.isAssignableFrom(entry.getClass())) {
            this.setHeader((PkgMapEntryHeader) entry);
        } else {
            if (pkgMapEntryList.contains(entry)) {
                PkgMapEntry existingEntry = findEntryThatEquals(entry);
                throw new PackageException("Entry that equals the given one '" + entry + "' already exists in the current map. Equal entry in list: '" + existingEntry + "'.");
            }
            boolean success = pkgMapEntryList.add(entry);
            if (!success) {
                throw new PackageException("Failed to add the entry '" + entry + "' to the map.");
            }
        }
    }

    /**
	 * Sets the only header for this pkgmap. If it was already set before, an exception is thrown.
	 * @param header
	 */
    public void setHeader(PkgMapEntryHeader header) {
        if (this.header != null) {
            throw new IllegalStateException("The header is already set. Cannot overwrite");
        }
        if (header == null) {
            log.info("Resetting pkgmap header to null");
        }
        this.header = header;
    }

    public PkgMapEntryHeader getHeader() {
        return this.header;
    }

    /**
	 * @return Returns the number of entries that are currently in this map
	 */
    public int getSize() {
        return this.pkgMapEntryList.size();
    }

    /**
	 * Searches for an entry in the {@link #pkgMapEntryList} which equals the given entry (current.equals(entry)==true).
	 * @param entry The entry to be searched
	 * @return The result entry or null if no equal entry was found
	 */
    private PkgMapEntry findEntryThatEquals(PkgMapEntry entry) {
        for (Iterator<PkgMapEntry> iter = this.pkgMapEntryList.iterator(); iter.hasNext(); ) {
            PkgMapEntry currentEntry = (PkgMapEntry) iter.next();
            if (currentEntry.equals(entry)) {
                return currentEntry;
            }
        }
        return null;
    }

    /**
	 * @return The number of different parts that exist in the current pkgmap. If the part of an entry
	 * is <code>null</code>, the value 1 is assumed by default as defined in the sun specs.
	 */
    public Integer getNumberOfParts() {
        Set<Integer> foundParts = new HashSet<Integer>();
        for (Iterator<PkgMapEntry> iter = this.pkgMapEntryList.iterator(); iter.hasNext(); ) {
            PkgMapEntry currentEntry = (PkgMapEntry) iter.next();
            if (PkgMapEntryFile.class.isAssignableFrom(currentEntry.getClass())) {
                PkgMapEntryFile currentEntryFile = (PkgMapEntryFile) currentEntry;
                Integer part = currentEntryFile.getPart();
                if (part == null) {
                    part = ONE;
                }
                foundParts.add(part);
            }
        }
        return foundParts.size();
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((header == null) ? 0 : header.hashCode());
        result = prime * result + ((pkgMapEntryList == null) ? 0 : pkgMapEntryList.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        return this.equals(obj, false);
    }

    /**
	 * @param obj
	 * @param ignoreLastModified
	 * @return
	 */
    public boolean equals(Object obj, boolean ignoreLastModified) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        final PkgMap other = (PkgMap) obj;
        if (!ObjectUtils.areObjectsEqual(this.header, other.header)) return false;
        if (pkgMapEntryList == null) {
            if (other.pkgMapEntryList != null) return false;
        } else if (!listsEqual(pkgMapEntryList, other.pkgMapEntryList, ignoreLastModified)) return false;
        return true;
    }

    private boolean listsEqual(List<PkgMapEntry> list1, List<PkgMapEntry> list2, boolean ignoreLastModified) {
        if (!ignoreLastModified) {
            return list1.equals(list2);
        } else {
            ListIterator<PkgMapEntry> e1 = list1.listIterator();
            ListIterator<PkgMapEntry> e2 = list2.listIterator();
            while (e1.hasNext() && e2.hasNext()) {
                PkgMapEntry o1 = e1.next();
                PkgMapEntry o2 = e2.next();
                if (!(o1 == null ? o2 == null : o1.equals(o2, ignoreLastModified))) return false;
            }
            return !(e1.hasNext() || e2.hasNext());
        }
    }

    @Override
    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append(getClass().getName()).append("[");
        sb.append(super.toString());
        sb.append("[");
        sb.append("entries=").append(this.pkgMapEntryList);
        sb.append("]");
        sb.append("]");
        return sb.toString();
    }

    /**
	 * Sorter for PkgMap entries
	 */
    private static class PkgMapEntrySorter implements Comparator<PkgMapEntry> {

        public int compare(PkgMapEntry o1, PkgMapEntry o2) {
            if (o1 instanceof PkgMapEntryHeader) {
                return -1;
            } else if (o2 instanceof PkgMapEntryHeader) {
                return 1;
            } else if (o1 instanceof AbstractPkgMapEntry && o2 instanceof AbstractPkgMapEntry) {
                AbstractPkgMapEntry o1Abstract = (AbstractPkgMapEntry) o1;
                AbstractPkgMapEntry o2Abstract = (AbstractPkgMapEntry) o2;
                return o1Abstract.compareTo(o2Abstract);
            } else {
                throw new UnsupportedOperationException("Unknown pkgmap entry type: " + o1 + " and " + o2);
            }
        }
    }

    /**
	 * Links a pkgmap entry with one or more comments
	 */
    private static class EntryCommentAssociation {

        private PkgMapEntry entry;

        private List<PkgMapEntryComment> commentList;

        public EntryCommentAssociation(PkgMapEntry entry, List<PkgMapEntryComment> commentList) {
            this.entry = entry;
            this.commentList = commentList;
        }

        public PkgMapEntry getEntry() {
            return entry;
        }

        public List<PkgMapEntryComment> getCommentList() {
            return commentList;
        }
    }
}
