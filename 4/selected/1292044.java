package com.jot.system.transaction;

import java.util.List;
import mojasi.HashedByteWord;
import mojasi.MojasiException;
import mojasi.MojasiName;
import mojasi.MojasiParser;
import mojasi.MojasiToken;
import mojasi.MojasiWriter;
import mojasi.PJSONOmit;
import org.apache.log4j.Logger;
import com.jot.system.CachedObject;
import com.jot.system.JotContext;
import com.jot.system.JotMojasiParser;
import com.jot.system.RecurringAutoRpc;
import com.jot.system.nio.JotSocket;
import com.jot.system.pjson.Entity;
import com.jot.system.pjson.Guid;
import com.jot.system.pjson.PJSONName;
import com.jot.system.pjson.PjsonFactory;
import com.jot.system.pjson.PjsonParseUtil;
import com.jot.system.pjson.PjsonWriteUtil;

@PJSONName("SaveEntityTransaction")
@MojasiName("SvETrans")
public class SaveEntityTransaction extends Transaction {

    public static Logger logger = Logger.getLogger(SaveEntityTransaction.class);

    public byte[] json;

    public boolean readOnly;

    public Guid apisession;

    public int serial;

    @PJSONOmit
    private byte[] lockedJson = null;

    public Guid widgetServerName;

    public Guid saveAckGuid;

    public SaveEntityTransaction(JotContext ggg, Guid dest) {
        super(ggg, dest);
    }

    public SaveEntityTransaction(JotSocket jport) {
        super(jport);
    }

    SaveEntityTransaction(Guid me) {
        super(me);
    }

    private SaveEntityTransaction() {
        super();
    }

    @Override
    public void acquireLock() {
        if (rpc("acquireLock")) return;
        if (g.queueEntityLock(entity, this)) run(); else {
            g.clearEntityLock(entity, this);
            dofailed("someone holds a lock on a new save - impossible " + entity);
        }
    }

    @PJSONOmit
    int islocked = 0;

    @PJSONOmit
    int inlocked = 0;

    @Override
    public String lockWork() {
        islocked++;
        inlocked++;
        CachedObject obj = g.objectServers.find(entity);
        if (obj == null) {
            String errstr = null;
            if (json == null) errstr = "null data!!" + entity + " session=" + apisession; else if (json.length < 2) errstr = "small data!!" + entity + " session=" + apisession;
            if (errstr != null) {
                logger.error(errstr);
                return errstr;
            }
            lockedJson = json;
            json = new byte[] { 0 };
            notes = "saving item=" + entity;
            inlocked--;
            return null;
        }
        String errstr = "object " + entity + " already exists, from  apisession=" + apisession;
        logger.error(errstr);
        inlocked--;
        return errstr;
    }

    @PJSONOmit
    int iscommit = 0;

    @PJSONOmit
    int incommit = 0;

    @Override
    public void commitWork() {
        if (iscommit != 0) logger.error("should NOT be committed " + entity);
        if (incommit != 0) logger.error("should NOT be reentering commit " + entity);
        iscommit++;
        incommit++;
        if (islocked == 0) {
            logger.warn("should be islocked " + this.votes + " vs " + this.expected + " " + entity);
            return;
        }
        if (inlocked != 0) logger.error("should not be in locked " + entity);
        if (lockedJson == null) {
            logger.error("lockedJson null in commit " + entity);
            incommit--;
            return;
        }
        if (lockedJson.length <= 1) {
            logger.error("lockedJson too small in commit " + entity);
            incommit--;
            return;
        }
        if (logger.isTraceEnabled()) logger.trace("commiting save of entity " + entity + " on " + g.peer.getName().toStringTrimmed() + " trans=" + getGuid());
        int version = 0;
        if (readOnly) version = -1;
        Entity ee = JotMojasiParser.bytes2Entity(lockedJson, g);
        JotSocket wsock = g.getPeerPort(widgetServerName);
        g.objectServers.put(entity, wsock, ee, version, lockedJson);
        lockedJson = null;
        SaveEntityAck ack = new SaveEntityAck(g, widgetServerName);
        ack.init(saveAckGuid);
        ack.apisession = apisession;
        ack.serial = serial;
        ack.entity = this.entity;
        ack.commitWork();
        incommit--;
        disconnected();
    }

    @Override
    public void dofailed(String message) {
        SaveEntityAck ack = new SaveEntityAck(g, widgetServerName);
        ack.init(saveAckGuid);
        ack.apisession = apisession;
        ack.serial = serial;
        ack.entity = this.entity;
        ack.failed();
        super.dofailed(message);
    }

    /**
     * This is the serialization interface for all objects in the object store. I got sick of debugging the
     * reflection involved with other serialization methods, and they were slow.
     * </p>
     * It is generated by <code>GenPseudoJson</code> so don't bother editing it. <code>GenPseudoJson</code>
     * will generate code to support adding and deleting instance variables by keeping state in a json file of the
     * same name as this class. To get a fresh version simply delete the json file and run
     * <code>GenPseudoJson</code>
     */
    public void writePjson(PjsonWriteUtil writer) {
        writer.writeGUID(guid);
        writer.writeByteArray(json);
        writer.writeBoolean(readOnly);
        writer.writeGUID(apisession);
        writer.writeInt(serial);
        writer.writeGUID(widgetServerName);
        writer.writeGUID(saveAckGuid);
        writer.writeGUID(entity);
        writer.writeInt(expected);
        writer.writeGenericList(managers);
        writer.writeGUID(widget);
        writer.writeEntityStub(user);
    }

    @SuppressWarnings("unchecked")
    private void parseVersion1Pjson(PjsonParseUtil parser) throws Exception {
        if (parser.peek() != '}') {
            json = parser.readBytesArray();
            readOnly = parser.readBoolean();
            apisession = parser.readGuid();
            serial = parser.readInt();
            widgetServerName = parser.readGuid();
            saveAckGuid = parser.readGuid();
            entity = parser.readGuid();
            expected = parser.readInt();
            managers = (List<com.jot.system.pjson.Guid>) parser.readGenericList();
            widget = parser.readGuid();
            user = (com.jot.system.entities.User) parser.parseGenericObject();
        }
        g = parser.global;
        sock = parser.sock;
    }

    public static class SaveEntityTransactionFactory extends PjsonFactory {

        public Object make(PjsonParseUtil parser) throws Exception {
            parser.entityGuid = parser.readGuid();
            SaveEntityTransaction tmp;
            synchronized (parser.global.getRecurringFactoryLock(parser.entityGuid)) {
                tmp = (SaveEntityTransaction) parser.global.recurringFactoryLookup(parser.entityGuid);
                if (tmp == null) tmp = new SaveEntityTransaction(parser.entityGuid);
                parser.global.recurringFactoryAdd(tmp, parser);
            }
            parser.global.lockRecurringAutoRpc(tmp, parser);
            tmp.parseVersion1Pjson(parser);
            return tmp;
        }
    }

    public static PjsonFactory factory = new SaveEntityTransactionFactory();

    @Override
    public Logger getLogger() {
        return logger;
    }

    @Override
    public void managerTimedOut() {
        ;
    }

    public void fireItUp(Guid session, Guid item, int serial, List<Guid> mgrs, byte[] jsonBytes, boolean readOnly) {
        lock.lock();
        this.apisession = session;
        this.serial = serial;
        this.entity = item;
        this.managers = mgrs;
        this.expected = mgrs.size();
        this.widgetServerName = g.peer.getName();
        this.saveAckGuid = Guid.createSecretGuid();
        this.readOnly = readOnly;
        this.json = jsonBytes;
        if (this.json == null) logger.error("missing data for save " + item);
        if (this.json != null && this.json.length == 0) logger.error("zero length data for save " + item);
        if (this.managers.size() == 0) logger.error("there are no servers for this bucket. This is extremely bad");
        for (Guid mgr : mgrs) {
            if (logger.isTraceEnabled()) logger.trace("sending SaveEntityTransaction for entity=" + item + " to " + mgr);
            if (json == null) logger.error("What happened to my data ?");
            this.setDestGuid(mgr);
            this.acquireLock();
            if (json == null) logger.error("What happened to my data ?");
        }
        lock.unlock();
        setTimeToLive(0);
        bumpTimeout();
    }

    private static HashedByteWord guid_moj = new HashedByteWord(",gu");

    public Object preMojasiMake(MojasiParser parser, MojasiToken token) {
        Guid myGuid = null;
        try {
            parser.loadDictionary(token);
            myGuid = null;
            MojasiToken kv;
            if ((kv = parser.find(guid_moj)) != null) myGuid = (Guid) parser.parseObject(kv); else logger.error("missing guid for entity");
        } catch (MojasiException e) {
            logger.error("preMojasiMake ", e);
        }
        RecurringAutoRpc tmp = null;
        JotContext jotg = (JotContext) (parser.global);
        synchronized (jotg.getRecurringFactoryLock(myGuid)) {
            tmp = (SaveEntityTransaction) jotg.recurringFactoryLookup(myGuid);
            if (tmp == null) tmp = new SaveEntityTransaction(myGuid);
            try {
                jotg.recurringFactoryAdd(tmp, null);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return tmp;
    }

    /**
     * This is the serialization interface for objects. I got sick of debugging the
     * reflection involved with other serialization methods, and they were slow.
     * </p>
     * It is generated by <code>GenerateMojasi</code> so don't bother editing it. <code>GenerateMojasi</code>
     * will generate code to support adding and deleting instance variables by keeping state in a m.json file of the
     * same name as the alias of this class.
     */
    public static class SaveEntityTransactionMFactory extends TransactionMFactory {

        private HashedByteWord json_moj = new HashedByteWord(",js");

        private HashedByteWord readOnly_moj = new HashedByteWord(",re");

        private HashedByteWord apisession_moj = new HashedByteWord(",ap");

        private HashedByteWord serial_moj = new HashedByteWord(",se");

        private HashedByteWord widgetServerName_moj = new HashedByteWord(",wi");

        private HashedByteWord saveAckGuid_moj = new HashedByteWord(",sa");

        @SuppressWarnings("unchecked")
        public SaveEntityTransactionMFactory() {
            super(new MojasiToken("SvETrans"), SaveEntityTransaction.class);
        }

        @SuppressWarnings("unchecked")
        public SaveEntityTransactionMFactory(MojasiToken name, Class clazz) {
            super(name, clazz);
        }

        @Override
        public Object read(MojasiParser parser, MojasiToken token, Object obj) throws MojasiException {
            super.read(parser, token, obj);
            SaveEntityTransaction me = (SaveEntityTransaction) obj;
            MojasiToken kv;
            if ((kv = parser.find(json_moj)) != null) me.json = parser.parseByteArray(kv);
            if ((kv = parser.find(readOnly_moj)) != null) me.readOnly = parser.parseBool(kv);
            if ((kv = parser.find(apisession_moj)) != null) me.apisession = (Guid) parser.parseObject(kv);
            if ((kv = parser.find(serial_moj)) != null) me.serial = parser.parseInt(kv);
            if ((kv = parser.find(widgetServerName_moj)) != null) me.widgetServerName = (Guid) parser.parseObject(kv);
            if ((kv = parser.find(saveAckGuid_moj)) != null) me.saveAckGuid = (Guid) parser.parseObject(kv);
            me.mojasiReadExtras(parser);
            return obj;
        }

        ;

        @Override
        public void write(MojasiWriter w, Object obj1) throws MojasiException {
            SaveEntityTransaction me = (SaveEntityTransaction) obj1;
            super.write(w, obj1);
            if ((w.mask & 0xffff) != 0) w.writeByteArray(json_moj, me.json);
            if ((w.mask & 0xffff) != 0) w.writeBool(readOnly_moj, me.readOnly);
            if ((w.mask & 0xffff) != 0) w.writeGenericObject(apisession_moj, me.apisession);
            if ((w.mask & 0xffff) != 0) w.writeInt(serial_moj, me.serial);
            if ((w.mask & 0xffff) != 0) w.writeGenericObject(widgetServerName_moj, me.widgetServerName);
            if ((w.mask & 0xffff) != 0) w.writeGenericObject(saveAckGuid_moj, me.saveAckGuid);
        }

        ;

        @Override
        public Object make(MojasiParser parser, MojasiToken token) {
            Object tmp = null;
            if (tmp == null) tmp = new SaveEntityTransaction();
            return tmp;
        }

        ;

        @Override
        public void init() {
            super.init();
            addAlias("js", "json");
            addAlias("re", "readOnly");
            addAlias("ap", "apisession");
            addAlias("se", "serial");
            addAlias("wi", "widgetServerName");
            addAlias("sa", "saveAckGuid");
        }

        ;
    }

    ;
}
