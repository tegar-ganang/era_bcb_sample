package equilServer;

import equilSharedFramework.ClientInterface;
import equilSharedFramework.Reply;
import equilSharedFramework.ServerInterface;
import equilSharedFramework.ConfigFile;
import java.rmi.Naming;
import java.rmi.RMISecurityManager;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.LinkedList;
import java.util.Random;

/**
 * A Server object acts as the EQUIL server. Clients call methods on it
 * via RMI, and it calls methods on the various clients using RMI. Keeps track
 * of labs, lab queues, users, and also acts as a go-between for user
 * authentication, allowing clients to request authentication by using the 
 * Authenticator class.
 * @author CITS3200 2006 Group E
 * @version 1.0.0
 */
public class Server extends UnicastRemoteObject implements ServerInterface {

    /** The location of the server configuration file on disk. */
    private static final String cPath = "config/ServerConfig.txt";

    /** Key representing authentication method in config file */
    private static final String cAuthKey = "AuthMethod";

    /** The authentication method to use. Default is LDAP */
    private String authMethod = Authenticator.authLDAP;

    /** The name of the equil RMI service */
    private static final String SERVICE_NAME = "Equil";

    /** The length of the session keys generated by the server */
    private static final int keySize = 20;

    /** Location of file storing lab data */
    private static final String LAB_DATA = "config/LabInfo.txt";

    /** An enumeration of the possible callbacks */
    private enum Callback {

        UPDATE, REMOVE, MESSAGE, STOPPED
    }

    /** A reference to the authentication object */
    private Authenticator auth;

    /** A list of all running labs */
    private LinkedList<Lab> runningLabs;

    /** A list of all authenticated demonstrator session keys */
    private LinkedList<String> demonstratorKeys;

    /** A list of all authenticated student keys */
    private LinkedList<String> studentKeys;

    private static String logPath = "logs/server.log";

    private static boolean logToFile = true;

    private static boolean logToConsole = true;

    private Logger fileLog;

    /**
     * Main method - runs the server.
     */
    public static void main(String[] args) {
        if (System.getSecurityManager() == null) {
            System.setSecurityManager(new RMISecurityManager());
        }
        try {
            Server server = new Server();
            Naming.rebind("//localhost/" + SERVICE_NAME, server);
            server.write("Server started.");
        } catch (Exception e) {
            System.out.println("Server failed to start.");
        }
    }

    /**
     * Creates a new Server object.
     */
    public Server() throws RemoteException {
        fileLog = new Logger(logPath);
        auth = new Authenticator();
        demonstratorKeys = new LinkedList<String>();
        studentKeys = new LinkedList<String>();
        runningLabs = new LinkedList<Lab>();
        try {
            ConfigFile config = new ConfigFile(cPath);
            authMethod = config.getValue(cAuthKey);
        } catch (Exception e) {
            write("Error reading server configuration file.");
        }
    }

    /**
     * Attempts to log a student in to the server. Logging in requires
     * successful authentication of the student's username and password.
     * Once a student has logged in, they are assigned a session key for
     * use in further communications with the server.
     * @param username the user name of the student
     * @param password the password of the student
     * @return a Reply object indicating the success of this operation.
     *         The Reply will contain a session key if successful.
     */
    public Reply studentLogin(String username, String password) throws RemoteException {
        if (username.equals("")) {
            return new Reply(false, "Username field is blank");
        }
        if (password.equals("")) {
            return new Reply(false, "Password field is blank");
        }
        if (auth.authenticateUser(authMethod, username, password)) {
            String sessionKey = generateSessionKey();
            studentKeys.add(sessionKey);
            return new Reply(true, sessionKey);
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /**
     * Attempts to log a student off the server. Logging off requires
     * a valid session key to be provided. The act of logging off will
     * remove this session key from the list of authenticated session keys
     * in the server.
     * @param sessionKey the session key of the student who is logging off
     * @return a Reply object indicating the success of this operation
     */
    public Reply studentLogoff(String sessionKey) throws RemoteException {
        if (isAuthStudent(sessionKey)) {
            for (Lab lab : runningLabs) {
                if (lab.inLab(sessionKey)) {
                    studentRemoveFromQueue(sessionKey);
                    lab.removeUser(sessionKey);
                    studentKeys.remove(sessionKey);
                    return new Reply(true, "Successfully logged off");
                }
            }
            for (String sKey : studentKeys) {
                if (sKey.equals(sessionKey)) {
                    studentKeys.remove(sessionKey);
                    return new Reply(true, "Successfully logged off");
                }
            }
            return new Reply(false, "Already logged off.");
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /** 
     * Register a client for RMI callbacks with a certain lab. This
     * method should only be called once the client has joined a lab.
     * @param sessionKey the session key of the user to register for callbacks
     * @param ci         a reference to the ClientInterface object for the user
     * @return a Reply object indicating the success of this operation
     */
    private Reply registerForCallback(String sessionKey, ClientInterface ci) {
        for (Lab lab : runningLabs) {
            if (lab.addClientInterface(sessionKey, ci)) return new Reply(true, "Added ClientInterface successfully");
        }
        return new Reply(false, "Can't add ClientInterface, User not in lab");
    }

    private void callback(Lab toCallBackStudentsIn) {
        for (User student : toCallBackStudentsIn.getStudentsInLab()) {
            callback(Callback.UPDATE, student.getSessionKey(), toCallBackStudentsIn.getQueuedMachines());
        }
    }

    private void callback(final Callback type, final String sessionKey, final String[] data) {
        Thread callbackManager = new Thread() {

            public void run() {
                ClientInterface ci;
                for (Lab lab : runningLabs) {
                    ci = lab.getClientInterface(sessionKey);
                    if (ci != null) {
                        try {
                            switch(type) {
                                case REMOVE:
                                    ci.notifyOfRemoval(sessionKey);
                                    break;
                                case MESSAGE:
                                    ci.showMessage(sessionKey, data[0]);
                                    break;
                                case UPDATE:
                                    ci.updateQueue(sessionKey, data);
                                    break;
                                case STOPPED:
                                    ci.notifyLabStopped(sessionKey);
                            }
                        } catch (RemoteException e) {
                            removeFromLab(sessionKey);
                        }
                        break;
                    }
                }
            }
        };
        callbackManager.start();
    }

    /**
     * Special callback method that takes a User, so it doesn't
     * need to search through session keys.
     */
    private void callback(final Callback type, final User user, final String[] data) {
        Thread callbackManager = new Thread() {

            public void run() {
                ClientInterface ci = user.getClientInterface();
                String sessionKey = user.getSessionKey();
                if (ci != null) {
                    try {
                        switch(type) {
                            case REMOVE:
                                ci.notifyOfRemoval(sessionKey);
                                break;
                            case MESSAGE:
                                ci.showMessage(sessionKey, data[0]);
                                break;
                            case UPDATE:
                                ci.updateQueue(sessionKey, data);
                                break;
                            case STOPPED:
                                ci.notifyLabStopped(sessionKey);
                        }
                    } catch (RemoteException e) {
                        removeFromLab(sessionKey);
                    }
                }
            }
        };
        callbackManager.start();
    }

    /**
     * Attempts to add a student to a laboratory session.
     * @param sessionKey   the session key of the student
     * @param labName      the name of the lab to join
     * @param studentName  the name of the student
     * @param hostName     the hostname of the client computer
     * @return a Reply object indicating the success of the operation
     */
    public Reply studentAddToLab(String sessionKey, String labName, String studentName, String hostName, ClientInterface ci) throws RemoteException {
        if (isAuthStudent(sessionKey)) {
            boolean added = false;
            int i = 0;
            while (Character.isLetter(labName.charAt(i))) i++;
            while (labName.charAt(i) != 'L') i++;
            String unitCode = labName.substring(0, i);
            for (Lab lab : runningLabs) {
                if (lab.getName().equals(labName)) {
                    if (ConfigReader.isEnrolled(unitCode, studentName, LAB_DATA)) {
                        lab.addStudent(studentName, hostName, sessionKey);
                        registerForCallback(sessionKey, ci);
                        callback(lab);
                        added = true;
                    } else {
                        return new Reply(false, "Not enrolled in the unit.");
                    }
                }
            }
            if (added) {
                return new Reply(true, "Successfully joined lab.");
            } else {
                return new Reply(false, "Failed to join lab: Lab does not exist.");
            }
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /**
     * Attempts to remove a student from a laboratory session.
     * @param sessionKey the session key of the student
     * @return a Reply object indicating the success of the operation
     */
    public Reply studentRemoveFromLab(String sessionKey) throws RemoteException {
        if (isAuthStudent(sessionKey)) {
            if (removeFromLab(sessionKey)) {
                return new Reply(true, "Successfully left lab.");
            } else {
                return new Reply(false, "Failed to leave lab.");
            }
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /**
     * Associates demonstrator with particular lab for callback purposes.
     * <p>
     * Treats a demonstrator simply as a User (but it won't be added to queue)
     * @param sessionKey    the session key of the demonstrator
     * @param labName       the name of the lab to associate with
     * @return a Reply object indicating the success of the operation
     */
    public Reply demonstratorAddToLab(String sessionKey, String labName, ClientInterface ci) throws RemoteException {
        if (isAuthDemonstrator(sessionKey)) {
            for (Lab lab : runningLabs) {
                if (lab.getName().equals(labName)) {
                    lab.addStudent("Demonstrator", "Dem hostname", sessionKey);
                    registerForCallback(sessionKey, ci);
                    callback(lab);
                    return new Reply(true, "Successfully started managing lab");
                }
            }
            return new Reply(false, "Unable to manage lab: Lab not found");
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /**
     * Dissociates demonstrator from a laboratory session that it is
     * associated with.
     * <p>
     * Treats demonstrator like a user, so works in similar way to 
     * studentRemoveFromLab method.
     * @param sessionKey    the session key of the demonstrator
     * @return a Reply object indicating the success of the operation
     */
    public Reply demonstratorRemoveFromLab(String sessionKey) throws RemoteException {
        if (isAuthDemonstrator(sessionKey)) {
            if (removeFromLab(sessionKey)) {
                return new Reply(true, "Successfully stopped managing lab.");
            } else {
                return new Reply(false, "Failed to stop managing lab.");
            }
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /** 
     * A private helper method that removes a specified student from the
     * lab that they are currently a member of. Also calls back any other
     * students in that lab, and provides them with an updated queue.
     * @param sessionKey the session key of the user to remove
     */
    private boolean removeFromLab(String sessionKey) {
        for (Lab lab : runningLabs) if (lab.inLab(sessionKey)) {
            lab.leaveQueue(sessionKey);
            lab.removeUser(sessionKey);
            callback(lab);
            return true;
        }
        return false;
    }

    /**
     * Attempts to add a student to the queue of the laboratory session
     * that they are currently in.
     * @param sessionKey the session key of the student
     * @return a Reply object indicating the success of the operation
     */
    public Reply studentAddToQueue(String sessionKey) throws RemoteException {
        if (isAuthStudent(sessionKey)) {
            boolean added = false;
            for (Lab lab : runningLabs) {
                if (lab.inLab(sessionKey)) {
                    lab.joinQueue(sessionKey);
                    added = true;
                    callback(lab);
                }
            }
            if (added) {
                return new Reply(true, "Successfully joined queue.");
            } else {
                return new Reply(false, "Failed to join queue.");
            }
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /**
     * Attempts to remove a student from the queue of the laboratory session
     * that the are currently in.
     * @param sessionKey the session key of the student
     * @return a Reply object indicating the success of the operation
     */
    public Reply studentRemoveFromQueue(String sessionKey) throws RemoteException {
        if (isAuthStudent(sessionKey)) {
            if (removeFromQueue(sessionKey)) {
                return new Reply(true, "Successfully left queue.");
            } else {
                return new Reply(false, "Failed to leave queue: Not in queue");
            }
        } else {
            return new Reply(false, "Failed to authenticate");
        }
    }

    /** 
     * A private helper method that removes a specified student from the
     * queue of the lab that they are currently a member of. Also calls 
     * back any other students in that lab, and provides them with an 
     * updated queue.
     * @param sessionKey the session key of the user to remove
     */
    private boolean removeFromQueue(String sessionKey) {
        for (Lab lab : runningLabs) if (lab.inQueue(sessionKey)) {
            lab.leaveQueue(sessionKey);
            callback(lab);
            return true;
        }
        return false;
    }

    /**
     * Indicates that a student has been attended to by a laboratory
     * demonstrator.
     * @param sessionKey the session key of the student
     * @return a Reply object indicating the success of the operation
     */
    public Reply studentNotifyAttendedTo(String sessionKey) throws RemoteException {
        return studentRemoveFromQueue(sessionKey);
    }

    /**
     * Attempts to log a demonstrator in to the server. Logging in requires
     * successful authentication of the demonstrator's username and password.
     * Once a demonstrator has logged in, they are assigned a session key for
     * use in further communications with the server.
     * @param username the user name of the demonstrator
     * @param password the password of the demonstrator
     * @return a Reply object indicating the success of this operation.
     *         The Reply will contain a session key if successful.
     */
    public Reply demonstratorLogin(String username, String password) throws RemoteException {
        if (username.equals("")) {
            return new Reply(false, "Username field is blank");
        }
        if (password.equals("")) {
            return new Reply(false, "Password field is blank");
        }
        if (auth.authenticateDemonstrator(username, password)) {
            String sessionKey = generateSessionKey();
            demonstratorKeys.add(sessionKey);
            return new Reply(true, sessionKey);
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /**
     * Attempts to log a demonstrator off the server. Logging off requires
     * a valid session key to be provided. The act of logging off will
     * remove this session key from the list of authenticated session keys
     * in the server.
     * @param sessionKey the session key of the demonstrator who is logging off
     * @return a Reply object indicating the success of this operation
     */
    public Reply demonstratorLogoff(String sessionKey) throws java.rmi.RemoteException {
        if (isAuthDemonstrator(sessionKey)) {
            for (Lab lab : runningLabs) {
                if (lab.inLab(sessionKey)) {
                    lab.removeUser(sessionKey);
                    demonstratorKeys.remove(sessionKey);
                    return new Reply(true, "Successfully logged off");
                }
            }
            for (String dKey : demonstratorKeys) {
                if (dKey.equals(sessionKey)) {
                    demonstratorKeys.remove(sessionKey);
                    return new Reply(true, "Successfully logged off");
                }
            }
            return new Reply(false, "Already logged off.");
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /**
     * Removes the student specified by hostLocation if the sessionKey matches
     * a demonstrator.
     * @param sessionKey the session key for demonstrator to be checked
     * @param hostLocation the machine name of the student to be removed
     * @return a Reply object indicating the success of this operation
     */
    public Reply demonstratorRemoveStudent(String sessionKey, String hostLocation) throws java.rmi.RemoteException {
        if (isAuthDemonstrator(sessionKey)) {
            for (Lab lab : runningLabs) {
                if (lab.inLab(sessionKey)) {
                    LinkedList<User> students = lab.getStudentsInLab();
                    for (User user : students) {
                        if (user.getLocation().equals(hostLocation)) {
                            String sKey = user.getSessionKey();
                            callback(Callback.REMOVE, sKey, new String[] {});
                            return studentRemoveFromQueue(sKey);
                        }
                    }
                    return new Reply(false, "Failed to find student in queue.");
                }
            }
            return new Reply(false, "Failed to remove student from queue.");
        } else {
            return new Reply(false, "Failed to authenticate");
        }
    }

    /**
     * Attempts to create a new laboratory session. Only an authenticated
     * demonstrator can create laboratory sessions.
     * @param sessionKey  the session key of the demonstrator who is attempting
     *                    to create the laboratory session
     * @param name        the name of the laborator session
     * @param description a description of the laboratory session
     * @return a Reply object indicating the success of this operation
     */
    public Reply demonstratorStartLab(String sessionKey, String name, String description) throws java.rmi.RemoteException {
        boolean labExists = false;
        if (isAuthDemonstrator(sessionKey)) {
            for (Lab lab : runningLabs) {
                if (lab.getName().equals(name)) {
                    labExists = true;
                }
            }
            if (!labExists) {
                runningLabs.add(new Lab(name, description));
                write("Lab started: " + name);
                return new Reply(true, "Lab started.");
            } else {
                return new Reply(false, "Lab already running.");
            }
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /**
     * Attempts to stop a laboratory session. Only an authenticated
     * demonstrator can stop laboratory sessions.
     * @param sessionKey  the session key of the demonstrator who is attempting
     *                    to stop the laboratory session
     * @return a Reply object indicating the success of this operation
     */
    public Reply demonstratorStopLab(String sessionKey) throws RemoteException {
        if (isAuthDemonstrator(sessionKey)) {
            for (Lab lab : runningLabs) {
                if (lab.inLab(sessionKey)) {
                    runningLabs.remove(lab);
                    for (User user : lab.getStudentsInLab()) {
                        callback(Callback.STOPPED, user, new String[] {});
                        removeFromLab(user.getSessionKey());
                        studentKeys.remove(sessionKey);
                        demonstratorKeys.remove(sessionKey);
                    }
                    write("Lab stopped: " + lab.getName());
                    return new Reply(true, "Lab successfully stopped.");
                }
            }
            return new Reply(false, "Couldnt find lab, which demonstrator is in.");
        } else {
            return new Reply(false, "Failed to authenticate.");
        }
    }

    /**
     * Attempts to retrieve a list of all possible labs.
     * @param sessionKey sessionKey that is checked for to see if it is
     *        in use by demonstrator, if not, authentication fails and a special
     *        matrix is returned.
     * @return  a 2-dimensional array where the (i,0) entry is the unique lab ID
     *          and the (i,1) entry is the lab description. Return value is a 
     *          1x1 array if authentication fails. If no labs are running, 
     */
    public String[][] getAllLabs(String sessionKey) {
        if (isAuthDemonstrator(sessionKey)) {
            return ConfigReader.getLabs(LAB_DATA);
        } else {
            String[][] errorArray = new String[1][1];
            errorArray[0][0] = "Failed to authenticate.";
            return errorArray;
        }
    }

    /**
     * Attempts to retrieve a list of runninglabs.
     * @param sessionKey sessionKey that is checked for to see if it is
     *        in use by student or demonstrator, if not, authentication fails 
     *        and a special matrix is returned.
     * @return  a 2-dimensional array where the (i,0) entry is the unique lab ID
     *          and the (i,1) entry is the lab description. Return value is a 
     *          1x1 array if authentication fails. If no labs are running, a 0
     *          length array is returned, as expected.
     */
    public String[][] getRunningLabs(String sessionKey) {
        if (isAuthStudent(sessionKey) || isAuthDemonstrator(sessionKey)) {
            String[][] rLabs = new String[runningLabs.size()][2];
            for (int i = 0; i < runningLabs.size(); i++) {
                rLabs[i][0] = runningLabs.get(i).getName();
                rLabs[i][1] = runningLabs.get(i).getDescription();
            }
            return rLabs;
        } else {
            String[][] errorArray = new String[1][1];
            errorArray[0][0] = "Failed to authenticate.";
            return errorArray;
        }
    }

    /**
     * Generates a session key containing only characters between 'A' and 'Z'.
     * @return a session key
     */
    private String generateSessionKey() {
        Random generator = new Random(System.currentTimeMillis());
        char[] key = new char[keySize];
        for (int i = 0; i < keySize; i++) {
            int r = generator.nextInt(26) + 65;
            key[i] = (char) r;
        }
        String sessionKey = new String(key);
        if (isAuthDemonstrator(sessionKey) || isAuthStudent(sessionKey)) {
            sessionKey = generateSessionKey();
        }
        return sessionKey;
    }

    /**
     * Checks if the specified session key has been authenticated as a
     * demonstrator.
     * @param sessionKey    the session key to test
     * @return              true if the session key belongs to a 
     *                      demonstrator, false otherwise
     */
    private boolean isAuthDemonstrator(String sessionKey) {
        for (String s : demonstratorKeys) {
            if (sessionKey.equals(s)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if the specified session key has been authenticated as a
     * student.
     * @param sessionKey    the session key to test
     * @return              true if the session key belongs to a 
     *                      student, false otherwise
     */
    private boolean isAuthStudent(String sessionKey) {
        for (String s : studentKeys) {
            if (sessionKey.equals(s)) {
                return true;
            }
        }
        return false;
    }

    private void write(String s) {
        if (logToFile) fileLog.write(s);
        if (logToConsole) System.out.println(s);
    }
}
