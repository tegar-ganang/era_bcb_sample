package org.servebox.flex.mojo;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import org.apache.commons.io.FileUtils;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.project.MavenProject;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.log.LogSystem;
import org.servebox.flex.mojo.base.AbstractFlexMakeMojo;
import org.servebox.flex.mojo.eclipse.EclipseDependency;
import org.servebox.flex.mojo.eclipse.EclipseHelper;
import org.servebox.flex.mojo.util.DependencyComparator;
import org.servebox.flex.mojo.util.FlexMojoUtils;
import flex2.tools.oem.Builder;

/**
 * Create the project descriptors used by FlexBuilder plugin :<br>
 * - .project<br>
 * - .flexProperties<br>
 * - .actionScriptProperties<br>
 * By default, if this goal is run on a multiproject root, dependencies between modules
 * will be configured as project dependencies.
 * 
 * @author J.F.Mathiot
 * @goal eclipse
 * @requiresDependencyResolution test
 * @requiresProject
 */
public class EclipseMojo extends AbstractFlexMakeMojo implements LogSystem {

    /** @parameter expression="${localRepository}" */
    protected org.apache.maven.artifact.repository.ArtifactRepository localRepository;

    public static final String PROJECT_NAME_DEFAULT_TEMPLATE = "[artifactId]";

    public static final String PROJECT_NAME_WITH_VERSION_TEMPLATE = "[artifactId]-[version]";

    public static final String PROJECT_NAME_WITH_GROUP_TEMPLATE = "[groupId].[artifactId]";

    public static final String PROJECT_NAME_WITH_GROUP_AND_VERSION_TEMPLATE = "[groupId].[artifactId]-[version]";

    /**
     * The projects in the reactor.
     * 
     * @parameter expression="${reactorProjects}"
     * @readonly
     */
    private List<MavenProject> reactorProjects;

    /**
     * A list of extra Flex Applications that will be added into the
     * actrionScriptProperties file.
     * 
     * @parameter expression="${flex.eclipse.mxmlExtraFiles}"
     */
    protected File[] mxmlExtraFiles;

    /**
     * Control of outputfolder name for eclipse compilation
     * 
     * @parameter expression="${flex.eclipse.eclipseOutputFolderName}"
     */
    protected String eclipseOutputFolderName;

    /**
     * Indicates to compiler if must automatically determine rsls' order depending on
     * dependencies.
     * 
     * @parameter expression="${flex.eclipse.autoRSLOrdering}" default-value="true"
     * @felxversion Flex 4
     */
    protected boolean autoRSLOrdering = true;

    /**
     * Indicates to FlexBuilder whether the non-embedded files should be copied to the
     * output directory.
     * 
     * @parameter expression="${flex.eclipse.copyDependentFiles}" default-value="true"
     */
    protected boolean copyDependentFiles = true;

    /**
     * If set to true, Flash Text Engine will be used in mx components.
     * 
     * @parameter expression="${flex.eclipse.fteInMXComponents}" default-value="false"
     * @felxversion Flex 4
     */
    protected boolean fteInMXComponents = false;

    /**
     * Indicates whether the source should be compiled on server.<br>
     * It seems weird when using Maven, but we let the option there.
     * 
     * @parameter expression="${flex.eclipse.serverCompile}" default-value="false"
     */
    protected boolean serverCompile = false;

    /**
     * Indicates whether dependencies that exists in the reactor should be created as
     * sub-projects instead<br>
     * of deployed packages.
     * 
     * @parameter expression="${flex.eclipse.useProjectReferences}" default-value="true"
     */
    protected boolean useProjectReferences = true;

    /**
     * Indicate whether the version number of the artifact is appended to the name of the
     * generated FlexBuilder project.
     * 
     * @parameter expression="${flex.eclipse.addVersionToProjectName}"
     *            default-value="false"
     */
    protected boolean addVersionToProjectName;

    /**
     * Indicates whether the groupId of the artifact is appended to the name of the
     * generated FlexBuilder project.
     * 
     * @parameter expression="${flex.eclipse.addGroupIdToProjectName}"
     *            default-value="false"
     */
    protected boolean addGroupIdToProjectName;

    /**
     * Indicates whether the html wrapper generated by FlexBuilder should include player
     * version checks.
     * 
     * @parameter expression="${flex.eclipse.htmlPlayerVersionCheck}" default-value="true"
     */
    protected boolean htmlPlayerVersionCheck = true;

    /**
     * Indicates whether the html wrapper generated by FlexBuilder should include auto
     * install flag.
     * 
     * @parameter expression="${flex.eclipse.htmlExpressInstall}" default-value="true"
     */
    protected boolean htmlExpressInstall = true;

    /**
     * Indicate whether the html wrapper should be generate
     * 
     * @parameter expression="${flex.eclipse.htmlGenerate}" default-value="true"
     */
    protected boolean htmlGenerate = true;

    /**
     * Indicates whether the html wrapper generated by FlexBuilder should support history
     * management.
     * 
     * @parameter expression="${flex.eclipse.htmlHistoryManagement}" default-value="true"
     */
    protected boolean htmlHistoryManagement = true;

    /**
     * Indicates sourcePath for dependencies
     * 
     * @parameter expression="${flex.eclipse.sourceAttachments}"
     */
    protected ArrayList<SourcePathEntry> sourceAttachments;

    /**
     * A list containing the URL to use for runtime-shared libraries.
     * 
     * @parameter expression="${flex.compiler.rsls}"
     */
    protected ArrayList<RuntimeSharedLibrary> rsls;

    protected Map<String, RuntimeSharedLibrary> rslMap;

    /**
     * The type of server used on the back-end side, if applicable. One of:<br>
     * ASP-IIS: deployment on IIS / ASP.net<br>
     * PHP: deployment on a server hosting the PHP script engine<br>
     * J2EE: deployment on a J2EE server without BlazeDS or Adobe LiveCycle Data Services<br>
     * ColdFusion: deployment on a ColdFusion server without BlazeDS, Adobe LiveCycle Data
     * Services ES or ColdFusion Flash Remoting<br>
     * J2EE-Remoting: deployment on a J2EE server with BlazeDS or Adobe LiveCycle Data
     * Services ES<br>
     * ColdFusion-Remoting: deployment on a ColdFusion server with BlazeDS, Adobe
     * LiveCycle Data Services ES or ColdFusion Flash Remoting<br>
     * 
     * @parameter expression="${flex.eclipse.flexServerType}"
     */
    protected String flexServerType = null;

    /**
     * The path to the server root directory.
     * 
     * @parameter expression="${flex.eclipse.serverRoot}"
     */
    protected File serverRoot = null;

    /**
     * The URL used while debugging Flex applications.
     * 
     * @parameter expression="${flex.eclipse.serverRootUrl}"
     */
    protected URL serverRootUrl = null;

    /**
     * The path used as the context root.
     * 
     * @parameter expression="${flex.eclipse.serverContextRoot}"
     */
    protected String serverContextRoot = null;

    /**
     * The modules to compile before building the main artifact.
     * 
     * @parameter expression="${flex.eclipse.modules}"
     */
    protected ArrayList<Module> modules;

    /**
     * By default this option is not enabled. During code generation, each client
     * application in a project creates their own instance of a data service. If you want
     * a single instance of a service that all client applications in the project share,
     * enable this option. This option is only available if you specify the default Flash
     * Builder code generation utility.
     * 
     * @parameter expression="${flex.eclipse.enableServiceManager}" default-value="false"
     * @felxversion Flex 4
     */
    protected boolean enableServiceManager;

    /**
     * The type of Remote Object Access Service. BlazeDS-J2EE: BlazeDS with a J2EE server.
     * BlazeDS-ColdFusion: BlazeDS with a ColdFusion server. LCDS-ES-J2EE: LiveCycle Data
     * Services ES with a J2EE server. LCDS-ES-ColdFusion: LiveCycle Data Services ES with
     * a ColdFusion server.
     * 
     * @parameter expression="${flex.eclipse.flexServerFeature}"
     * @felxversion Flex 4
     */
    protected String flexServerFeature;

    /**
     * If true application will use IIS. If false application will use ASP.NET development
     * server.
     * 
     * @parameter expression="${flex.eclipse.useIIS}" default-value="false"
     * @felxversion Flex 4
     */
    protected boolean useIIS = false;

    /**
     * The namespaces to include to the artifact.
     * 
     * @parameter expression="${flex.compiler.includeNamespaces}"
     */
    protected ArrayList<String> includeNamespaces;

    /**
     * A list of dependencies to exclude from the Flex build path. Use this option in
     * conjunction with the localSdk parameter as a workaround to allow Flash Builder
     * design mode to work properly.
     * 
     * @parameter expression="${flex.eclipse.eclipseExclusions}"
     */
    protected ArrayList<Exclusion> eclipseExclusions;

    /**
     * The name of a local SDK to add to the build path. Use "default" to use the default
     * SDK. The name should match the name of a SDK available to FlashBuilder.
     * 
     * @parameter expression="${flex.eclipse.localSdk}"
     */
    protected String localSdk;

    /**
     * Indicate whether the locales should be retrieved by Eclipse using the local SDK installation.
     * 
     * @parameter expression="${flex.eclipse.useLocalesFromSdk}" default="false"
     */
    protected boolean useLocalesFromSdk = false;

    private String projectNameTemplate;

    private String getProjectNameTemplate() {
        return projectNameTemplate;
    }

    private Map<String, EclipseDependency> reactorDependencies;

    private MavenProject rootProject;

    private boolean isHandledPackagingType(MavenProject subproject) {
        return subproject.getPackaging().equals(FlexMojoUtils.getSWCPackagingType()) || subproject.getPackaging().equals(FlexMojoUtils.getSWFPackagingType());
    }

    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        try {
            initVelocityEngine();
        } catch (Exception e) {
            throw new MojoExecutionException("Unable to prepare Eclipse project generation, due to a Velocity initialization exception.", e);
        }
        reactorDependencies = new HashMap<String, EclipseDependency>();
        for (MavenProject subproject : reactorProjects) {
            if (isHandledPackagingType(subproject)) {
                reactorDependencies.put(getArtifactQualifiedId(subproject.getArtifact()), new EclipseDependency(subproject.getArtifact().getGroupId(), subproject.getArtifact().getArtifactId(), subproject.getArtifact().getVersion(), subproject.getArtifact().getClassifier(), true, false, false, false, subproject.getBasedir(), subproject.getArtifact().getType(), getProjectName(calculateProjectNameTemplate(), subproject)));
            }
            if (subproject.isExecutionRoot()) {
                rootProject = subproject;
            }
        }
        if (isHandledPackagingType(project)) {
            LinkedHashMap<String, EclipseDependency> projectDependencies = resolveDependencies(project, reactorDependencies);
            copyGlobalSWCDependencies(project, projectDependencies);
            String nature;
            try {
                nature = getProjectNature(project);
            } catch (Exception e) {
                getLog().warn("Packaging does not correspond to any Flex project nature : " + project.getPackaging() + ", skipping.");
                return;
            }
            if (!project.isExecutionRoot() || reactorProjects.size() == 1) {
                checkServerConfiguration(project);
                if (FlexMojoUtils.isFlex4()) {
                    checkServiceFeatureConfiguration(project);
                }
                createProjectDescriptor(project.getBasedir().getName(), nature, projectDependencies);
                createFlexPropertiesDescriptor(nature, projectDependencies);
                createActionScriptPropertiesDescriptor(nature, projectDependencies);
                if (useApolloConfig) {
                    if (airConfig != null) {
                        createAirDescriptor(sourceDirectory);
                    }
                }
            }
        } else {
            getLog().info("Skipping project " + getArtifactQualifiedId(project.getArtifact()) + " as the packaging type is unknown.");
        }
    }

    /**
     * Checks project's server configuration and validates it.
     * 
     * @param project
     * @throws MojoExecutionException
     */
    private void checkServerConfiguration(MavenProject project) throws MojoExecutionException {
        if (!project.getPackaging().equals(FlexMojoUtils.getSWFExtension()) || flexServerType == null || flexServerType.length() < 1) {
            flexServerType = EclipseHelper.FLEX_SERVER_TYPE_NONE_ID;
            return;
        }
        if (!(flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_J2EE_REMOTING_ID) || flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_COLDFUSION_REMOTING_ID) || flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_PHP_ID) || flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_ASP_ID) || flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_J2EE_ID) || flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_COLDFUSION_ID))) {
            throw new MojoExecutionException("Unrecognized server type : " + flexServerType);
        }
        checkServerRoot();
        if (serverContextRoot == null) {
            serverContextRoot = "";
        }
    }

    /**
     * Checks defined Remote Object Access Service
     * 
     * @param project
     * @throws MojoExecutionException
     * @felxversion Flex 4
     */
    private void checkServiceFeatureConfiguration(MavenProject project) throws MojoExecutionException {
        if (!project.getPackaging().equals(FlexMojoUtils.getSWFExtension()) || flexServerFeature == null || flexServerFeature.length() < 1) {
            flexServerFeature = EclipseHelper.FLEX_SERVER_FEATURE_NONE_ID;
            return;
        }
        if (!(flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_COLDFUSION_BLAZEDS_ID) || flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_J2EE_BLAZEDS_ID) || flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_COLDFUSION_LCDS_ES_ID) || flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_J2EE_LCDS_ES_ID) || flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_COLDFUSION_FLASH_REMOTING_ID))) {
            throw new MojoExecutionException("Unrecognized Remote Object Access Service : " + flexServerFeature);
        }
        checkServerRoot();
        if ((flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_COLDFUSION_FLASH_REMOTING_ID) || flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_COLDFUSION_BLAZEDS_ID) || flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_COLDFUSION_LCDS_ES_ID)) && !flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_COLDFUSION_REMOTING_ID)) {
            throw new MojoExecutionException("Remote object access service with a type " + flexServerFeature + " can be used only with a " + EclipseHelper.FLEX_SERVER_TYPE_COLDFUSION_REMOTING_ID + " server type");
        }
        if ((flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_J2EE_BLAZEDS_ID) || flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_J2EE_LCDS_ES_ID)) && !flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_J2EE_REMOTING_ID)) {
            throw new MojoExecutionException("Remote object access service with a type " + flexServerFeature + " can be used only with a " + EclipseHelper.FLEX_SERVER_TYPE_J2EE_REMOTING_ID + " server type");
        }
        if (!flexServerFeature.toUpperCase().equals(EclipseHelper.FLEX_SERVER_FEATURE_NONE_ID) && !(flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_J2EE_REMOTING_ID) || flexServerType.toUpperCase().equals(EclipseHelper.FLEX_SERVER_TYPE_COLDFUSION_REMOTING_ID))) {
            throw new MojoExecutionException(flexServerFeature + " is not compatible with : " + flexServerType + " server type");
        }
    }

    /**
     * Checks whether serverRoot and serverRootUrl are defined for using flexServerType
     * and flexServerFeatures.
     * 
     * @throws MojoExecutionException
     */
    private void checkServerRoot() throws MojoExecutionException {
        if (serverRoot == null || !serverRoot.exists()) {
            throw new MojoExecutionException("The property serverRoot should be set.");
        }
        if (serverRootUrl == null) {
            throw new MojoExecutionException("The property serverRootUrl should be set.");
        }
    }

    /**
     * The playerglobal and airglobal SWC dependencies won't work
     * @param project
     * @param projectDependencies
     * @throws MojoExecutionException
     */
    private void copyGlobalSWCDependencies(MavenProject project, HashMap<String, EclipseDependency> projectDependencies) throws MojoExecutionException {
        for (EclipseDependency dep : projectDependencies.values()) {
            checkGlobalDependency(dep.getArtifactId(), dep.getVersion());
            if (dep.getArtifactId().equals(PLAYERGLOBAL) || dep.getArtifactId().equals(AIRGLOBAL)) {
                File libsDir = new File(project.getBasedir() + "/libs");
                if (!libsDir.exists()) {
                    libsDir.mkdir();
                }
                try {
                    File dependencyFile = new File(libsDir, dep.getArtifactId() + "." + getDependenciesExtension());
                    FileUtils.copyFile(dep.getFile(), dependencyFile);
                    dep.setFile(dependencyFile);
                } catch (IOException e) {
                    throw new MojoExecutionException("Unable to copy " + dep.getArtifactId() + "to libs directory", e);
                }
            }
        }
    }

    /**
     * Resolve project dependencies.
     * 
     * @return resolved IDE dependencies, with attached SWCs for non-reactor dependencies.
     */
    @SuppressWarnings("unchecked")
    private LinkedHashMap<String, EclipseDependency> resolveDependencies(MavenProject subproject, Map<String, EclipseDependency> reactorDependencies) {
        Set<String> exclusions = getExclusionsAsString();
        LinkedHashMap<String, EclipseDependency> ideDependencies = new LinkedHashMap<String, EclipseDependency>();
        Set<Artifact> dependencies = new TreeSet<Artifact>(new DependencyComparator(rsls));
        dependencies.addAll(subproject.getArtifacts());
        for (Artifact dependency : dependencies) {
            if (dependency.getType().equals(getDependenciesExtension())) {
                if (exclusions.contains(dependency.getGroupId() + ":*") || exclusions.contains(dependency.getGroupId() + ":" + dependency.getArtifactId())) {
                    continue;
                }
                if (useProjectReferences && reactorDependencies.containsKey(getArtifactQualifiedId(dependency))) {
                    ideDependencies.put(getArtifactQualifiedId(dependency), reactorDependencies.get(getArtifactQualifiedId(dependency)));
                } else {
                    EclipseDependency ideDependency = new EclipseDependency(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion(), dependency.getClassifier(), false, dependency.getScope().equals(Artifact.SCOPE_TEST), dependency.getScope().equals(Artifact.SCOPE_PROVIDED), true, dependency.getFile(), dependency.getType(), null);
                    if (hasRslDeclaration(dependency.getGroupId(), dependency.getArtifactId())) {
                        RuntimeSharedLibrary lib = getRslDeclaration(dependency.getGroupId(), dependency.getArtifactId());
                        ideDependency.setRslUrls(lib.getUrls());
                        ideDependency.setVerifyDigests(lib.isVerifyDigests());
                    }
                    ideDependencies.put(getArtifactQualifiedId(dependency), ideDependency);
                }
            }
        }
        return ideDependencies;
    }

    private Set<String> getExclusionsAsString() {
        Set<String> exclusions = new HashSet<String>();
        for (Exclusion exclusion : eclipseExclusions) {
            if (exclusion.getArtifactId() != null) {
                exclusions.add(exclusion.getGroupId() + ":" + exclusion.getArtifactId());
            } else {
                exclusions.add(exclusion.getGroupId() + ":*");
            }
        }
        return exclusions;
    }

    protected boolean hasRslDeclaration(String groupId, String artifactId) {
        return getRslDeclaration(groupId, artifactId) != null;
    }

    protected RuntimeSharedLibrary getRslDeclaration(String groupId, String artifactId) {
        if (rslMap == null) {
            rslMap = new HashMap<String, RuntimeSharedLibrary>();
            for (RuntimeSharedLibrary rsl : rsls) {
                rslMap.put(rsl.getGroupId() + ":" + rsl.getArtifactId(), rsl);
            }
        }
        return rslMap.get(groupId + ":" + artifactId);
    }

    private String getArtifactQualifiedId(Artifact artifact) {
        return artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getBaseVersion() + ":" + artifact.getClassifier() + ":" + artifact.getType();
    }

    /**
     * Create the .project and add the required Eclipse natures.
     * 
     * @param nature2
     */
    protected void createProjectDescriptor(String projectName, String nature, HashMap<String, EclipseDependency> dependencies) throws MojoExecutionException {
        File projectFile = new File(project.getBasedir(), ".project");
        if (projectFile.exists()) {
            getLog().debug("Project file already exists, trying to remove it.");
            projectFile.delete();
        }
        try {
            projectFile.createNewFile();
            FileUtils.writeStringToFile(projectFile, EclipseHelper.getProjectDescriptorContent(projectName, nature, flexServerType, serverRoot), "UTF-8");
        } catch (Exception e) {
            throw new MojoExecutionException("Unable to create project descriptor.", e);
        }
    }

    private String getProjectNature(MavenProject subproject) throws Exception {
        if (subproject.getPackaging().equals("swc")) {
            return EclipseHelper.FLEX_LIB_NATURE;
        } else if (subproject.getPackaging().equals("swf")) {
            if (useApolloConfig) {
                return EclipseHelper.AIR_NATURE;
            }
            return EclipseHelper.FLEX_NATURE;
        }
        throw new Exception("Unknown packaging exception");
    }

    /**
     * Create the .flexProperties descriptor.
     */
    protected void createFlexPropertiesDescriptor(String nature, HashMap<String, EclipseDependency> dependencies) throws MojoExecutionException {
        File propertiesFile = new File(project.getBasedir(), (nature.equals(EclipseHelper.FLEX_NATURE) || nature.equals(EclipseHelper.AIR_NATURE)) ? ".flexProperties" : ".flexLibProperties");
        if (propertiesFile.exists()) {
            getLog().debug("Properties file already exists, trying to remove it.");
            propertiesFile.delete();
        }
        try {
            propertiesFile.createNewFile();
            String sourcesFolderPath = sourceDirectory.toURI().toString();
            String resourcesFolderPath = resourcesDirectory.exists() ? resourcesDirectory.toURI().toString() : null;
            String testFolderPath = testDirectory.exists() ? testDirectory.toURI().toString() : null;
            if (nature.equals(EclipseHelper.FLEX_NATURE) || nature.equals(EclipseHelper.AIR_NATURE)) {
                FileUtils.writeStringToFile(propertiesFile, EclipseHelper.getFlexPropertiesDescriptorContent(nature, flexServerType, serverRoot, serverRootUrl, serverContextRoot, serverCompile, archiveFiles, styleSheets, sourcesFolderPath, resourcesFolderPath, testFolderPath, enableServiceManager, flexServerFeature, useIIS, componentManifests), "UTF-8");
            } else {
                FileUtils.writeStringToFile(propertiesFile, EclipseHelper.getFlexPropertiesDescriptorContent(nature, flexServerType, null, null, null, serverCompile, getClassPathEntries(), archiveFiles, styleSheets, sourcesFolderPath, resourcesFolderPath, testFolderPath, enableServiceManager, flexServerFeature, useIIS, componentManifests, includeNamespaces), "UTF-8");
            }
        } catch (Exception e) {
            throw new MojoExecutionException("Unable to create flex properties descriptor.", e);
        }
    }

    @SuppressWarnings("unchecked")
    private Collection<String> getClassPathEntries() {
        Collection<File> contents = FileUtils.listFiles(sourceDirectory, new String[] { "as", "mxml" }, true);
        return FlexMojoUtils.filesToFullyQualifiedClassNames(sourceDirectory, contents);
    }

    /**
     * Create the .actionScriptProperties descriptor.
     */
    protected void createActionScriptPropertiesDescriptor(String nature, LinkedHashMap<String, EclipseDependency> dependencies) throws MojoExecutionException {
        File propertiesFile = new File(project.getBasedir(), ".actionScriptProperties");
        if (mxmlFile == null && (nature.equals(EclipseHelper.FLEX_NATURE) || nature.equals(EclipseHelper.AIR_NATURE))) {
            mxmlFile = new File(sourceDirectory + File.separator + "main.mxml");
        }
        if (propertiesFile.exists()) {
            getLog().debug("Properties file already exists, trying to remove it.");
            propertiesFile.delete();
        }
        String outputFolderLocation = null;
        String rootUrl = null;
        if (serverRoot != null && serverRoot.exists()) {
            if (eclipseOutputFolderName == null) outputFolderLocation = serverRoot.toURI().getPath() + project.getBasedir().getName() + "-debug"; else outputFolderLocation = serverRoot.toURI().getPath() + eclipseOutputFolderName;
            if (serverRootUrl == null || serverContextRoot == null) {
                throw new MojoExecutionException("Parameters serverRootUrl and serverContextRoot should be specified.");
            }
            try {
                if (eclipseOutputFolderName == null) rootUrl = new URL(serverRootUrl, serverContextRoot + "/" + project.getBasedir().getName() + "-debug").toString(); else rootUrl = new URL(serverRootUrl, serverContextRoot + "/" + eclipseOutputFolderName).toString();
            } catch (Exception e) {
                throw new MojoExecutionException("Unable to create rootUrl ", e);
            }
        }
        try {
            propertiesFile.createNewFile();
            String content = EclipseHelper.getActionScriptPropertiesDescriptorContent(rootProject, project, localRepository, nature, dependencies, mxmlFile != null ? FlexMojoUtils.relativePath(mxmlFile, sourceDirectory) : null, getmxmlExtraApplications(mxmlExtraFiles), localSdk, getAdditionalCompilerArguments(), autoRSLOrdering, copyDependentFiles, isFlex3Compatible, fteInMXComponents, false, enableAccessibility, htmlExpressInstall, targetFlashPlayer, htmlPlayerVersionCheck, htmlGenerate, htmlHistoryManagement, nature.equals(EclipseHelper.FLEX_LIB_NATURE) ? "bin" : "bin-debug", FlexMojoUtils.relativePath(sourceDirectory, project.getBasedir()), actionScriptStrictChecking, useApolloConfig, verifyDigests, showActionScriptWarnings, outputFolderLocation, (sourceAttachments != null && sourceAttachments.size() > 0 ? sourceAttachments : null), resourcesDirectory.exists() ? FlexMojoUtils.relativePath(resourcesDirectory, project.getBasedir()) : null, testDirectory.exists() ? FlexMojoUtils.relativePath(testDirectory, project.getBasedir()) : null, localesDirectory.exists() ? FlexMojoUtils.relativePath(localesDirectory, project.getBasedir()) : null, locales, useLocalesFromSdk, modules, rootUrl);
            FileUtils.writeStringToFile(propertiesFile, content, "UTF-8");
        } catch (Exception e) {
            throw new MojoExecutionException("Unable to create actionscript properties descriptor.", e);
        }
    }

    private List<String> getmxmlExtraApplications(File[] appliList) {
        List<String> appliPathList = new ArrayList<String>();
        for (int i = 0; i < appliList.length; i++) {
            File file = appliList[i];
            appliPathList.add(FlexMojoUtils.relativePath(file, sourceDirectory));
        }
        return appliPathList;
    }

    @SuppressWarnings("deprecation")
    private String getAdditionalCompilerArguments() throws MojoExecutionException {
        String aca = "";
        if (locales.size() > 0) {
            aca += "-locale=" + getLocalesAsString() + " -allow-source-path-overlap=true";
        } else {
            aca += "-locale " + locale;
        }
        if (actionScriptMetadatas.length > 0) {
            aca += " -keep-as3-metadata+=";
            aca += getActionscriptMetaDatasAsString();
        }
        if (!defineDirectives.isEmpty()) {
            for (DefineDirective directive : defineDirectives) {
                aca += " -define=" + directive.getName() + "," + directive.getValue().replaceAll("\"", "&quot;");
                ;
            }
        }
        if (project.getPackaging().equals(FlexMojoUtils.getSWFPackagingType())) {
            if (servicesConfiguration != null && servicesConfiguration.exists()) {
                aca += " -services &quot;" + servicesConfiguration.getAbsolutePath() + "&quot;";
            }
            if (!useNetwork) {
                aca += " -use-network=false";
            }
            if (contextRoot != null && !tokens.isEmpty()) {
                for (FlexCompilationToken token : tokens) {
                    if (!token.getName().equals("context.root")) {
                        aca += " +" + token.getName() + "=" + token.getValue();
                    }
                }
            }
            if (!themes.isEmpty() || !themeDependencies.isEmpty()) {
                aca += " -theme";
                if (!themes.isEmpty()) {
                    aca += getThemeAsString();
                }
                if (!themeDependencies.isEmpty()) {
                    for (ThemeDependency t : themeDependencies) {
                        Iterator<?> deps = project.getArtifacts().iterator();
                        while (deps.hasNext()) {
                            Artifact dependency = (Artifact) deps.next();
                            if (dependency.getType().equals("swc") && dependency.getGroupId().equals(t.getGroupId()) && dependency.getArtifactId().equals(t.getArtifactId())) {
                                try {
                                    aca += " &quot;" + dependency.getFile().getCanonicalFile().toString() + "&quot;";
                                } catch (IOException e) {
                                    throw new MojoExecutionException("Unable to find theme dependency.", e);
                                }
                            }
                        }
                    }
                }
            }
        }
        return aca;
    }

    /**
     * Calculate the project name template from the fields
     * {@link #addVersionToProjectName} and {@link #addGroupIdToProjectName}
     */
    private String calculateProjectNameTemplate() {
        if (getProjectNameTemplate() != null) {
            if (addVersionToProjectName || addGroupIdToProjectName) {
                getLog().warn("projectNameTemplate definition overrides " + "addVersionToProjectName or addGroupIdToProjectName");
            }
            return getProjectNameTemplate();
        } else if (addVersionToProjectName && addGroupIdToProjectName) {
            return PROJECT_NAME_WITH_GROUP_AND_VERSION_TEMPLATE;
        } else if (addVersionToProjectName) {
            return PROJECT_NAME_WITH_VERSION_TEMPLATE;
        } else if (addGroupIdToProjectName) {
            return PROJECT_NAME_WITH_GROUP_TEMPLATE;
        }
        return PROJECT_NAME_DEFAULT_TEMPLATE;
    }

    public static String getProjectName(String template, MavenProject project) {
        return getProjectName(template, project.getGroupId(), project.getArtifactId(), project.getVersion());
    }

    private static String getProjectName(String template, String groupId, String artifactId, String version) {
        String s = template;
        s = s.replaceAll("\\[groupId\\]", groupId);
        s = s.replaceAll("\\[artifactId\\]", artifactId);
        s = s.replaceAll("\\[version\\]", version);
        return s;
    }

    public void logVelocityMessage(int level, String message) {
    }

    public void init(RuntimeServices rs) {
    }

    @Override
    protected String getArtifactExtension() {
        return null;
    }

    @Override
    protected Builder getCompilerInstance() throws Exception {
        return null;
    }
}
