package org.jmlspecs.eclipse.jdt.core.tests.rac;

import java.util.Map;
import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
import org.jmlspecs.jml4.compiler.JmlCompilerOptions;

public class Samples extends RacTestCompiler {

    @Override
    protected Map<String, String> getCompilerOptions() {
        Map<String, String> options = super.getCompilerOptions();
        options.put(CompilerOptions.OPTION_ReportUnnecessaryElse, CompilerOptions.IGNORE);
        options.put(CompilerOptions.OPTION_ReportLocalVariableHiding, CompilerOptions.IGNORE);
        options.put(JmlCompilerOptions.OPTION_ReportNonNullTypeSystem, CompilerOptions.IGNORE);
        options.put(JmlCompilerOptions.OPTION_DefaultNullity, JmlCompilerOptions.NULLABLE);
        options.put(CompilerOptions.OPTION_ReportPotentialNullReference, CompilerOptions.IGNORE);
        options.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.IGNORE);
        options.put(CompilerOptions.OPTION_ReportMissingSerialVersion, CompilerOptions.IGNORE);
        options.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
        options.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);
        options.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.IGNORE);
        return options;
    }

    public Samples(String name) {
        super(name);
    }

    public void test_Account() {
        compile("Account.java", "public class Account {\n" + "  private /*@ spec_public @*/ int bal;\n" + "  //@ public invariant bal >= 0;\n" + "\n" + "  /*@ requires amt >= 0;\n" + "    @ assignable bal;\n" + "    @ ensures bal == amt; @*/\n" + "  public Account(int amt) {\n" + "    bal = amt;\n" + "  }\n" + " \n" + "  /*@ assignable bal;\n" + "    @ ensures bal == acc.bal; @*/\n" + "  public Account(Account acc) {\n" + "    bal = acc.balance();\n" + "  }\n" + "\n" + "  /*@ requires amt > 0; // && amt <= acc.balance();\n" + "    @ assignable bal, acc.bal;\n" + "    @ ensures bal == \\old(bal) + amt\n" + "    @   && acc.bal == \\old(acc.bal - amt); @*/\n" + "  public void transfer(int amt, Account acc) {\n" + "    acc.withdraw(amt);\n" + "    deposit(amt);\n" + "  }\n" + "\n" + "  /*@ requires amt > 0 && amt <= bal;\n" + "    @ assignable bal;\n" + "    @ ensures bal == \\old(bal) - amt; @*/\n" + "  public void withdraw(int amt) {\n" + "    bal -= amt;\n" + "  }\n" + "\n" + "  /*@ requires amt > 0;\n" + "    @ assignable bal;\n" + "    @ ensures bal == \\old(bal) + amt; @*/\n" + "  public void deposit(int amt) {\n" + "    bal += amt;\n" + "  }\n" + "\n" + "  //@ ensures \\result == bal;\n" + "  public /*@ pure @*/ int balance() {\n" + "    return bal;\n" + "  }\n" + "    \n" + "    public static void main(String[] args) {\n" + "        Account acc = new Account(100);\n" + "        acc.withdraw(200);\n" + "        System.out.println(\"Balance after withdrawal: \" + acc.balance());\n" + "    }\n" + "}\n");
    }

    public void test_AlarmClock() {
        compile("Clock.java", "public class Clock {\n" + "  //@ public model long _time;\n" + "  //@ private represents _time = second + minute*60 + hour*60*60;\n" + "\n" + "  //@ public invariant _time == getSecond() + getMinute()*60 + getHour()*60*60;\n" + "  //@ public invariant 0 <= _time && _time < 24*60*60;\n" + "\n" + "  //@ private invariant 0 <= hour && hour <= 23;\n" + "  private int hour; \n" + "  //@ private invariant 0 <= minute && minute <= 59;\n" + "  private int minute; \n" + "  //@ private invariant 0 <= second && second <= 59;\n" + "  private int second; \n" + "\n" + "  //@ ensures _time == 12*60*60;\n" + "  public /*@ pure @*/ Clock() { hour = 12; minute = 0; second = 0; }\n" + "\n" + "  //@ ensures 0 <= \\result && \\result <= 23;\n" + "  public /*@ pure @*/ int getHour() { return hour; }\n" + "\n" + "  //@ ensures 0 <= \\result && \\result <= 59;\n" + "  public /*@ pure @*/ int getMinute() { return minute; }\n" + "\n" + "  //@ ensures 0 <= \\result && \\result <= 59;\n" + "  public /*@ pure @*/ int getSecond() { return second; }\n" + "\n" + "  /*@ requires   0 <= hour && hour <= 23;\n" + "    @ requires   0 <= minute && minute <= 59;\n" + "    @ assignable _time;\n" + "    @ ensures    _time == hour*60*60 + minute*60;\n" + "    @*/\n" + "  public void setTime(int hour, int minute) {\n" + "    this.hour = hour; this.minute = minute; this.second = 0;\n" + "  }\n" + "\n" + "  //@ assignable _time;\n" + "  //@ ensures _time == \\old(_time + 1) % 24*60*60;\n" + "  public void tick() {\n" + "    second++;\n" + "    if (second == 60) { second = 0; minute++; }\n" + "    if (minute == 60) { minute = 0; hour++; }\n" + "    if (hour == 24)   { hour = 0; }\n" + "  }\n" + "}\n" + "interface AlarmInterface {\n" + "  public void on();\n" + "  public void off();\n" + "}\n" + "class AlarmClock extends Clock {\n" + "  //@ public model int _alarmTime;\n" + "  //@ private represents _alarmTime = alarmMinute*60 + alarmHour*60*60;\n" + "\n" + "  //@ public ghost boolean _alarmRinging = false; //@ in _time;\n" + "  \n" + "  //@ private invariant 0 <= alarmHour && alarmHour <= 23;\n" + "  private int alarmHour; //@ in _alarmTime;\n" + "\n" + "  //@ private invariant 0 <= alarmMinute && alarmMinute <= 59;\n" + "  private int alarmMinute; //@ in _alarmTime;\n" + "\n" + "  private /*@ non_null @*/ AlarmInterface alarm;\n" + "\n" + "  public /*@ pure @*/ AlarmClock(/*@ non_null @*/ AlarmInterface alarm) {\n" + "    this.alarm = alarm;\n" + "  }\n" + "\n" + "  /*@ requires   0 <= hour && hour <= 23;\n" + "    @ requires   0 <= minute && minute <= 59;\n" + "    @ assignable _alarmTime;\n" + "    @*/\n" + "  public void setAlarmTime(int hour, int minute) {\n" + "    alarmHour = hour;\n" + "    alarmMinute = minute;\n" + "  }\n" + "\n" + "  // spec inherited from superclass Clock\n" + "  public void tick() {\n" + "    super.tick();\n" + "    if (getHour() == alarmHour & getMinute() == alarmMinute & getSecond() == 0) {\n" + "      alarm.on();\n" + "      //@ set _alarmRinging = true;\n" + "    }\n" + "    if ((getHour() == alarmHour & getMinute() == alarmMinute+1 & getSecond() == 0) ||\n" + "        (getHour() == alarmHour+1 & alarmMinute == 59 & getSecond() == 0) ) {\n" + "      alarm.off();\n" + "      //@ set _alarmRinging = false;\n" + "    }\n" + "  }\n" + "}\n" + "class DigitalDisplayClock{ \n" + "  //@ public model long _time;                                    \n" + "  //@ private represents _time = getSecond()+getMinute()*60+getHour()*60*60; \n" + "\n" + "  //@ protected invariant time.length == 6;\n" + "  //@ protected invariant 0 <= time[0] && time[0] <= 9; // sec\n" + "  //@ protected invariant 0 <= time[1] && time[1] <= 5; // sec\n" + "  //@ protected invariant 0 <= time[2] && time[2] <= 9; // min\n" + "  //@ protected invariant 0 <= time[3] && time[3] <= 5; // min\n" + "  //@ protected invariant 0 <= time[4] && time[4] <= 9; // hr\n" + "  //@ protected invariant 0 <= time[5] && time[5] <= 2; // hr\n" + "  //@ protected invariant time[5] == 2 ==> time[4] <= 3; // hr\n" + "  protected /*@ non_null @*/ int[] time; // NB rep modifier \n" + "  public /*@ pure @*/ DigitalDisplayClock() {\n" + "    time = new int [6]; }   // NB rep modifier\n" + "\n" + "  //@ ensures 0 <= \\result && \\result <= 23;\n" + "  public /*@ pure @*/ int getHour() { return  time[5]*10 + time[4]; }\n" + "\n" + "  //@ ensures 0 <= \\result && \\result <= 59;\n" + "  public /*@ pure @*/ int getMinute() { return time[3]*10 + time[2]; }\n" + "\n" + "  //@ ensures 0 <= \\result && \\result <= 59;\n" + "  public /*@ pure @*/ int getSecond() { return time[1]*10 + time[0]; }\n" + " \n" + "  /*@ requires   0 <= hour && hour <= 23 && 0 <= minute && minute <= 59;\n" + "    @ assignable _time;\n" + "    @ ensures    getHour()==hour && getMinute()==minute && getSecond()==0;\n" + "    @*/\n" + "  public void setTime(int hour, int minute) {\n" + "      time[5] = hour / 10;    time[4] = hour % 10;\n" + "      time[3] = minute % 10;  time[2] = minute % 10;\n" + "      time[1] = 0 ;           time[0] = 0;\n" + "  }\n" + "\n" + "  //@ assignable _time;\n" + "  //@ ensures _time == (\\old(_time)+1) % 24*60*60;\n" + "  public void tick() {\n" + "      time[0]++;\n" + "      if (time[0] == 10) { time[0] = 0; time[1]++; }\n" + "      if (time[1] == 6)  { time[1] = 0; time[2]++; } // minute passed\n" + "      if (time[2] == 10) { time[2] = 0; time[3]++; }\n" + "      if (time[3] == 6)  { time[3] = 0; time[4]++; } // hour passed\n" + "      if (time[4] == 10) { time[4] = 0; time[3]++; }\n" + "      if (time[5] == 2 & time[4] == 4)\n" + "          { time[5] = 0; time[4] = 0; } // day passed\n" + "  }\n" + "}\n");
    }

    public void test_Purse() {
        compile("Purse.java", "class PurseException extends Exception {\n" + "    //@ pure\n" + "    public PurseException(String msg) {\n" + "        super(msg);\n" + "    }\n" + "}\n" + "public class Purse {\n" + "\n" + "    int MAX_BALANCE;\n" + "    int balance;\n" + "    //@ invariant 0 <= balance && balance <= MAX_BALANCE;\n" + "\n" + "    byte[] pin;\n" + "    /*@ invariant pin != null && pin.length == 4\n" + "      @           && (\\forall int i; 0 <= i && i < 4;\n" + "      @                              0 <= pin[i] && pin[i] <= 9);\n" + "      @*/\n" + "       \n" + "    /*@ requires   amount >= 0;\n" + "      @ assignable balance;\n" + "      @ ensures    balance == \\old(balance) - amount\n" + "      @            && \\result == balance;\n" + "      @ signals (PurseException) balance == \\old(balance);\n" + "      @*/\n" + "    int debit(int amount) throws PurseException {\n" + "        if (amount <= balance) { balance -= amount; return balance; }\n" + "        else { throw new PurseException(\"overdrawn by \" + amount); }\n" + "    }\n" + "    \n" + "    /*@ requires   p != null && p.length >= 4;\n" + "      @ assignable \\nothing;\n" + "      @ ensures    \\result <==> (\\forall int i; 0 <= i && i < 4;\n" + "      @                                         pin[i] == p[i]);\n" + "      @*/\n" + "    boolean checkPin(byte[] p) {\n" + "        boolean res = true;\n" + "        for (int i=0; i < 4; i++) { res = res && pin[i] == p[i]; }\n" + "        return res;\n" + "    }\n" + "\n" + "    /*@ requires   0 < mb && 0 <= b && b <= mb\n" + "      @            && p != null && p.length == 4\n" + "      @            && (\\forall int i; 0 <= i && i < 4;\n" + "      @                               0 <= p[i] && p[i] <= 9);\n" + "      @ assignable MAX_BALANCE, balance, pin;\n" + "      @ ensures    MAX_BALANCE == mb && balance == b\n" + "      @            && (\\forall int i; 0 <= i && i < 4; p[i] == pin[i]);\n" + "      @*/\n" + "    Purse(int mb, int b, byte[] p) {\n" + "        MAX_BALANCE = mb; balance = b; pin = (byte[]) p.clone();\n" + "    }\n" + "}\n" + "class Purse2 {\n" + "\n" + "    int MAX_BALANCE;\n" + "    int balance;\n" + "    //@ invariant 0 <= balance && balance <= MAX_BALANCE;\n" + "\n" + "    byte[] pin;\n" + "    /*@ invariant pin != null && pin.length == 4\n" + "      @           && (\\forall int i; 0 <= i && i < 4;\n" + "      @                              0 <= pin[i] && pin[i] <= 9);\n" + "      @*/\n" + "       \n" + "    /*@ requires   amount >= 0;\n" + "      @ assignable balance;\n" + "      @ ensures    balance == \\old(balance) - amount\n" + "      @            && \\result == balance;\n" + "      @ signals (PurseException) balance == \\old(balance);\n" + "      @*/\n" + "    int debit(int amount) throws PurseException {\n" + "        if (amount <= balance) { balance -= amount; return balance; }\n" + "        else { throw new PurseException(\"overdrawn by \" + amount); }\n" + "    }\n" + "    \n" + "    /*@ requires   p != null && p.length >= 4;\n" + "      @ assignable \\nothing;\n" + "      @ ensures    \\result <==> (\\forall int i; 0 <= i && i < 4;\n" + "      @                                         pin[i] == p[i]);\n" + "      @*/\n" + "    boolean checkPin(byte[] p) {\n" + "        boolean res = true;\n" + "        for (int i=0; i < 4; i++) { res = res && pin[i] == p[i]; }\n" + "        return res;\n" + "    }\n" + "\n" + "    /*@ requires   0 < mb && 0 <= b && b <= mb\n" + "      @            && p != null && p.length == 4\n" + "      @            && (\\forall int i; 0 <= i && i < 4;\n" + "      @                               0 <= p[i] && p[i] <= 9);\n" + "      @ assignable MAX_BALANCE, balance, pin;\n" + "      @ ensures    MAX_BALANCE == mb && balance == b\n" + "      @            && (\\forall int i; 0 <= i && i < 4; p[i]==pin[i]);\n" + "      @*/\n" + "    Purse2(int mb, int b, byte[] p) {\n" + "        MAX_BALANCE = mb; balance = b; pin = (byte[])p.clone();\n" + "    }\n" + "\n" + "    public String toString() {\n" + "        return \"Purse(max=\" + MAX_BALANCE + \", bal=\" + balance\n" + "            + \", pin={\" + pin[0] + pin[1] + pin[2] + pin[3] + \"})\";\n" + "    }\n" + "}\n");
    }

    public void test_Digraph() {
        compile("Arc.java", "import java.util.*;\n" + "import java.awt.Color;\n" + "/*@ pure @*/ interface NodeType {\n" + "  \n" + "  /*@ also\n" + "    @   public normal_behavior\n" + "    @       requires !(o instanceof NodeType);\n" + "    @       ensures \\result == false;\n" + "    @*/\n" + "  public boolean equals(/*@ nullable @*/ Object o);\n" + "\n" + "  public int hashCode();\n" + "\n" + "  /*@ also\n" + "    @   public normal_behavior\n" + "    @     ensures \\result instanceof NodeType\n" + "    @          && ((NodeType)\\result).equals(this);\n" + "    @*/\n" + "  public Object clone();\n" + "\n" + "}\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Directed arcs for directed graphs.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " */\n" + "public class Arc implements Cloneable {\n" + "\n" + "    private /*@ spec_public non_null @*/ NodeType source;\n" + "    private /*@ spec_public non_null @*/ NodeType target;\n" + "    \n" + "    //@ private invariant_redundantly source != null && target != null;\n" + "\n" + "    /** Initialize this arc with the given source and target. */\n" + "    /*@ public normal_behavior\n" + "      @   requires_redundantly source != null && target != null;\n" + "      @   assignable this.source, this.target;\n" + "      @   ensures this.source == source\n" + "      @        && this.target == target;\n" + "      @*/\n" + "    public Arc(NodeType source, NodeType target) {\n" + "        this.source = source;\n" + "        this.target = target;\n" + "    }\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     requires o instanceof Arc;\n" + "      @     ensures \\result\n" + "      @             ==> ((Arc)o).source.equals(this.source)\n" + "      @                 && ((Arc)o).target.equals(this.target);\n" + "      @ also\n" + "      @   public normal_behavior\n" + "      @     requires !(o instanceof Arc);\n" + "      @     ensures \\result == false;\n" + "      @*/\n" + "    public /*@ pure @*/ boolean equals(/*@ nullable @*/ Object o) {\n" + "        return (o instanceof Arc) \n" + "            && ((Arc)o).source.equals(source)\n" + "            && ((Arc)o).target.equals(target);\n" + "    }\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     ensures \\result instanceof Arc\n" + "      @         && ((Arc)\\result).equals(this);\n" + "      @*/\n" + "    public /*@ pure @*/ Object clone() {\n" + "        Arc res;\n" + "        try {\n" + "            res = (Arc)super.clone();\n" + "        } catch (CloneNotSupportedException e) {\n" + "            // should not happen\n" + "            throw new InternalError(e.getMessage());\n" + "        }\n" + "	// source and target refs are shared between object and clone\n" + "	// so they do not need to be reassigned\n" + "	//@ assume res.source == source && res.target == target;\n" + "	return res;\n" + "    }\n" + "    \n" + "    public /*@ pure @*/ int hashCode() {\n" + "        return source.hashCode() + target.hashCode();\n" + "    }\n" + "\n" + "    /** Invert the direction of this arc. */\n" + "    /*@ public normal_behavior\n" + "      @   assignable source, target;\n" + "      @   ensures source == \\old(target) && target == \\old(source);\n" + "      @*/\n" + "    public void flip() {\n" + "        NodeType temp = source;\n" + "        source = target;\n" + "        target = temp;\n" + "    }\n" + "\n" + "    /** Get the source node of this arc. */\n" + "    /*@ public normal_behavior\n" + "      @   assignable \\nothing;\n" + "      @   ensures \\result == source;           \n" + "      @*/\n" + "    public /*@ pure @*/ NodeType getSource() {\n" + "        return source;\n" + "    }\n" + "\n" + "    /** Set the source node of this arc to the given node. */\n" + "    /*@ public normal_behavior\n" + "      @   requires_redundantly source != null;\n" + "      @   assignable this.source;\n" + "      @   ensures this.source == source;           \n" + "      @*/\n" + "    public void setSource(NodeType source) {\n" + "        this.source = source;\n" + "    }\n" + "\n" + "    /** Get the target node of this arc. */\n" + "    /*@ public normal_behavior\n" + "      @   assignable \\nothing;\n" + "      @   ensures \\result == target;           \n" + "      @*/\n" + "    public /*@ pure @*/ NodeType getTarget() {\n" + "        return target;\n" + "    }\n" + "\n" + "    /** Set the target node of this arc to the given node. */\n" + "    /*@ public normal_behavior\n" + "      @   requires_redundantly target != null;\n" + "      @   assignable this.target;\n" + "      @   ensures this.target == target;           \n" + "      @*/\n" + "    public void setTarget(NodeType target) {\n" + "        this.target = target;\n" + "    }\n" + "\n" + "    /** Return the name of this class. */\n" + "    //@ ensures \\result != null;\n" + "    protected /*@ pure @*/ String className() {\n" + "        return \"Arc\";\n" + "    }\n" + "\n" + "    public String toString() {\n" + "        return className() + \"[from: \" + source + \", to: \" + target + \"]\";\n" + "    }\n" + "}\n" + "// @(#)$Id: ArcType.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/*@ pure */ class ArcType {\n" + "\n" + "    private NodeType _from;\n" + "\n" + "    private NodeType _to;\n" + "\n" + "    //@ private invariant_redundantly _from != null && _to != null;\n" + "\n" + "    public ArcType(NodeType from, NodeType to) {\n" + "        _from = from;\n" + "        _to = to;\n" + "    }\n" + "\n" + "    public boolean equals(/*@ nullable @*/ Object o) {\n" + "        return o instanceof ArcType\n" + "            && ((ArcType)o)._from.equals(_from)\n" + "            && ((ArcType)o)._to.equals(_to);\n" + "    }\n" + "\n" + "    public int hashCode() {\n" + "        return _from.hashCode() + _to.hashCode();\n" + "    }\n" + "\n" + "    //@ ensures \\result == _from;\n" + "    public NodeType getFrom() {\n" + "        return _from;\n" + "    }\n" + "\n" + "    //@ ensures \\result == _to;\n" + "    public NodeType getTo() {\n" + "        return _to;\n" + "    }\n" + "\n" + "    public Object clone() {\n" + "        return new ArcType(_from, _to);\n" + "    }\n" + "\n" + "    protected String className() {\n" + "        return \"ArcType\";\n" + "    }\n" + "\n" + "    public String toString() {\n" + "        return className() + \"[from: \" + _from + \", to: \" + _to + \"]\";\n" + "    }\n" + "}\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Directed graphs.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " */\n" + "abstract class Digraph {\n" + "\n" + "    protected /*@ spec_public @*/ HashSet nodeSet;\n" + "    protected /*@ spec_public @*/ HashSet arcSet;\n" + "    /*@ private invariant_redundantly nodeSet != null;\n" + "      @ private invariant (\\forall Object e; nodeSet.contains(e); \n" + "      @                       e!=null && e instanceof NodeType);\n" + "      @ \n" + "      @ private invariant_redundantly arcSet != null;\n" + "      @ private invariant (\\forall Object e; arcSet.contains(e); \n" + "      @                       e!=null && e instanceof Arc);\n" + "      @*/\n" + "\n" + "    public Digraph() {\n" + "        nodeSet = new HashSet();\n" + "        arcSet = new HashSet();\n" + "    }\n" + "\n" + "    public void addNode(NodeType n) {\n" + "        nodeSet.add(n);\n" + "    }\n" + "\n" + "    public void removeNode(NodeType n) {\n" + "        nodeSet.remove(n);\n" + "    }\n" + "\n" + "    public void addArc(NodeType inFrom, NodeType inTo) {\n" + "        arcSet.add(new Arc(inFrom, inTo));\n" + "    }\n" + "\n" + "    public void removeArc(NodeType inFrom, NodeType inTo) {\n" + "        arcSet.remove(new Arc(inFrom, inTo));\n" + "    }\n" + "\n" + "    /*@ also \n" + "      @  public normal_behavior\n" + "      @    ensures \\result == nodeSet.contains(n);\n" + "      @*/\n" + "    public /*@ pure @*/ boolean isNode(NodeType n) {\n" + "        return nodeSet.contains(n);\n" + "    }\n" + "\n" + "    public /*@ pure @*/ boolean isArc(NodeType inFrom, NodeType inTo) {\n" + "        return arcSet.contains(new Arc(inFrom, inTo));\n" + "    }\n" + "\n" + "    public /*@ pure @*/ boolean isAPath(NodeType start, NodeType end) {\n" + "        return reachSet(start).contains(end);\n" + "    }\n" + "\n" + "    protected /*@ pure @*/ HashSet reachSet(NodeType start) {\n" + "        HashSet disc = new HashSet(); // discovered vertices\n" + "        Iterator arcs = arcSet.iterator();\n" + "        while (arcs.hasNext()) {\n" + "            Arc next = (Arc) arcs.next();\n" + "            if (next.getSource() == start && !disc.contains(next.getTarget())) {\n" + "                disc.add(next.getTarget());\n" + "                reachSet(next.getTarget());\n" + "            }\n" + "        }\n" + "\n" + "        return disc;\n" + "    }\n" + "    public String toString() {\n" + "        return \"[arcs: \" + arcSet.toString()\n" + "               + \"\\n nodes: \" + nodeSet.toString() + \"]\";\n" + "    }\n" + "\n" + "    public /*@ pure @*/ boolean unconnected(NodeType n) {\n" + "        Iterator arcIter = arcSet.iterator();\n" + "        while (arcIter.hasNext()) {\n" + "            Arc a = (Arc) arcIter.next();\n" + "            if (a.getSource().equals(n) || a.getTarget().equals(n)) {\n" + "                return false;\n" + "            }\n" + "        }\n" + "        return true;\n" + "    }\n" + "}\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Transposable directed graphs.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " */\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class TransposableDigraph extends Digraph {\n" + "\n" + "    protected /*@ spec_public @*/ HashSet nodes;\n" + "    protected /*@ spec_public @*/ HashSet arcs;\n" + "    /** Initialize this transposable digraph to be empty. */\n" + "    /*@  public normal_behavior\n" + "      @   assignable nodes, arcs;\n" + "      @*/\n" + "    public TransposableDigraph() {\n" + "        super();\n" + "    }\n" + "\n" + "    /** Transpose this graph by inverting the direction of all its edges. */\n" + "    /*@ public normal_behavior\n" + "      @  assignable arcs;\n" + "      @  ensures nodes.equals(\\old(nodes));\n" + "      @*/\n" + "    public void transpose() {\n" + "        Iterator arciter = arcSet.iterator();\n" + "        while (arciter.hasNext()) {\n" + "            Arc a = (Arc) arciter.next();\n" + "            a.flip();\n" + "        }\n" + "    }\n" + "\n" + "}\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "/** Nodes with values\n" + " * @author Gary T. Leavens\n" + " * @author Katie Becker\n" + " */\n" + "abstract class ValueNode implements NodeType, Cloneable {\n" + "\n" + "    protected /*@ spec_public nullable @*/ Object value;\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     requires o instanceof ValueNode;\n" + "      @ also\n" + "      @   public normal_behavior\n" + "      @     requires !(o instanceof ValueNode);\n" + "      @     ensures \\result == false;\n" + "      @*/\n" + "    public boolean equals(/*@ nullable @*/ Object o) {\n" + "        if (!(o instanceof ValueNode)) { \n" + "            return false;\n" + "        } else if (value == null) {\n" + "            return ((ValueNode) o).getValue() == null;\n" + "        } else {\n" + "            return value.equals(((ValueNode) o).getValue());\n" + "        }\n" + "    }\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     ensures \\result instanceof ValueNode && \\fresh(\\result)\n" + "      @          && ((ValueNode)\\result).equals(this);\n" + "      @     ensures_redundantly \\result != this;\n" + "      @*/\n" + "    public /*@ pure @*/ /*@ non_null @*/ Object clone() {\n" + "        ValueNode res;\n" + "        try {\n" + "            res = (ValueNode)super.clone();\n" + "        } catch (CloneNotSupportedException e) {\n" + "            // should not happen\n" + "            throw new InternalError(e.getMessage());\n" + "        }\n" + "	return res;\n" + "    }\n" + "\n" + "    /*@ public normal_behavior\n" + "      @   assignable this.value;\n" + "      @   ensures this.value == value;\n" + "      @*/\n" + "    public void setValue(/*@ nullable @*/ Object value) {\n" + "        this.value = value;\n" + "    }\n" + "\n" + "    /*@ public normal_behavior\n" + "      @   ensures \\result == value;\n" + "      @*/\n" + "    public /*@ pure nullable @*/ Object getValue() {\n" + "        return value;\n" + "    }\n" + "  \n" + "    public int hashCode() {\n" + "        if (value == null) {\n" + "            return 0;\n" + "        } else {\n" + "            return value.hashCode();\n" + "        }\n" + "    }\n" + "  \n" + "    protected abstract /*@ pure @*/ String className();\n" + "\n" + "    public /*@ non_null @*/ String toString(){\n" + "        return className() + \"(\" + value + \")\";     \n" + "    }\n" + "}\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Nodes for searchable graphs.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " */\n" + "class SearchableNode extends ValueNode {\n" + "\n" + "    private /*@ spec_public @*/ int discoverTime;\n" + "    private /*@ spec_public @*/ int finishTime;\n" + "    private /*@ spec_public nullable @*/ SearchableNode predecessor;\n" + "    private /*@ spec_public nullable @*/ Color color;\n" + "\n" + "    /*@ public normal_behavior\n" + "      @   assignable value;\n" + "      @   ensures value == v;            \n" + "      @*/\n" + "    public SearchableNode(/*@ nullable @*/ Object v) {\n" + "        value = v;\n" + "    }\n" + "\n" + "    /*@ protected normal_behavior\n" + "      @   assignable value, discoverTime, finishTime, predecessor, color;\n" + "      @   ensures value == v && discoverTime == dT && finishTime == fT\n" + "      @                     && predecessor == pred;           \n" + "      @*/\n" + "    protected SearchableNode(/*@ nullable @*/ Object v, int dT, int fT, \n" + "			     /*@ nullable @*/ SearchableNode pred,\n" + "                             /*@ nullable @*/ Color c)\n" + "    {\n" + "        value = v;\n" + "        discoverTime = dT;\n" + "        finishTime = fT;\n" + "        predecessor = pred;\n" + "        color = c;\n" + "    }\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     requires o instanceof SearchableNode;\n" + "      @     ensures discoverTime == ((SearchableNode) o).discoverTime\n" + "      @          && finishTime == ((SearchableNode) o).finishTime;\n" + "      @ also\n" + "      @   public normal_behavior\n" + "      @     requires !(o instanceof SearchableNode);\n" + "      @     ensures \\result == false;\n" + "      @*/\n" + "    public boolean equals(/*@ nullable @*/ Object o) {\n" + "        if (!(o instanceof SearchableNode)) {\n" + "            return false;\n" + "        }\n" + "\n" + "        SearchableNode sn = (SearchableNode) o;\n" + "        return super.equals(o)\n" + "            && discoverTime == sn.discoverTime\n" + "            && finishTime == sn.finishTime\n" + "            && (((predecessor == null && sn.predecessor == null))\n" + "                || (predecessor != null \n" + "                    && predecessor.equals(sn.predecessor)))\n" + "            && (((color == null && sn.color == null))\n" + "                || (color != null && color.equals(sn.color)));\n" + "    }\n" + "\n" + "    // specification and comment inherited\n" + "    public int hashCode() {\n" + "        return super.hashCode() + discoverTime + finishTime;\n" + "    }\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     ensures \\result instanceof SearchableNode && \\fresh(\\result)\n" + "      @          && ((SearchableNode)\\result).equals(this);\n" + "      @     ensures_redundantly \\result != this;\n" + "      @*/\n" + "    public Object clone() {\n" + "        return super.clone();\n" + "    }\n" + "\n" + "    /*@ protected normal_behavior\n" + "      @   assignable color;\n" + "      @   ensures color.equals(c);           \n" + "      @*/\n" + "    protected void setColor(/*@ nullable @*/ Color c) {\n" + "        this.color = c;\n" + "    }\n" + "\n" + "    /*@ public normal_behavior\n" + "      @   assignable \\nothing;\n" + "      @   ensures \\result != null ==> \\result.equals(color);           \n" + "      @*/\n" + "    public /*@ pure nullable @*/ Color getColor() {\n" + "        return color;\n" + "    }\n" + "\n" + "    /*@ protected normal_behavior\n" + "      @   assignable predecessor;\n" + "      @   ensures predecessor == p;           \n" + "      @*/\n" + "    protected void setPredecessor(/*@ nullable @*/ SearchableNode p) {\n" + "        this.predecessor = p;\n" + "    }\n" + "\n" + "    /*@ public normal_behavior\n" + "      @   assignable \\nothing;\n" + "      @   ensures \\result == predecessor;           \n" + "      @*/\n" + "    public /*@ pure nullable @*/ SearchableNode getPredecessor() {\n" + "        return predecessor;\n" + "    }\n" + "\n" + "    /*@ protected normal_behavior\n" + "      @   assignable finishTime;\n" + "      @   ensures finishTime == fTime;           \n" + "      @*/\n" + "    protected void setFinishTime(int fTime) {\n" + "        this.finishTime = fTime;\n" + "    }\n" + "\n" + "    /*@ public normal_behavior\n" + "      @   assignable \\nothing;\n" + "      @   ensures \\result == finishTime;           \n" + "      @*/\n" + "    public /*@ pure @*/ int getFinishTime() {\n" + "        return finishTime;\n" + "    }\n" + "\n" + "    /*@ protected normal_behavior\n" + "      @   assignable discoverTime;\n" + "      @   ensures discoverTime == dTime;           \n" + "      @*/\n" + "    protected void setDiscoverTime(int dTime) {\n" + "        this.discoverTime = dTime;\n" + "    }\n" + "\n" + "    /*@ public normal_behavior\n" + "      @   assignable \\nothing;\n" + "      @   ensures \\result == discoverTime;           \n" + "      @*/\n" + "    public /*@ pure @*/ int getDiscoverTime() {\n" + "        return discoverTime;\n" + "    }\n" + "\n" + "    protected /*@ non_null @*/ String className() {\n" + "        return \"SearchableNode\";\n" + "    }\n" + "\n" + "    public /*@ non_null @*/ String toString() {\n" + "        return super.toString() + \"[\"\n" + "            + (discoverTime == 0 ? \"\" : \"discoverTime: \" + discoverTime)\n" + "            + (finishTime == 0 ? \"\" : \" finishTime: \" + finishTime)\n" + "            + (predecessor == null ? \"\" : \" predecessor: \" + predecessor)\n" + "            + (color == null ? \"\" : \" color: \" + color)\n" + "            + \"]\";\n" + "    }\n" + "}\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Directed graphs that are searchable.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " */\n" + "class SearchableDigraph extends TransposableDigraph {\n" + "\n" + "    private /*@ spec_public @*/ int time; // for DFS and DFSVisit\n" + "\n" + "    /** Initialize this searchable digraph to be empty. */\n" + "    /*@  public normal_behavior\n" + "      @   assignable nodes, arcs;\n" + "      @*/\n" + "    public SearchableDigraph() {\n" + "        super();\n" + "    }\n" + "  \n" + "    /* // !FIXME! -- write this in code\n" + "       public SearchableDigraph StronglyConnectedComponents() {\n" + "       DFS();\n" + "       SearchableDigraph trans = (SearchableDigraph) transpose();\n" + "       // do trans.DFS(); in decreasing order of finishing times.\n" + "       // add the vertices in the depthFirst forest formed by \n" + "       //    trans.DFS() as a separate strongly connected componenet\n" + "       //    to the resulting graph by calling reachSet() on the vertices\n" + "       // add the appropriate arcs\n" + "       return trans;\n" + "       }\n" + "    */\n" + "\n" + "    /*@ public normal_behavior\n" + "      @  assignable time, arcs, nodes;\n" + "      @  // !FIXME! complete this specification.\n" + "      @*/\n" + "    public void DFS() {\n" + "        Iterator nodes = nodeSet.iterator();\n" + "        while (nodes.hasNext()) {\n" + "            SearchableNode next = (SearchableNode) nodes.next();\n" + "            next.setColor(Color.WHITE);\n" + "            next.setPredecessor(null);\n" + "        }\n" + "        time = 0;\n" + "        while (nodes.hasNext()) {\n" + "            SearchableNode next = (SearchableNode) nodes.next();\n" + "            if (next.getColor() == Color.WHITE) {\n" + "                DFSVisit(next);\n" + "            }\n" + "        }\n" + "    }\n" + "\n" + "    /*@ public normal_behavior\n" + "      @  requires u != null && u.color != null && u.color == Color.WHITE;\n" + "      @  assignable time, arcs, u.discoverTime, u.color,\n" + "      @             u.predecessor, u.finishTime;\n" + "      @  ensures u.color == Color.BLACK && u.discoverTime == \\old(time + 1)\n" + "      @       && time > \\old(time); // !FIXME! complete this specification.\n" + "      @*/\n" + "    public void DFSVisit(SearchableNode u) {\n" + "        u.setColor(Color.GRAY);\n" + "        time++;\n" + "        u.setDiscoverTime(time);\n" + "        Iterator arcs = arcSet.iterator();\n" + "        while (arcs.hasNext()) {\n" + "            Arc next = (Arc) arcs.next();\n" + "            if (next.getSource() == u) {\n" + "                if (((SearchableNode) next.getTarget()).getColor()\n" + "                    == Color.WHITE) {\n" + "                        ((SearchableNode) next.getTarget())\n" + "                            .setPredecessor((SearchableNode) next.getSource());\n" + "                    DFSVisit((SearchableNode) next.getTarget());\n" + "                }\n" + "            }\n" + "        }\n" + "        u.setColor(Color.BLACK);\n" + "        u.setFinishTime(time);\n" + "        time++;\n" + "    }\n" + "}\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Nodes for transposable directed graphs.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " */\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class TransposableNode extends ValueNode {\n" + "\n" + "    /*@ public normal_behavior\n" + "      @   assignable value;\n" + "      @   ensures value == v;            \n" + "      @*/\n" + "    public TransposableNode(Object v) {\n" + "        setValue(v);\n" + "    }\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     requires o instanceof TransposableNode;\n" + "      @ also\n" + "      @   public normal_behavior\n" + "      @     requires !(o instanceof TransposableNode);\n" + "      @     ensures \\result == false;\n" + "      @*/\n" + "    public boolean equals(/*@ nullable @*/ Object o) {\n" + "        return (o instanceof TransposableNode)\n" + "            && super.equals(o);\n" + "    }\n" + "\n" + "    protected /*@ pure non_null @*/ String className() {\n" + "        return \"TransposableNode\";\n" + "    }\n" + "}\n");
    }

    public void test_DirObserver() {
        compile("DirObserver.java", "import java.util.*;\n" + "// @(#)$Id: DirObserver.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2001 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Observers (i.e. listeners) in the directory system. */\n" + "public interface DirObserver {\n" + "\n" + "    /** The state of this observer. */\n" + "    //@ public model instance HashSet obsState;\n" + "\n" + "    /** Receive a notification that a given name is being added\n" + "     *  to the given directory.\n" + "     */ \n" + "    /*@ public normal_behavior\n" + "      @   requires o != null && o.in_notifier && n != null && !n.equals(\"\");\n" + "      @   assignable obsState;\n" + "      @   ensures o.equals(\\old(o));\n" + "      @*/\n" + "    void addNotification(Directory o, String n);\n" + "\n" + "    /** Receive a notification that a given name is being removed\n" + "     *  from the given directory.\n" + "     */ \n" + "    /*@ public normal_behavior\n" + "      @   requires o != null && o.in_notifier && n != null && !n.equals(\"\");\n" + "      @   assignable obsState;\n" + "      @   ensures o.equals(\\old(o));\n" + "      @*/\n" + "    void removeNotification(Directory o, String n);\n" + "}\n" + "// @(#)$Id: Directory.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2001 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Directories that can be both read and written. */\n" + "interface Directory extends RODirectory {\n" + "\n" + "  /** Add a mapping from the given string \n" + "   *  to the given file to this directory.\n" + "   */\n" + "  public void addEntry(String n, File f);\n" + "\n" + "  /** Remove the entry with the given name from this directory. */\n" + "  public void removeEntry(String n);\n" + "}\n" + "// @(#)$Id: DirObserverKeeper.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2001 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** An object that keeps directory observers (i.e., a subject). */\n" + "interface DirObserverKeeper {\n" + "    \n" + "    /** Is a notification callback running? */\n" + "    /*@ public ghost instance boolean in_notifier;\n" + "      @ public initially !in_notifier;\n" + "      @*/\n" + "\n" + "    /** The set of observers. */\n" + "    /*@ public model instance HashSet listeners;\n" + "      @ public instance invariant listeners != null;\n" + "      @*/\n" + "\n" + "    /** Is a notifier callback running? */\n" + "    /*@ public normal_behavior\n" + "      @   assignable \\nothing;\n" + "      @   ensures \\result == in_notifier;\n" + "      @*/\n" + "    /*@ pure @*/ boolean inNotifier();\n" + "\n" + "    /** Add a listener to the set of listeners. */\n" + "    /*@ public normal_behavior\n" + "      @   requires o != null;\n" + "      @   assignable listeners;\n" + "      @   ensures listeners.equals(\\old(listeners));\n" + "      @*/\n" + "    void register(DirObserver o);\n" + "\n" + "    /** Take a listener out of the set of listeners. */\n" + "    /*@ public normal_behavior\n" + "      @   requires o != null;\n" + "      @   assignable listeners;\n" + "      @   ensures listeners.equals(\\old(listeners.remove(o)));\n" + "      @*/\n" + "    void unregister(DirObserver o);\n" + "}\n" + "// @(#)$Id: RODirectory.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2001 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Read-only directories. */\n" + "interface RODirectory extends DirObserverKeeper {\n" + "    /** Return the file with the given name in this directory. */\n" + "    /*@ public normal_behavior\n" + "      @      assignable \\nothing;\n" + "      @      ensures \\result == null;\n" + "      @*/\n" + "    public File thisFile(String n);\n" + "\n" + "    /*@ also\n" + "      @  public normal_behavior\n" + "      @  {|\n" + "      @     requires !(oth instanceof RODirectory);\n" + "      @     ensures \\result == false;\n" + "      @   also\n" + "      @     requires oth instanceof RODirectory;\n" + "      @     ensures \\result ==\n" + "      @        ( listeners.equals(((RODirectory)oth).listeners));\n" + "      @  |}\n" + "      @*/\n" + "    public /*@ pure @*/ boolean equals(/*@ nullable @*/ Object oth);\n" + "}\n" + "// @(#)$Id: File.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2001 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** A simplified file class for purposes of this example. */\n" + "class File {\n" + "\n" + "    public /*@ pure @*/ boolean equals(/*@ nullable @*/ Object o) {\n" + "        if (o == null || !(o instanceof File)) {\n" + "            return false;\n" + "        }\n" + "        return true; // this is a stub only...\n" + "    }\n" + "}\n");
    }

    public void test_PriorityQueue() {
        if (testIsDisabled("Need to fix nullities and generics")) return;
        compile("QueueEntry.java", "// @(#)$Id: QueueEntry.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "public /*@ pure @*/ class QueueEntry {\n" + "\n" + "    public /*@ non_null @*/ Object _obj;\n" + "    public int _priorityLevel;\n" + "    public long _timeStamp;\n" + "\n" + "    /*@ private invariant_redundantly\n" + "      @    _priorityLevel >= 0 && _timeStamp >= 0L;\n" + "      @*/\n" + "\n" + "    public QueueEntry(Object argObj, int argLevel,\n" + "                      long argTimeStamp) {\n" + "        _obj = argObj;\n" + "        _priorityLevel = argLevel;\n" + "        _timeStamp = argTimeStamp;\n" + "    }\n" + "\n" + "    public boolean equals(/*@ nullable @*/ Object o) {\n" + "        if (!(o instanceof QueueEntry)) {\n" + "            return false;\n" + "        }\n" + "\n" + "        QueueEntry qe = (QueueEntry)o;\n" + "        return qe._obj == _obj\n" + "            && qe._priorityLevel == _priorityLevel\n" + "            && qe._timeStamp == _timeStamp;\n" + "    }\n" + "\n" + "    public /*@ pure @*/ int hashCode() {\n" + "        return _obj.hashCode();\n" + "    }\n" + "\n" + "    public Object clone() {\n" + "        try {\n" + "            return super.clone();\n" + "        } catch (CloneNotSupportedException e) {\n" + "            // should not happen\n" + "            throw new InternalError(e.getMessage());\n" + "        }\n" + "    }\n" + "\n" + "    public /*@ pure @*/ int getLevel() {\n" + "        return _priorityLevel;\n" + "    }\n" + "\n" + "    public /*@ pure @*/ Object getObj() {\n" + "        return _obj;\n" + "    }\n" + "\n" + "    public String toString() {\n" + "        return \"[obj: \" + _obj.toString()\n" + "            + \", priorityLevel: \" + _priorityLevel\n" + "            + \", timeStamp: \" + _timeStamp\n" + "            + \"]\";\n" + "    }\n" + "}\n" + "// @(#)$Id: PQException.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "class PQException extends RuntimeException {\n" + "  public PQException() { super(); }\n" + "  public PQException(String s) { super(s); }\n" + "}\n" + "// @(#)$Id: PriorityQueueUser.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "interface PriorityQueueUser {\n" + "\n" + " /*@ also\n" + "   @   public normal_behavior\n" + "   @     ensures \\result <==>\n" + "   @       (\\exists QueueEntry e; e != null;\n" + "   @                              e._obj == argObj);\n" + "   @*/\n" + " /*@ pure @*/ boolean contains(Object argObj);\n" + "\n" + " /*@ also\n" + "   @   public normal_behavior\n" + "   @     requires true;\n" + "   @     ensures\n" + "   @       (\\exists QueueEntry r;\n" + "   @           \\result == r._obj;\n" + "   @           (\\forall QueueEntry o;\n" + "   @              !(r.equals(o));\n" + "   @               r._priorityLevel >= o._priorityLevel\n" + "   @               && (r._priorityLevel == o._priorityLevel\n" + "   @                   ==> r._timeStamp < o._timeStamp) ) );\n" + "   @ also\n" + "   @   public exceptional_behavior\n" + "   @     requires true;\n" + "   @     signals_only PQException;\n" + "   @*/\n" + " /*@ pure @*/ Object next() throws PQException;\n" + "\n" + " /*@ also\n" + "   @   public normal_behavior\n" + "   @     requires true;\n" + "   @     ensures (\\exists QueueEntry e;\n" + "   @         e._obj == argObj;\n" + "   @         true);\n" + "   @ also\n" + "   @   public normal_behavior\n" + "   @     requires !true;\n" + "   @     assignable \\nothing;\n" + "   @     ensures \\not_modified(entries);\n" + "   @*/\n" + " void remove(Object argObj);\n" + "\n" + " /*@ also\n" + "   @   public normal_behavior\n" + "   @     ensures \\result <==> true;\n" + "   @*/\n" + " /*@ pure @*/ boolean isEmpty();\n" + "}\n");
    }

    public void _test_DLList() {
        compile("DLList.java", "// @(#) $Id: SLNode.java 1199 2009-02-17 1f9:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class SLNode { // Singly Linked Node\n" + "\n" + "    // data members\n" + "\n" + "    protected Object entry_;\n" + "    protected SLNode nextNode_;\n" + "\n" + "    // methods\n" + "\n" + "    public SLNode(Object ent) {\n" + "	entry_ = ent;\n" + "	nextNode_ = null;\n" + "    }\n" + "    public /*@ pure @*/ Object getEntry() {\n" + "	return entry_;\n" + "    }\n" + "    public void setEntry(Object newEntry) {\n" + "	entry_ = newEntry;\n" + "    }\n" + "    public /*@ pure @*/ SLNode getNextNode() {\n" + "	return nextNode_;\n" + "    }\n" + "    public void insertAfter(Object newEntry) {\n" + "	nextNode_ = new SLNode(newEntry, nextNode_);\n" + "    }\n" + "    public void removeNextNode() {\n" + "	if (nextNode_ != null) {\n" + "	    nextNode_ = nextNode_.getNextNode();\n" + "	}\n" + "    }\n" + "    public /*@ non_null @*/ Object clone() {\n" + "	if (nextNode_ == null) {\n" + "	    return new SLNode(getEntry());\n" + "	} else {\n" + "	    return new SLNode(getEntry(), (SLNode)nextNode_.clone());\n" + "	}\n" + "    }\n" + "    public /*@ pure non_null @*/ String toString() {\n" + "	return getEntry() + \", \" + stringOfEntries(getNextNode());\n" + "    }\n" + "\n" + "    /** Returns the string concatentation of all nodes following this node up\n" + "     * to and excluding the end of the chain or this, which ever is reached\n" + "     * first (i.e. this method will terminate even for circular lists).\n" + "     */\n" + "    protected /*@ pure @*/ String stringOfEntries(SLNode curr) {\n" + "	if (curr == null) {\n" + "	    return \"\";\n" + "	}\n" + "	// Get string representation of entry. (Note the following works even\n" + "	// if the entry is null.)\n" + "	String entryAsString = curr.getEntry() + \"\";\n" + "\n" + "	if (curr.getNextNode() == null\n" + "	    // the following disjunct prevents infinite recursion\n" + "	    || curr.getNextNode() == this) {\n" + "	    return entryAsString;\n" + "	}\n" + "	return entryAsString + \", \" + stringOfEntries(curr.getNextNode());\n" + "    }\n" + "    protected SLNode() {\n" + "	entry_ = null;\n" + "	nextNode_ = null;\n" + "    }\n" + "    protected SLNode(Object ent, SLNode nxtNode) {\n" + "	entry_ = ent;\n" + "	nextNode_ = nxtNode;\n" + "    }\n" + "}\n" + "\n" + "// @(#) $Id: DLNode.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class DLNode extends SLNode { // Doubly Linked Node\n" + "\n" + "    // data members\n" + "\n" + "    protected DLNode prevNode_;\n" + "\n" + "    public DLNode(Object ent) {\n" + "	super(ent);\n" + "	prevNode_ = null;\n" + "    }\n" + "\n" + "    public void insertAfter(Object newEntry) {\n" + "	nextNode_ = new DLNode(newEntry, this, (DLNode)nextNode_);\n" + "    }\n" + "    public void removeNextNode() {\n" + "	if (nextNode_ != null) {\n" + "	    DLNode nextNext = (DLNode) nextNode_.getNextNode();\n" + "\n" + "	    // remove the current links\n" + "	    // the next two lines are needed in case nextNode_ is aliased\n" + "	    ((DLNode)nextNode_).linkTo(null);\n" + "\n" + "	    this.linkTo(nextNext);\n" + "	}\n" + "    }\n" + "    public /*@ pure @*/ DLNode getPrevNode() {\n" + "	return prevNode_;\n" + "    }\n" + "    public void insertBefore(Object newEntry) {\n" + "	if (prevNode_ != null) {\n" + "	    prevNode_.insertAfter(newEntry);\n" + "	} else {\n" + "	    prevNode_ = new DLNode(newEntry, null, this);\n" + "	}\n" + "    }\n" + "    public /*@ non_null @*/ Object clone() {\n" + "	if (nextNode_ == null) {\n" + "	    if (prevNode_ == null) {\n" + "		return new DLNode(getEntry());\n" + "	    } else {\n" + "		return new DLNode(getEntry(), prevNode_.clonePrevious(), null);\n" + "	    }\n" + "	} else {\n" + "	    if (prevNode_ == null) {\n" + "		return new DLNode(getEntry(), null, \n" + "				  ((DLNode)nextNode_).cloneNext());\n" + "	    } else {\n" + "		return new DLNode(getEntry(), \n" + "				  prevNode_.clonePrevious(), \n" + "				  ((DLNode)nextNode_).cloneNext());\n" + "	    }\n" + "	}\n" + "    }\n" + "    protected DLNode cloneNext() {\n" + "	if (nextNode_ == null) {\n" + "	    return new DLNode(getEntry());\n" + "	} else {\n" + "	    return new DLNode(getEntry(), null, \n" + "			      ((DLNode)nextNode_).cloneNext());\n" + "	}\n" + "    }\n" + "    protected DLNode clonePrevious() {\n" + "	if (prevNode_ == null) {\n" + "	    return new DLNode(getEntry());\n" + "	} else {\n" + "	    return new DLNode(getEntry(), prevNode_.clonePrevious(), null);\n" + "	}\n" + "    }\n" + "    protected void linkTo(DLNode nxtNode) {\n" + "	if (nextNode_ != null) { // needed in case nextNode_ is aliased\n" + "	    ((DLNode)nextNode_).prevNode_ = null;\n" + "	}\n" + "	if (nxtNode != null) {\n" + "	    nxtNode.prevNode_ = this;\n" + "	}\n" + "	this.nextNode_ = nxtNode;\n" + "    }\n" + "    protected DLNode(Object ent, DLNode prvNode, DLNode nxtNode) {\n" + "	this(ent);\n" + "	if (prvNode != null) {\n" + "	    prvNode.linkTo(this);\n" + "	}\n" + "	if (nxtNode != null) {\n" + "	    this.linkTo(nxtNode);\n" + "	}\n" + "    }\n" + "}\n" + "// @(#) $Id: SLList.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class SLList { // Singly Linked List\n" + "\n" + "    // data members\n" + "\n" + "    protected /*@non_null*/ SLNode theListNode_;\n" + "\n" + "    // used for inserting and iteration through the List \n" + "    protected SLNode cursorNode_;\n" + "\n" + "    public SLList() {\n" + "	theListNode_ = new SLNode(null);\n" + "	cursorNode_ = null;\n" + "    }\n" + "\n" + "    // iteration methods\n" + "    // -----------------\n" + "\n" + "    public void firstEntry() {\n" + "	// The first node is a sentinel so the first entry is in the 2nd node\n" + "	cursorNode_ = theListNode_.getNextNode();\n" + "    }\n" + "    public void incrementCursor() {\n" + "	if (isOffEnd()) {\n" + "	    // System.err.println(\"Error in `SLList.incrementCursor()': No more List entries\"\n" + "	    //	       + \"List is \" + this.toString() );\n" + "	    throw new IllegalStateException(\"Error in `SLList.OneWayList.incrementCursor()': No more List entries\\n\"\n" + "					    + \"List is \" + this.toString() );\n" + "	}\n" + "	cursorNode_ = cursorNode_.getNextNode();\n" + "    }\n" + "    public /*@ pure @*/ boolean isOffFront() {\n" + "	return cursorNode_ == theListNode_;\n" + "    }\n" + "    public /*@ pure @*/ boolean isOffEnd() {\n" + "	return cursorNode_ == null;\n" + "    }\n" + "    public /*@ pure @*/ Object getEntry() {\n" + "	if (isOffEnd() || isOffFront()) {\n" + "	    // The following line is not pure\n" + "	    //System.err.println(\"Error in `SLList.getEntry': cursorNode_ is invalid\");\n" + "	    throw new IllegalStateException(\"Error in `SLList.getEntry': cursorNode_ is invalid\");\n" + "	}\n" + "	return cursorNode_.getEntry();\n" + "    }\n" + "\n" + "    // methods for changing the list\n" + "    // -----------------------------\n" + "    public void removeEntry() {\n" + "	if (isOffEnd() || isOffFront()) {\n" + "	    // System.err.println(\"Error in `SLList.removeEntry': cursorNode_ is invalid\");\n" + "	    // System.err.println(\"List is \" + this.toString());\n" + "	    throw new IllegalStateException(\"Error in `SLList.removeEntry':\"\n" + "					    + \"cursorNode_ is invalid\\n\"\n" + "					    + \"List is \" + this.toString());\n" + "	}\n" + "\n" + "	// link the previous node to the next node\n" + "	decreaseCursor();\n" + "	cursorNode_.removeNextNode();\n" + "    }\n" + "    public void replaceEntry(Object newEntry) {\n" + "	cursorNode_.setEntry(newEntry);\n" + "    }\n" + "    public void insertAfterCursor(Object newEntry) {\n" + "	if (isOffEnd()) {\n" + "	    // System.err.println(\"Error in `SLList.insertAfterCursor': cursorNode_ is invalid\");\n" + "	    // System.err.println(\"Attempting to insert \" + newEntry);\n" + "	    // System.err.println(\"into list \" + this.toString());\n" + "	    throw new IllegalStateException(\"Error in `SLList.insertAfterCursor':\"\n" + "					    + \" cursorNode_ is invalid\\n\"\n" + "					    + \"Attempting to insert \" \n" + "					    + newEntry \n" + "					    + \"into list \" + this.toString() );\n" + "	}\n" + "\n" + "	// creat a new Node containing newEntry and insert after cursor\n" + "	cursorNode_.insertAfter(newEntry);\n" + "    }\n" + "    public void insertBeforeCursor(Object newEntry) {\n" + "	if (isOffFront()) {\n" + "	    // System.err.println(\"Error in `SLList.insertBeforeCursor': cursorNode_ is invalid\");\n" + "	    // System.err.println(\"Attempting to insert \" + newEntry);\n" + "	    // System.err.println(\"into list \" + this.toString());\n" + "	    throw new IllegalStateException(\"Error in `SLList.insertBeforeCursor':\"\n" + "					    + \" cursorNode_ is invalid\\n\"\n" + "					    + \"Attempting to insert \" \n" + "					    + newEntry \n" + "					    + \"into list \" + this.toString() );\n" + "	}\n" + "\n" + "	decreaseCursor();\n" + "\n" + "	// link previous Node to new Node\n" + "	insertAfterCursor(newEntry);\n" + "\n" + "	// move the cursor forward to the original Node\n" + "	incrementCursor();\n" + "	incrementCursor();\n" + "    }\n" + "    public /*@ non_null @*/ Object clone() {\n" + "	SLList result = new SLList( theListNode_ );\n" + "	return result;\n" + "    }\n" + "    public /*@ non_null @*/ String toString() {\n" + "	String str = \"<\";\n" + "	SLNode curr = theListNode_.getNextNode();\n" + "	while (curr != cursorNode_ && curr != null) {\n" + "	    str = str + curr.getEntry();\n" + "	    curr = curr.getNextNode();\n" + "	    if (curr != null && curr.getNextNode() != null) {\n" + "		str += \", \";\n" + "	    }\n" + "	}\n" + "	str += \" || \";\n" + "	while (curr != null) {\n" + "	    str = str + curr.getEntry();\n" + "	    curr = curr.getNextNode();\n" + "	    if (curr != null && curr.getNextNode() != null) {\n" + "		str += \", \";\n" + "	    }\n" + "	}\n" + "	str += \">\";\n" + "	return str;\n" + "    }\n" + "\n" + "    // ***********************************************************\n" + "    // protected methods\n" + "\n" + "    protected void decreaseCursor() {\n" + "	if (isOffFront()) {\n" + "	    // System.err.println(\"Error in `SLList.decreaseCursor': cursorNode_ is invalid\");\n" + "	    throw new IllegalStateException(\"Error in `SLList.decreaseCursor': cursorNode_ is invalid\");\n" + "	}\n" + "	SLNode origCursor = cursorNode_;\n" + "\n" + "	firstEntry();\n" + "\n" + "	if (cursorNode_ == origCursor) {\n" + "	    cursorNode_ = theListNode_;\n" + "	} else {\n" + "	    while (!isOffEnd() && cursorNode_.getNextNode() != origCursor) {\n" + "		incrementCursor();\n" + "	    }\n" + "	}\n" + "    }\n" + "    protected SLList(SLList othLst) {\n" + "	theListNode_ = (SLNode)othLst.theListNode_.clone();\n" + "	firstEntry();\n" + "    }\n" + "    protected SLList(SLNode listNode) {\n" + "	theListNode_ = (SLNode)listNode.clone();\n" + "	firstEntry();\n" + "    }\n" + "\n" + "}\n" + "// @(#) $Id: E_SLList.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class E_SLList extends SLList { // Singly Linked List\n" + "\n" + "    // data members\n" + "    protected int length_;\n" + "    protected int log_;\n" + "\n" + "    public E_SLList() {\n" + "	super();\n" + "	length_ = 0;\n" + "	log_ = 0;\n" + "    }\n" + "    // accessors\n" + "    // ---------\n" + "    public /*@ pure @*/ int length() {\n" + "	return length_;\n" + "    }\n" + "    public /*@ pure @*/ boolean isEmpty() {\n" + "	return length_ == 0;\n" + "    }\n" + "\n" + "    // to allow multiple iterations over the same list\n" + "    // -----------------------------------------------\n" + "    public ListIterator createIterator() {\n" + "	return(new ListIterator(this));\n" + "    }\n" + "\n" + "    // methods for changing the list\n" + "    // -----------------------------\n" + "    public void removeEntry() {\n" + "	super.removeEntry();\n" + "	length_ --;\n" + "	log_++;\n" + "    }\n" + "    public void insertAfterCursor(Object newEntry) {\n" + "	super.insertAfterCursor(newEntry);\n" + "	length_ ++;\n" + "	log_++;\n" + "    }\n" + "    public void insertBeforeCursor(Object newEntry) {\n" + "\n" + "	decreaseCursor();\n" + "\n" + "	// link previous Node to new Node\n" + "	insertAfterCursor(newEntry);\n" + "\n" + "	// move the cursor forward to the original Node\n" + "	incrementCursor();\n" + "	incrementCursor();\n" + "	log_++;\n" + "    }\n" + "\n" + "    public void replaceEntry(Object newEntry) {\n" + "	super.replaceEntry(newEntry);\n" + "	log_++;\n" + "    }\n" + "    public void append(Object newEntry) {\n" + "	lastEntry();\n" + "	insertAfterCursor(newEntry);\n" + "	incrementCursor();\n" + "	log_++;\n" + "    }\n" + "    public void removeAllEntries() {\n" + "	firstEntry();\n" + "	while (!isOffEnd()) {\n" + "	    removeEntry();\n" + "	    incrementCursor();\n" + "	}\n" + "	log_++;\n" + "    }\n" + "    public /*@ non_null @*/ Object clone() {\n" + "	E_SLList result = new E_SLList( theListNode_, length_ );\n" + "	return result;\n" + "    }\n" + "\n" + "    // ***********************************************************\n" + "    // protected methods\n" + "\n" + "    protected void lastEntry() {\n" + "	if (isOffEnd()) {\n" + "	    decreaseCursor();\n" + "	} else {\n" + "\n" + "	    SLNode lastNode = cursorNode_;\n" + "\n" + "	    while (!isOffEnd()) {\n" + "		lastNode = cursorNode_;\n" + "		incrementCursor();\n" + "	    }\n" + "	    cursorNode_ = lastNode;\n" + "	}\n" + "    }\n" + "\n" + "    protected E_SLList(E_SLList othLst) {\n" + "	super(othLst);\n" + "	length_ = othLst.length_;\n" + "	log_ = othLst.log_;\n" + "	// To satisfy the class invariant the \n" + "	// model field 'cursor' needs a valid value before the call!\n" + "	firstEntry();\n" + "    }\n" + "    protected E_SLList(SLNode listNode, int len) {\n" + "	//	super(listNode);\n" + "	theListNode_ = (SLNode)listNode.clone();\n" + "	length_ = len;\n" + "	log_ = 0;\n" + "	// To satisfy the class invariant the \n" + "	// model field 'cursor' needs a valid value before the call!\n" + "	firstEntry();\n" + "    }\n" + "}\n" + "// @(#) $Id: Iterator.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author: Clyde Ruby\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "interface Iterator { \n" + "\n" + "  //@ public model instance Object uniteratedElems;\n" + "  //@ public model instance nullable Object currElem;\n" + "  //@ public model instance boolean unchanged;\n" + "\n" + "  /*@ public instance invariant currElem == null;\n" + "    @*/\n" + "\n" + "  /*@  public normal_behavior\n" + "    @    requires unchanged && !isDone();\n" + "    @*/\n" + "  public void next();\n" + "\n" + "  /*@  public normal_behavior\n" + "    @    requires unchanged;\n" + "    @    assignable \\nothing;\n" + "    @*/\n" + "  public /*@ pure @*/ boolean isDone();\n" + "\n" + "  /*@  public normal_behavior\n" + "    @    requires unchanged && !isDone();\n" + "    @    assignable \\nothing;\n" + "    @    ensures \\result == currElem;\n" + "    @*/\n" + "  public /*@ pure nullable @*/ Object currentItem();\n" + "}\n" + "\n" + "// @(#) $Id: RestartableIterator.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author: Clyde Ruby\n" + "\n" + "interface RestartableIterator extends Iterator {\n" + "\n" + "    /*@ public model instance Object iteratedElems;\n" + "      @*/\n" + "\n" + "  /*@\n" + "    @  public normal_behavior\n" + "    @    requires unchanged;\n" + "    @    assignable iteratedElems, currElem, uniteratedElems;\n" + "  public void first();\n" + "\n" + "  /*@\n" + "    @ also\n" + "    @  public normal_behavior\n" + "    @    requires unchanged && !isDone();\n" + "    @    assignable iteratedElems;\n" + "    @*/\n" + "  public void next();\n" + "\n" + "  /*@\n" + "    @ also\n" + "    @  public normal_behavior\n" + "    @    requires unchanged;\n" + "    @    assignable \\nothing;\n" + "    @*/\n" + "  public /*@ pure @*/ boolean isDone();\n" + "\n" + "}\n" + "\n" + "// @(#) $Id: ListIterator.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class ListIterator implements RestartableIterator {\n" + "\n" + "    // data members\n" + "    protected E_SLList listRef_;\n" + "\n" + "    protected int origLog_;\n" + "\n" + "    //@ protected represents listPtr <- listRef_;\n" + "    //@ protected represents currIndex <- listRef_.cursor;\n" + "    //@ protected represents origChgLog <- origLog_;\n" + "\n" + "    /*@ protected represents currElem <- \n" + "      @     (!listRef_.isOffFront() && !listRef_.isOffEnd())\n" + "      @   ? currentItem()\n" + "      @   : null;\n" + "      @*/\n" + "\n" + "    //@ protected represents currIndex <- listRef_.cursor;\n" + "    //@ protected represents unchanged <- (listRef_.changeLog == origChgLog);\n" + "\n" + "  /*@ also\n" + "    @ protected normal_behavior\n" + "    @   requires lst != null;\n" + "    @   assignable listRef_, listRef_.cursor, origLog_;\n" + "    @   ensures listRef_.cursor == 0\n" + "    @         && listRef_.theList.equals(lst.theList)\n" + "    @         && \\fresh(listRef_);\n" + "    @*/\n" + "    public ListIterator(E_SLList lst) {\n" + "	origLog_ = lst.log_;\n" + "	listRef_ = (E_SLList)lst.clone();\n" + "	listRef_.firstEntry();\n" + "    }\n" + "\n" + "    // don't allow the default constructor\n" + "    private ListIterator() {\n" + "    }\n" + "\n" + "  /*@ also\n" + "    @ protected normal_behavior\n" + "    @   assignable listRef_.cursor;\n" + "    @   ensures listRef_.cursor == 0;\n" + "    @*/\n" + "    public void first() {\n" + "	listRef_.firstEntry();\n" + "    }\n" + "\n" + "  /*@ also\n" + "    @ protected normal_behavior\n" + "    @   requires !listRef_.isOffEnd();\n" + "    @   assignable listRef_.cursor;\n" + "    @   ensures listRef_.cursor == \\pre(listRef_.cursor + 1);\n" + "    @*/\n" + "    public void next() {\n" + "	listRef_.incrementCursor();\n" + "    }\n" + "\n" + "  /*@ also\n" + "    @ protected normal_behavior \n" + "    @   assignable \\nothing;\n" + "    @   ensures \\result \n" + "    @       == (listRef_.cursor == listRef_.theList.int_length());\n" + "    @*/\n" + "    public boolean isDone() {\n" + "	return(listRef_.isOffEnd());\n" + "    }\n" + "\n" + "  /*@ also\n" + "    @ protected normal_behavior \n" + "    @   requires !listRef_.isOffFront() && !listRef_.isOffEnd();\n" + "    @   requires_redundantly listRef_.length() > 0;\n" + "    @   assignable \\nothing;\n" + "    @   ensures \\result == listRef_.theList.itemAt(listRef_.cursor);\n" + "    @*/\n" + "    public Object currentItem() {\n" + "	return(listRef_.getEntry());\n" + "    }\n" + "    public /*@ non_null @*/ String toString() {\n" + "	return listRef_.toString();\n" + "    }\n" + "\n" + "}\n" + "\n" + "// @(#) $Id: DLList.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "public class DLList extends E_SLList { // Doubly Linked List\n" + "\n" + "    protected DLNode lastNode_;\n" + "\n" + "    public DLList() {\n" + "	theListNode_ = new DLNode(null);\n" + "	length_ = 0;\n" + "\n" + "	// To satisfy the class invariant the \n" + "	// model field 'cursor' needs a valid value before the call!\n" + "	cursorNode_ = theListNode_;\n" + "	theListNode_.insertAfter(null);\n" + "	lastNode_ = (DLNode) theListNode_.getNextNode();\n" + "\n" + "	firstEntry();\n" + "    }\n" + "    // iteration methods\n" + "    // -----------------\n" + "    public void firstEntry() {\n" + "	// The first node is a sentinel so the first entry is in the 2nd node\n" + "	cursorNode_ = theListNode_.getNextNode();\n" + "    }\n" + "    public /*@ pure @*/ boolean isOffEnd() {\n" + "	return cursorNode_ == lastNode_;\n" + "    }\n" + "\n" + "    public void incrementCursor() {\n" + "	if (isOffEnd()) {\n" + "	    // System.err.println(\"Error in `DLList.incrementCursor()': No more List entries\");\n" + "	    throw new IllegalStateException(\"Error in `DLList.incrementCursor()': No more List entries\");\n" + "	}\n" + "	cursorNode_ = cursorNode_.getNextNode();\n" + "    }\n" + "\n" + "    /*@ non_null @*/ public Object getEntry() {\n" + "	if (isOffEnd()) {\n" + "	    // The following line is not pure\n" + "	    //System.err.println(\"Error in `DLList.getEntry': cursorNode_ is invalid\");\n" + "	    throw new IllegalStateException(\"Error in `DLList.getEntry': cursorNode_ is invalid\");\n" + "	}\n" + "	return(cursorNode_.getEntry());\n" + "    }\n" + "\n" + "    // NEW iteration methods (for doubly linked list)\n" + "    // ---------------------\n" + "    public void decrementCursor() {\n" + "	if (isOffFront()) {\n" + "	    // System.err.println(\"Error in `DLList.decrementCursor': cursorNode_ is invalid\");\n" + "	    throw new IllegalStateException(\"Error in `DLList.decrementCursor': cursorNode_ is invalid\");\n" + "	}\n" + "	cursorNode_ = ((DLNode)cursorNode_).getPrevNode();\n" + "	// super.decreaseCursor();\n" + "    }\n" + "    public void lastEntry() {\n" + "	// lastNode_ points to sentinel node at end of list.\n" + "	// So the node previous to the last sentinel node is the last node.\n" + "\n" + "	cursorNode_ = lastNode_;\n" + "	decrementCursor();\n" + "    }\n" + "    public void removeEntry() {\n" + "	if (isOffEnd() || isOffFront()) {\n" + "	    // System.err.println(\"Error in `DLList.removeEntry': cursorNode_ is invalid\");\n" + "	    throw new IllegalStateException(\"Error in `DLList.removeEntry': cursorNode_ is invalid\");\n" + "	}\n" + "\n" + "	DLNode prev1 = ((DLNode)cursorNode_).getPrevNode();\n" + "\n" + "	// link the previous node to the next node\n" + "	// link the next node back to the previous node\n" + "	prev1.removeNextNode();\n" + "\n" + "	cursorNode_ = prev1;\n" + "	length_ --;\n" + "	log_++;\n" + "    }\n" + "    public void insertAfterCursor(Object newEntry) {\n" + "	DLNode origCursor = (DLNode)cursorNode_;\n" + "\n" + "	if (!isOffEnd()) {\n" + "	    incrementCursor();\n" + "	}\n" + "\n" + "	insertBeforeCursor(newEntry);\n" + "	cursorNode_ = origCursor;\n" + "    }\n" + "    public void insertBeforeCursor(Object newEntry) {\n" + "	DLNode origCursor = (DLNode)cursorNode_;\n" + "\n" + "	if (isOffFront()) {\n" + "	    incrementCursor();\n" + "	} \n" + "\n" + "	((DLNode)cursorNode_).insertBefore(newEntry);\n" + "\n" + "	cursorNode_ = origCursor;\n" + "	log_++;\n" + "	length_ ++;\n" + "    }\n" + "    public /*@ non_null @*/ Object clone() {\n" + "	DLList result = new DLList( (DLNode) theListNode_.clone(),\n" + "				    length_ );\n" + "	return result;\n" + "    }\n" + "    public /*@ non_null @*/ String toString() {\n" + "	String str = \"<\";\n" + "	if (isOffEnd()) {\n" + "	    if (theListNode_.getNextNode() != null) {\n" + "		str += theListNode_.getNextNode().toString();\n" + "	    }\n" + "	    str += \" || \";\n" + "	} else {\n" + "	    str += cursorNode_.toString();\n" + "	}\n" + "	str += \">\";\n" + "	return str;\n" + "    }\n" + "\n" + "    // ***********************************************************\n" + "    // protected methods\n" + "\n" + "    protected DLList(DLList othLst) {\n" + "	theListNode_ = (DLNode) othLst.theListNode_;\n" + "	length_ = othLst.length_;\n" + "	log_ = othLst.log_;\n" + "	lastNode_ = othLst.lastNode_;\n" + "\n" + "	// To satisfy the class invariant the \n" + "	// model field 'cursor' needs a valid value before the call!\n" + "	cursorNode_ = theListNode_;\n" + "\n" + "	firstEntry();\n" + "    }\n" + "\n" + "    protected DLList(DLNode listNode, int len) {\n" + "	theListNode_ = listNode;\n" + "	length_ = len;\n" + "	log_ = 0;\n" + "	SLNode currNode = listNode;\n" + "	while (currNode.getNextNode() != null) {\n" + "	    currNode = currNode.getNextNode();\n" + "	}\n" + "	lastNode_ = (DLNode) currNode;\n" + "\n" + "	// To satisfy the class invariant the \n" + "	// model field 'cursor' needs a valid value before the call!\n" + "	cursorNode_ = theListNode_;\n" + "	firstEntry();\n" + "}\n");
    }

    public void test_TwoWayNode() {
        compile("OneWayNode.java", "// @(#) $Id: Iterator.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author: Clyde Ruby\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "interface Iterator { \n" + "\n" + "  //@ public model instance Object uniteratedElems;\n" + "  //@ public model instance nullable Object currElem;\n" + "  //@ public model instance boolean unchanged;\n" + "\n" + "  /*@ public instance invariant currElem == null;\n" + "    @*/\n" + "\n" + "  /*@  public normal_behavior\n" + "    @    requires unchanged && !isDone();\n" + "    @*/\n" + "  public void next();\n" + "\n" + "  /*@  public normal_behavior\n" + "    @    requires unchanged;\n" + "    @    assignable \\nothing;\n" + "    @*/\n" + "  public /*@ pure @*/ boolean isDone();\n" + "\n" + "  /*@  public normal_behavior\n" + "    @    requires unchanged && !isDone();\n" + "    @    assignable \\nothing;\n" + "    @    ensures \\result == currElem;\n" + "    @*/\n" + "  public /*@ pure nullable @*/ Object currentItem();\n" + "}\n" + "\n" + "// @(#) $Id: RestartableIterator.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author: Clyde Ruby\n" + "\n" + "interface RestartableIterator extends Iterator {\n" + "\n" + "    /*@ public model instance Object iteratedElems;\n" + "      @*/\n" + "\n" + "  /*@\n" + "    @  public normal_behavior\n" + "    @    requires unchanged;\n" + "    @    assignable iteratedElems, currElem, uniteratedElems;\n" + "  public void first();\n" + "\n" + "  /*@\n" + "    @ also\n" + "    @  public normal_behavior\n" + "    @    requires unchanged && !isDone();\n" + "    @    assignable iteratedElems;\n" + "    @*/\n" + "  public void next();\n" + "\n" + "  /*@\n" + "    @ also\n" + "    @  public normal_behavior\n" + "    @    requires unchanged;\n" + "    @    assignable \\nothing;\n" + "    @*/\n" + "  public /*@ pure @*/ boolean isDone();\n" + "\n" + "}\n" + "// @(#) $Id: OneWayNode.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "public class OneWayNode { // Singly Linked Node\n" + "\n" + "    // data members\n" + "\n" + "    protected /*@ nullable @*/ Object entry_;\n" + "    protected /*@ nullable @*/ OneWayNode nextNode_;\n" + "\n" + "    // methods\n" + "\n" + "    public OneWayNode() {\n" + "	entry_ = null;\n" + "	nextNode_ = null;\n" + "    }\n" + "    public OneWayNode(/*@ nullable @*/ Object ent) {\n" + "	entry_ = ent;\n" + "	nextNode_ = null;\n" + "    }\n" + "    public /*@ pure nullable @*/ Object getEntry() {\n" + "	return entry_;\n" + "    }\n" + "    public void setEntry(/*@ nullable @*/ Object newEntry) {\n" + "	entry_ = newEntry;\n" + "    }\n" + "    public /*@ pure nullable @*/ /* rep */ OneWayNode getNextNode() {\n" + "	return nextNode_;\n" + "    }\n" + "    public void insertAfter(/*@ nullable @*/ Object newEntry) {\n" + "	nextNode_ = new OneWayNode(newEntry, nextNode_);\n" + "    }\n" + "    public void removeNextNode() {\n" + "	if (nextNode_ != null) {\n" + "	    nextNode_ = nextNode_.getNextNode();\n" + "	}\n" + "    }\n" + "    public boolean hasNext() {\n" + "	return nextNode_ != null;\n" + "    }\n" + "    public /* unaliased */ Object clone() {\n" + "	if (nextNode_ == null) {\n" + "	    return new OneWayNode(getEntry());\n" + "	} else {\n" + "	    return new OneWayNode(getEntry(), \n" + "				  (OneWayNode)nextNode_.clone());\n" + "	}\n" + "    }\n" + "    public /*@ pure @*/ String toString() {\n" + "	return stringOfEntries(this);\n" + "    }\n" + "\n" + "    /** Returns the string concatentation of all nodes following this node up\n" + "     * to and excluding the end of the chain or this, which ever is reached\n" + "     * first (i.e. this method will terminate even for circular lists).\n" + "     */\n" + "    protected /*@ pure @*/ String stringOfEntries(\n" + "                                     /*@ nullable @*/ OneWayNode curr) \n" + "    {\n" + "	if (curr == null) {\n" + "	    return \"\";\n" + "	}\n" + "	// Get string representation of entry. (Note the following works even\n" + "	// if the entry is null.)\n" + "	String entryAsString = curr.getEntry() + \"\";\n" + "\n" + "	if (!curr.hasNext()\n" + "	    // the following disjunct prevents infinite recursion\n" + "	    || curr.getNextNode() == this) {\n" + "	    return entryAsString;\n" + "	}\n" + "	return entryAsString + \", \" + stringOfEntries(curr.getNextNode());\n" + "    }\n" + "    protected OneWayNode(/*@ nullable @*/ Object ent,\n" + "                         /*@ nullable @*/ OneWayNode nxtNode)\n" + "    {\n" + "	entry_ = ent;\n" + "	nextNode_ = nxtNode;\n" + "    }\n" + "}\n" + "\n" + "// @(#) $Id: TwoWayNode.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "class TwoWayNode extends OneWayNode { // Doubly Linked Node\n" + "\n" + "    // data members\n" + "\n" + "    protected /*@ nullable @*/ TwoWayNode prevNode_;\n" + "\n" + "    public TwoWayNode() {\n" + "	super();\n" + "	prevNode_ = null;\n" + "    }\n" + "    public TwoWayNode(/*@ nullable @*/ Object ent) {\n" + "	super(ent);\n" + "	prevNode_ = null;\n" + "    }\n" + "    public void insertAfter(/*@ nullable @*/ Object newEntry) {\n" + "	nextNode_ = new TwoWayNode(newEntry, this, (TwoWayNode)nextNode_);\n" + "    }\n" + "    public void removeNextNode() {\n" + "	if (nextNode_ != null) {\n" + "	    TwoWayNode nextNextNode = (TwoWayNode) nextNode_.getNextNode();\n" + "\n" + "	    // remove the current links\n" + "	    // the next line is needed in case nextNode_ is aliased\n" + "	    ((TwoWayNode) nextNode_).linkTo(null);\n" + "\n" + "	    this.linkTo(nextNextNode);\n" + "	}\n" + "    }\n" + "    public /*@ pure nullable @*/ TwoWayNode getPrevNode() {\n" + "	return prevNode_;\n" + "    }\n" + "    public void insertBefore(/*@ nullable @*/ Object newEntry) {\n" + "	prevNode_ = new TwoWayNode(newEntry, prevNode_, this);\n" + "    }\n" + "    public String toString() {\n" + "	String str = \"\";\n" + "	str += stringOfPrevEntries(((TwoWayNode)this).getPrevNode());\n" + "	str += \" || \";\n" + "	str += stringOfEntries(this);\n" + "	return str;\n" + "    }\n" + "\n" + "    /** The first invocation of this method should be with curr ==\n" + "     * prevNode_. If this is done, then the string returned will be a\n" + "     * concatentation of all nodes prior to this node up to and excluding the\n" + "     * end of the chain or this, which ever is reached first (i.e. this method\n" + "     * will terminate even for circular lists).\n" + "     */\n" + "    protected /*@ pure @*/ String stringOfPrevEntries(\n" + "                                      /*@ nullable @*/ TwoWayNode curr)\n" + "    {\n" + "	if (curr == null\n" + "	    // the following disjunct prevents infinite recursion\n" + "	    || curr == this) {\n" + "	    return \"\";\n" + "	}\n" + "	return stringOfPrevEntries(curr.getPrevNode())\n" + "	    + curr.getEntry() + \", \";\n" + "    }\n" + "    public Object clone() {\n" + "	if (nextNode_ == null) {\n" + "	    if (prevNode_ == null) {\n" + "		return new TwoWayNode(getEntry());\n" + "	    } else {\n" + "		return new TwoWayNode(getEntry(), \n" + "				      prevNode_.clonePrevious(), null);\n" + "	    }\n" + "	} else {\n" + "	    if (prevNode_ == null) {\n" + "		return new TwoWayNode(getEntry(), null, \n" + "				      ((TwoWayNode)nextNode_).cloneNext());\n" + "	    } else {\n" + "		return new TwoWayNode(getEntry(), \n" + "				      prevNode_.clonePrevious(), \n" + "				      ((TwoWayNode)nextNode_).cloneNext());\n" + "	    }\n" + "	}\n" + "    }\n" + "    protected /*@ pure @*/ TwoWayNode cloneNext() {\n" + "	if (nextNode_ == null) {\n" + "	    return new TwoWayNode(getEntry());\n" + "	} else {\n" + "	    return new TwoWayNode(getEntry(), null, \n" + "			      ((TwoWayNode)nextNode_).cloneNext());\n" + "	}\n" + "    }\n" + "    protected /*@ pure @*/ TwoWayNode clonePrevious() {\n" + "	if (prevNode_ == null) {\n" + "	    return new TwoWayNode(getEntry());\n" + "	} else {\n" + "	    return new TwoWayNode(getEntry(), prevNode_.clonePrevious(), null);\n" + "	}\n" + "    }\n" + "    private /*@ helper @*/ void linkTo(/*@ nullable @*/ TwoWayNode nxtNode) {\n" + "	if (nextNode_ != null) {\n" + "	    // needed in case nextNode_ is aliased\n" + "\n" + "	    ((TwoWayNode)nextNode_).prevNode_ = null;\n" + "	}\n" + "	if (nxtNode != null) {\n" + "	    // has to be done here or in a private helper method \n" + "	    // so the invariant holds!\n" + "	    nxtNode.prevNode_ = this;\n" + "	}\n" + "	nextNode_ = nxtNode;\n" + "    }\n" + "    protected TwoWayNode(/*@ nullable @*/ Object ent,\n" + "                         /*@ nullable @*/ TwoWayNode prvNode,\n" + "                         /*@ nullable @*/ TwoWayNode nxtNode)\n" + "    {\n" + "	this(ent);\n" + "	if (prvNode != null) {\n" + "	    prvNode.linkTo(this);\n" + "	}\n" + "	if (nxtNode != null) {\n" + "	    this.linkTo(nxtNode);\n" + "	}\n" + "    }\n" + "}\n" + "\n" + "// @(#) $Id: OneWayList.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class OneWayList { // Singly Linked List\n" + "\n" + "    // data members\n" + "\n" + "    protected OneWayNode theListNode_;\n" + "\n" + "    // used for inserting and iteration through the List \n" + "    protected OneWayNode cursorNode_;\n" + "\n" + "    public OneWayList() {\n" + "	theListNode_ = new OneWayNode(null);\n" + "	cursorNode_ = null;\n" + "    }\n" + "\n" + "    // iteration methods\n" + "    // -----------------\n" + "\n" + "    public void firstEntry() {\n" + "	// The first node is a sentinel so the first entry is in the 2nd node\n" + "	cursorNode_ = theListNode_.getNextNode();\n" + "    }\n" + "    public void incrementCursor() {\n" + "	if (isOffEnd()) {\n" + "	    // System.err.println(\"Error in `list2.OneWayList.incrementCursor()': No more List entries\");\n" + "	    // System.err.println(\"List is \" + this.toString());\n" + "	    throw new IllegalStateException(\"Error in `list2.OneWayList.incrementCursor()': No more List entries\\n\"\n" + "					    + \"List is \" + this.toString() );\n" + "	}\n" + "	cursorNode_ = cursorNode_.getNextNode();\n" + "    }\n" + "    public /*@ pure @*/ boolean isOffEnd() {\n" + "	return cursorNode_ == null;\n" + "    }\n" + "    public /*@ pure @*/ boolean isOffFront() {\n" + "	return cursorNode_ == theListNode_;\n" + "    }\n" + "    public /*@ pure @*/ Object getEntry() {\n" + "	if (isOffEnd() || isOffFront()) {\n" + "	    // The method cannot be pure if it calls the following\n" + "	    //System.err.println(\"Error in `list2.OneWayList.getEntry': cursorNode_ is invalid\");\n" + "	    //System.err.println(this);\n" + "	    throw new IllegalStateException(\"Error in `list2.OneWayList.getEntry': cursorNode_ is invalid\\n\"\n" + "					    + \"List is \" + this.toString() );\n" + "	}\n" + "	return cursorNode_.getEntry();\n" + "    }\n" + "\n" + "    // methods for changing the list\n" + "    // -----------------------------\n" + "    public void removeEntry() {\n" + "	if (isOffEnd() || isOffFront()) {\n" + "	    // System.err.println(\"Error in `list2.OneWayList.removeEntry': cursorNode_ is invalid\");\n" + "	    // System.err.println(\"List is \" + this.toString());\n" + "	    throw new IllegalStateException(\"Error in `list2.OneWayList.removeEntry()': cursorNode_ is invalid\\n\"\n" + "					    + \"List is \" + this.toString() );\n" + "	}\n" + "\n" + "	// link the previous node to the next node\n" + "	cursorNode_ = previousNode(theListNode_, cursorNode_);\n" + "	cursorNode_.removeNextNode();\n" + "    }\n" + "    public void replaceEntry(Object newEntry) {\n" + "	cursorNode_.setEntry(newEntry);\n" + "    }\n" + "    public void insertAfterCursor(Object newEntry) {\n" + "	if (isOffEnd()) {\n" + "	    // System.err.println(\"Error in `list2.OneWayList.insertAfterCursor': cursorNode_ is invalid\");\n" + "	    // System.err.println(\"Attempting to insert \" + newEntry);\n" + "	    // System.err.println(\"into list \" + this.toString());\n" + "	    throw new IllegalStateException(\"Error in `list2.OneWayList.insertAfterCursor()': cursorNode_ is invalid\\n\"\n" + "					    + \"Attempting to insert \" + newEntry\n" + "					    + \"into list \" + this.toString() );\n" + "	}\n" + "\n" + "	// creat a new Node containing newEntry and insert after cursor\n" + "	cursorNode_.insertAfter(newEntry);\n" + "    }\n" + "    public void insertBeforeCursor(Object newEntry) {\n" + "	if (isOffFront()) {\n" + "	    // System.err.println(\"Error in `list2.OneWayList.insertBeforeCursor': cursorNode_ is invalid\");\n" + "	    // System.err.println(\"Attempting to insert \" + newEntry);\n" + "	    // System.err.println(\"into list \" + this.toString());\n" + "	    throw new IllegalStateException(\"Error in `list2.OneWayList.insertBeforeCursor()': cursorNode_ is invalid\\n\"\n" + "					    + \"Attempting to insert \" + newEntry\n" + "					    + \"into list \" + this.toString() );\n" + "	}\n" + "\n" + "	cursorNode_ = previousNode(theListNode_, cursorNode_);\n" + "\n" + "	// link previous Node to new Node\n" + "	insertAfterCursor(newEntry);\n" + "\n" + "	// move the cursor forward to the original Node\n" + "	incrementCursor();\n" + "	incrementCursor();\n" + "    }\n" + "    public /*@ non_null @*/ Object clone() {\n" + "	return new OneWayList(this);\n" + "    }\n" + "    public /*@ non_null @*/ String toString() {\n" + "	String str = \"<\";\n" + "	OneWayNode curr = theListNode_.getNextNode();\n" + "	while (curr != cursorNode_ && curr != null) {\n" + "	    str += curr.getEntry().toString();\n" + "	    curr = curr.getNextNode();\n" + "	    if (curr.hasNext()) {\n" + "		str += \", \";\n" + "	    }\n" + "	}\n" + "	str += \" || \";\n" + "	while (curr != null) {\n" + "	    str += curr.getEntry().toString();\n" + "	    curr = curr.getNextNode();\n" + "	    if (curr.hasNext()) {\n" + "		str += \", \";\n" + "	    }\n" + "	}\n" + "	str += \">\";\n" + "	return str;\n" + "    }\n" + "\n" + "    // ***********************************************************\n" + "    // protected methods\n" + "\n" + "    protected OneWayNode previousNode(OneWayNode curr, OneWayNode node) {\n" + "	if (curr.getNextNode() == node) {\n" + "	    return curr;\n" + "	} else {\n" + "	    return previousNode(curr.getNextNode(), node);\n" + "	}\n" + "    }\n" + "    protected OneWayList(OneWayList othLst) {\n" + "	theListNode_ = (OneWayNode) othLst.theListNode_.clone();\n" + "	firstEntry();\n" + "    }\n" + "\n" + "}\n" + "// @(#) $Id: E_OneWayList.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class E_OneWayList extends OneWayList { // Singly Linked List\n" + "\n" + "    // data members\n" + "    protected int length_;\n" + "\n" + "    public E_OneWayList() {\n" + "	super();\n" + "	length_ = 0;\n" + "    }\n" + "\n" + "    // accessors\n" + "    // ---------\n" + "    public /*@ pure @*/ int length() {\n" + "	return length_;\n" + "    }\n" + "    public /*@ pure @*/ boolean isEmpty() {\n" + "	return length_ == 0;\n" + "    }\n" + "    public /*@ pure @*/ boolean equals(/*@ nullable @*/ Object obj) {\n" + "	if (! (obj instanceof OneWayList) ) {\n" + "	    return false;\n" + "	} else {\n" + "	    return equalsNode(theListNode_, \n" + "		              ((OneWayList)obj).theListNode_);\n" + "	}\n" + "    }\n" + "\n" + "    public /*@ pure @*/ int hashCode() {\n" + "        if ( isEmpty() ) {\n" + "            return super.hashCode();\n" + "        } else {\n" + "            return theListNode_.getNextNode().getEntry().hashCode() + length();\n" + "        }\n" + "    }\n" + "\n" + "    // methods for changing the list\n" + "    // -----------------------------\n" + "    public void removeEntry() {\n" + "	super.removeEntry();\n" + "	length_ --;\n" + "    }\n" + "    public void insertAfterCursor(Object newEntry) {\n" + "	super.insertAfterCursor(newEntry);\n" + "	length_ ++;\n" + "    }\n" + "    public void insertBeforeCursor(Object newEntry) {\n" + "	cursorNode_ = previousNode(theListNode_, cursorNode_);\n" + "	cursorNode_.insertAfter(newEntry);\n" + "	incrementCursor();\n" + "	incrementCursor();\n" + "	length_ ++;\n" + "    }\n" + "    public void append(Object newEntry) {\n" + "	lastEntry();\n" + "	if (isOffEnd()) { // empty list is always off the end!\n" + "	    insertBeforeCursor(newEntry);\n" + "	} else {\n" + "	    insertAfterCursor(newEntry);\n" + "	    incrementCursor();\n" + "	}\n" + "    }\n" + "    public void removeAllEntries() {\n" + "	firstEntry();\n" + "	while (!isOffEnd()) {\n" + "	    removeEntry();\n" + "	    incrementCursor();\n" + "	}\n" + "    }\n" + "    public /*@ non_null @*/ Object clone() {\n" + "	return new E_OneWayList(this);\n" + "    }\n" + "\n" + "    // ***********************************************************\n" + "    // protected methods\n" + "\n" + "    protected void lastEntry() {\n" + "	if (isOffEnd()) {\n" + "	    cursorNode_ = theListNode_;\n" + "	}\n" + "	while (cursorNode_.getNextNode() != null) {\n" + "	    incrementCursor();\n" + "	}\n" + "    }\n" + "    protected E_OneWayList(E_OneWayList othLst) {\n" + "	super(othLst);\n" + "	length_ = othLst.length();\n" + "    }\n" + "    private /*@ pure @*/ boolean equalsNode(/*@ nullable @*/ OneWayNode nd1, /*@ nullable @*/ OneWayNode nd2) {\n" + "	if (nd1 == null && nd2 == null) {\n" + "	    return true;\n" + "	} else if (nd1 == null || nd2 == null) {\n" + "	    return false;\n" + "	} else if (nd1.getEntry() == nd2.getEntry()) {\n" + "	    if (nd1 == nd2) {\n" + "		return false;\n" + "	    } else {\n" + "		return equalsNode(nd1.getNextNode(), nd2.getNextNode());\n" + "	    }\n" + "	} else {\n" + "	    return false;\n" + "	}\n" + "    }\n" + "}\n" + "// @(#) $Id: TwoWayIterator.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class TwoWayIterator implements RestartableIterator {\n" + "\n" + "    // data members\n" + "    protected TwoWayNode firstLink_;\n" + "    protected TwoWayNode currLink_;\n" + "    protected TwoWayNode lastLink_;\n" + "\n" + "    public TwoWayIterator(TwoWayNode link) {\n" + "	firstLink_ = link;\n" + "	currLink_ = firstLink_;\n" + "	lastLink_ = firstLink_;\n" + "	first();\n" + "	while ( !isDone() ) {\n" + "	    lastLink_ = currLink_;\n" + "	    next();\n" + "	}\n" + "	first();\n" + "	// System.out.println(\"iterator:\" + toString());\n" + "    }\n" + "    public void first() {\n" + "	// first node/link is a sentinel\n" + "	currLink_ = (TwoWayNode) firstLink_.getNextNode();\n" + "    }\n" + "    public void next() {\n" + "	currLink_ = (TwoWayNode) currLink_.getNextNode();\n" + "    }\n" + "    public /*@ pure @*/ boolean isDone() {\n" + "	return currLink_ == null;\n" + "    }\n" + "    public Object currentItem() {\n" + "	return currLink_.getEntry();\n" + "    }\n" + "    public void last() {\n" + "	currLink_ = lastLink_;\n" + "    }\n" + "    public void previous() {\n" + "	if (currLink_ == null) {\n" + "	    last();\n" + "	} else {\n" + "	    currLink_ = currLink_.getPrevNode();\n" + "	}\n" + "    }\n" + "    public /*@ pure @*/ boolean isAtFront() {\n" + "	if (currLink_ == null) {\n" + "	    return firstLink_.getNextNode() == null;\n" + "	} else {\n" + "	    return currLink_.getPrevNode() == firstLink_;\n" + "	}\n" + "    }\n" + "\n" + "    // don't allow the default constructor\n" + "    protected TwoWayIterator() {\n" + "	firstLink_ = new TwoWayNode();\n" + "	currLink_ = firstLink_;\n" + "	lastLink_ = firstLink_;\n" + "	first();\n" + "	// System.out.println(\"iterator:\" + toString());\n" + "    }\n" + "    public /*@ non_null @*/ String toString() {\n" + "	OneWayNode curr = firstLink_.getNextNode();\n" + "	String str = \"\";\n" + "	int index = 0;\n" + "	if (currLink_ == firstLink_) {\n" + "	    index = -1;\n" + "	    str += \" || <\";\n" + "	} else {\n" + "	    str += \"<\";\n" + "	    while (curr != currLink_) {\n" + "		str += curr.getEntry();\n" + "		if (curr.hasNext()) {\n" + "		    str += \", \";\n" + "		}\n" + "		curr = curr.getNextNode();\n" + "		index++;\n" + "	    }\n" + "	    str += \" || \";\n" + "	}\n" + "	while (curr != null) {\n" + "	    str += curr.getEntry();\n" + "	    if (curr.hasNext()) {\n" + "		str += \", \";\n" + "	    }\n" + "	    curr = curr.getNextNode();\n" + "	}\n" + "	str += \"> currIndex=\" + index;\n" + "	return str;\n" + "    }\n" + "}\n" + "\n" + "// @(#) $Id: TwoWayList.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "// Author:  Clyde Ruby\n" + "\n" + "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n" + "/*@ nullable_by_default @*/ \n" + "class TwoWayList extends E_OneWayList { // Doubly Linked List\n" + "\n" + "    protected TwoWayNode lastNode_;\n" + "\n" + "    public TwoWayList() {\n" + "	theListNode_ = new TwoWayNode(null);\n" + "	length_ = 0;\n" + "\n" + "	// The next statements are needed to satisfy the class invariant!!!\n" + "	// model field 'cursor' needs a valid value before the call!\n" + "	cursorNode_ = theListNode_;\n" + "	lastNode_ = (TwoWayNode) theListNode_;\n" + "\n" + "	firstEntry();\n" + "    }\n" + "    // iteration methods\n" + "    // -----------------\n" + "\n" + "    // NEW iteration methods (for doubly linked list)\n" + "    // ---------------------\n" + "    public void decrementCursor() {\n" + "	if (isOffFront()) {\n" + "	    // System.err.println(\"Error in `list2.TwoWayList.decrementCursor': cursorNode_ is invalid\");\n" + "	    throw new IllegalStateException(\"Error in `list2.TwoWayList.decrementCursor': cursorNode_ is invalid\");\n" + "	}\n" + "	if (isOffEnd()) {\n" + "	    lastEntry();\n" + "	} else {\n" + "	    cursorNode_ = ((TwoWayNode)cursorNode_).getPrevNode();\n" + "	}\n" + "    }\n" + "    public void lastEntry() {\n" + "	cursorNode_ = lastNode_;\n" + "    }\n" + "    public void removeEntry() {\n" + "	if (isOffEnd() || isOffFront()) {\n" + "	    // System.err.println(\"Error in `list2.TwoWayList.removeEntry': cursorNode_ is invalid\\n\"\n" + "	    //	       + \"List is \" + this.toString() );\n" + "	    throw new IllegalStateException(\"Error in `list2.TwoWayList.removeEntry': cursorNode_ is invalid\\n\"\n" + "					    + \"List is \" + this.toString() );\n" + "	}\n" + "\n" + "	decrementCursor();\n" + "\n" + "	if (cursorNode_.getNextNode() == lastNode_) {\n" + "	    lastNode_ = (TwoWayNode) cursorNode_;\n" + "	}\n" + "\n" + "	cursorNode_.removeNextNode();\n" + "	length_ --;\n" + "    }\n" + "    public void insertAfterCursor(Object newEntry) {\n" + "	if ( isOffEnd() ) {\n" + "	    decrementCursor();\n" + "	    cursorNode_.insertAfter(newEntry);\n" + "	    incrementCursor();\n" + "	    lastNode_ = (TwoWayNode) cursorNode_;\n" + "	    incrementCursor();\n" + "	    length_ ++;\n" + "	} else {\n" + "	    super.insertAfterCursor(newEntry);\n" + "	    // cursorNode_.insertAfter(newEntry);\n" + "	    // length_ ++;\n" + "	    if (lastNode_ == cursorNode_) {\n" + "		lastNode_ = (TwoWayNode) cursorNode_.getNextNode();\n" + "	    }\n" + "	}\n" + "    }\n" + "    public void insertBeforeCursor(Object newEntry) {\n" + "	if ( isOffFront() || isOffEnd() ) {\n" + "	    insertAfterCursor(newEntry);\n" + "	} else {\n" + "	    decrementCursor();\n" + "	    insertAfterCursor(newEntry);\n" + "	    incrementCursor();\n" + "	    incrementCursor();\n" + "	    // ((TwoWayNode)cursorNode_).insertBefore(newEntry);\n" + "	    // length_ ++;\n" + "	}\n" + "    }\n" + "    public /*@ non_null @*/ Object clone() {\n" + "	return(new TwoWayList(this));\n" + "    }\n" + "    public TwoWayIterator createIterator() {\n" + "	// System.out.println(\"creating:\" + toString());\n" + "	return new TwoWayIterator( (TwoWayNode) theListNode_ );\n" + "    }\n" + "\n" + "    // ***********************************************************\n" + "    // protected methods\n" + "\n" + "    protected TwoWayList(TwoWayList othLst) {\n" + "	theListNode_ = (TwoWayNode) othLst.theListNode_.clone();\n" + "	length_ = othLst.length_;\n" + "	cursorNode_ = theListNode_;\n" + "\n" + "	// set the lastNode_ field\n" + "	lastNode_ = (TwoWayNode) theListNode_;\n" + "	while (lastNode_.getNextNode() != null) {\n" + "	    lastNode_ = (TwoWayNode) lastNode_.getNextNode();\n" + "	}\n" + "\n" + "	// To satisfy the class invariant the \n" + "	// model field 'cursor' needs a valid value before the call!\n" + "\n" + "	firstEntry();\n" + "    }\n" + "\n" + "}\n");
    }

    public void test_Counter() {
        compile("Counter.java", "// @(#)$Id: Meter.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "/** A behavioral subtype of Counter. */\n" + "class Meter implements Counter {\n" + "\n" + "    /** The count of how many times inc has been called. */\n" + "    protected int count;\n" + "    //@               in val;\n" + "    //@ protected represents val <- count;\n" + "\n" + "    // doc comment and specification inherited.\n" + "    public void inc() { count++; }\n" + "\n" + "    // doc comment and specification inherited.\n" + "    public /*@ pure @*/ int value() { return count; }\n" + "\n" + "    /** Initialize this Meter. */\n" + "    /*@ assignable val;\n" + "      @ ensures val == 0;\n" + "      @*/\n" + "    public Meter() { count = 0; }\n" + "}\n" + "// @(#)$Id: Counter.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "/** A simple Counter.  This class is a demo of behavioral subtyping. */\n" + "public interface Counter {\n" + "\n" + "    /** The capacity of this counter. */\n" + "    int CAPACITY = 100;  // implicitly public, static, final\n" + "\n" + "    /** A model of the value of this counter. */\n" + "    //@ public model instance int val;\n" + "    //@ public instance invariant 0 <= val && val < CAPACITY;\n" + "\n" + "    /** Increment this counter */\n" + "    /*@ requires val < CAPACITY;\n" + "      @ assignable val;\n" + "      @ ensures val == \\old(val + 1);\n" + "      @*/\n" + "    public void inc();\n" + "\n" + "    /** Return the value of this counter. */\n" + "    //@ ensures \\result == val;\n" + "    public /*@ pure @*/ int value();\n" + "\n" + "}\n");
    }

    public void test_LinearSearch() {
        compile("LinearSearch.java", "// @(#)$Id: LinearSearch.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** A linear search component, intended to demonstrate verification in\n" + " * JML specifications.  This class has two abstract methods that\n" + " * describe the search, which need to be filled in to instantiate\n" + " * it.  The formulation of the search and the verification\n" + " * is based on Edward Cohen's book\n" + " * <cite>Programming in the 1990s</cite> (Springer-Verlag, 1990).\n" + " * @author Gary T. Leavens\n" + " */\n" + "public abstract class LinearSearch\n" + "{\n" + "    /** The function that describes what is being sought. */\n" + "    //@ requires j >= 0;\n" + "    public abstract /*@ pure @*/ boolean f(int j);\n" + "\n" + "    /** The last integer in the search space, this describes the\n" + "     * domain of f, which goes from 0 to the result.\n" + "     */\n" + "    //@ ensures 0 <= \\result;\n" + "    //@ ensures (\\exists int j; 0 <= j && j <= \\result; f(j));\n" + "    public abstract /*@ pure @*/ int limit();\n" + "\n" + "    /** Find a solution to the searching problem. */\n" + "    /*@ public normal_behavior\n" + "      @   requires (\\exists int i; 0 <= i && i <= limit(); f(i));\n" + "      @   assignable \\nothing;\n" + "      @   ensures \\result == (\\min int i; 0 <= i && f(i); i);\n" + "      @*/\n" + "    public int find() {\n" + "        int x = 0;\n" + "        //@ decreasing limit() - x;\n" + "        while (!f(x)) {\n" + "            /*@ assert 0 <= x && !f(x)\n" + "              @    && (\\forall int i; 0 <= i && i < x; !f(i));\n" + "              @*/\n" + "            /*@ assert 0 <= (x+1)-1 && !f((x+1)-1)\n" + "              @    && (\\forall int i; 0 <= i && i < (x+1)-1; !f(i));\n" + "              @*/\n" + "            x = x + 1;\n" + "            /*@ assert 0 <= x-1 && !f((int)(x-1))\n" + "              @    && (\\forall int i; 0 <= i && i < x-1; !f(i));\n" + "              @*/\n" + "            /*@ assert 0 <= x && (\\forall int i; i == x-1; !f(i))\n" + "              @    && (\\forall int i; 0 <= i && i < x-1; !f(i));\n" + "              @*/\n" + "            /*@ assert 0 <= x && \n" + "              @        (\\forall int i; (0 <= i && i < x-1) || i == x-1; !f(i));\n" + "              @*/\n" + "            //@ assert 0 <= x && (\\forall int i; 0 <= i && i < x; !f(i));\n" + "        }\n" + "        /*@ assert 0 <= x && f(x)\n" + "          @     && (\\forall int i; 0 <= i && i < x; !f(i));\n" + "          @*/\n" + "        //@ assert x == (\\min int i; 0 <= i && f(i); i);\n" + "        return x;\n" + "    }\n" + "}\n" + "// @(#)$Id: SingleSolution.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** A class of search problems for which there is one solution. */\n" + "abstract class SingleSolution extends LinearSearch\n" + "{\n" + "    /** The number sought. */\n" + "    protected /*@ spec_public @*/ int n;\n" + "\n" + "    /** Initialize this search problem. */\n" + "    //@ assignable this.n;\n" + "    //@ ensures this.n == n;\n" + "    public SingleSolution(int n) {\n" + "        this.n = n;\n" + "    }\n" + "\n" + "    // doc comment and specification inherited\n" + "    public /*@ pure @*/ int limit() {\n" + "        return n+1;\n" + "    }\n" + "\n" + "    // doc comment inherited\n" + "    //@ also\n" + "    //@ ensures \\result != null;\n" + "    public String toString() {\n" + "        return className() + \"(\" + n + \")\";\n" + "    }\n" + "\n" + "    /** A hook method for defining toString. */\n" + "    //@ ensures \\result != null;\n" + "    protected /*@ pure @*/ abstract String className();\n" + "}\n" + "// @(#)$Id: EqualsN.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** A search problem which is to find the number n.\n" + " * @author Gary T. Leavens\n" + " */\n" + "class EqualsN extends SingleSolution\n" + "{\n" + "    /** Initialize this search problem. */\n" + "    //@ assignable this.n;\n" + "    //@ ensures this.n == n;\n" + "    public EqualsN(int n) {\n" + "        super(n);\n" + "    }\n" + "\n" + "    // doc comment inherited\n" + "    //@ also\n" + "    //@ requires j >= 0;\n" + "    //@ ensures \\result <==> j == n;\n" + "    public /*@ pure @*/ boolean f(int j) {\n" + "        return j == n;\n" + "    }\n" + "\n" + "    // doc comment and specification inherited\n" + "    protected String className() {\n" + "        return \"EqualsN\";\n" + "    }\n" + "}\n" + "// @(#)$Id: LessThanN.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** A search problem which is to find the first number strictly less\n" + " * than n (and greater than 0).\n" + " * @author Gary T. Leavens\n" + " */\n" + "class LessThanN extends SingleSolution\n" + "{\n" + "    /** Initialize this search problem. */\n" + "    //@ requires n > 0;\n" + "    //@ ensures this.n == n;\n" + "    public LessThanN(int n) {\n" + "        super(n);\n" + "    }\n" + "\n" + "    // doc comment inherited\n" + "    //@ also\n" + "    //@ requires j >= 0;\n" + "    //@ ensures \\result <==> j < n;\n" + "    public /*@ pure @*/ boolean f(int j) {\n" + "        return j < n;\n" + "    }\n" + "\n" + "    // doc comment and specification inherited\n" + "    protected String className() {\n" + "        return \"LessThanN\";\n" + "    }\n" + "}\n");
    }

    public void test_Floyd_Hoare_style_Proof() {
        if (testIsDisabled("Need to fix nullities and generics")) return;
        compile("Proof.java", "// @(#)$Id: Proof.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2000 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** A class that demonstrates Floyd-Hoare-style proofs using JML\n" + " * notation.  This was originally used as an exercise for a class at\n" + " * the University of Iowa.\n" + " * @author Gary T. Leavens */\n" + "public class Proof {\n" + "\n" + "    /** A variable to keep track of the minimum. */\n" + "    protected /*@ spec_public @*/ int min = Integer.MAX_VALUE;\n" + "\n" + "    /** Exercise 1: find the minimum element in an array. */\n" + "    /*@ public normal_behavior\n" + "      @   requires a != null && a.length >= 1;\n" + "      @   assignable min;\n" + "      @   ensures (\\forall int i; 0 <= i && i < a.length; min <= a[i])\n" + "      @      && (\\exists int i; 0 <= i && i < a.length; min == a[i]);\n" + "      @*/\n" + "    public void find_min (int a[])\n" + "    {\n" + "        //@ assert a != null && a.length >= 1;\n" + "        /*@ assert (\\forall int i; 0 <= i && i < 1; a[0] <= a[i])\n" + "          @   && (\\exists int i; 0 <= i && i < 1; a[0] == a[i])\n" + "          @   && a.length >= 1;\n" + "          @*/\n" + "        min = a[0];\n" + "        /*@ assert (\\forall int i; 0 <= i && i < 1; min <= a[i])\n" + "          @   && (\\exists int i; 0 <= i && i < 1; min == a[i])\n" + "          @   && a.length >= 1;\n" + "          @*/\n" + "        int j = 1;\n" + "        /*@ assert (\\forall int i; 0 <= i && i < j; min <= a[i])\n" + "          @   && (\\exists int i; 0 <= i && i < j; min == a[i])\n" + "          @   && a.length >= j;\n" + "          @*/\n" + "        /*@ assert (\\forall int i; 0 <= i && i < j; min <= a[i])\n" + "          @   && (\\exists int i; 0 <= i && i < j; min == a[i])\n" + "          @   && j < a.length + 1;\n" + "          @*/\n" + "        while (j < a.length) {\n" + "            //@ ghost final int m = a.length - j;\n" + "            /*@ assert (\\forall int i; 0 <= i && i < j; min <= a[i])\n" + "              @   && (\\exists int i; 0 <= i && i < j; min == a[i])\n" + "              @   && j < a.length + 1\n" + "              @   && j < a.length \n" + "              @   && (a.length - j) <= m;\n" + "              @*/\n" + "            /*@ assert (\\forall int i; 0 <= i && i < j; min <= a[i])\n" + "              @   && (\\exists int i; 0 <= i && i < j; min == a[i])\n" + "              @   && j < a.length\n" + "              @   && 0 <= m && (a.length - j) <= m;\n" + "              @*/\n" + "            if (a[j] < min) {\n" + "                /*@ assert (\\forall int i; 0 <= i && i < j; min <= a[i])\n" + "                  @   && (\\exists int i; 0 <= i && i < j; min == a[i])\n" + "                  @   && j < a.length\n" + "                  @   && 0 <= m && (a.length - j) <= m\n" + "                  @   && a[j] < min;\n" + "                  @*/\n" + "                /*@ assert (\\forall int i; 0 <= i && i < (j+1) ==> a[j] <= a[i])\n" + "                  @   && (\\exists int i; 0 <= i && i < (j+1) && a[j] == a[i])\n" + "                  @   && j+1 < a.length + 1\n" + "                  @   && 0 <= m && (a.length - (j+1)) < m;\n" + "                  @*/\n" + "                min = a[j];\n" + "                /*@ assert (\\forall int i; 0 <= i && i < (j+1) ==> min <= a[i])\n" + "                  @   && (\\exists int i; 0 <= i && i < (j+1) && min == a[i])\n" + "                  @   && j+1 < a.length + 1\n" + "                  @   && 0 <= m && (a.length - (j+1)) < m;\n" + "                  @*/\n" + "            }\n" + "            /*@ assert (\\forall int i; 0 <= i && i < (j+1) ==> min <= a[i])\n" + "              @   && (\\exists int i; 0 <= i && i < (j+1) && min == a[i])\n" + "              @   && j+1 < a.length + 1\n" + "              @   && 0 <= m && (a.length - (j+1)) < m;\n" + "              @*/\n" + "            j = j + 1;\n" + "            /*@ assert (\\forall int i; 0 <= i && i < j; min <= a[i])\n" + "              @   && (\\exists int i; 0 <= i && i < j; min == a[i])\n" + "              @   && j < a.length + 1\n" + "              @   && 0 <= m && (a.length - j) < m;\n" + "              @*/\n" + "        }\n" + "        /*@ assert (\\forall int i; 0 <= i && i < j; min <= a[i])\n" + "          @   && (\\exists int i; 0 <= i && i < j; min == a[i])\n" + "          @   && j < a.length + 1\n" + "          @   && j >= a.length;\n" + "          @*/\n" + "        /*@ assert (\\forall int i; 0 <= i && i < j; min <= a[i])\n" + "          @   && (\\exists int i; 0 <= i && i < j; min == a[i])\n" + "          @   && j == a.length;\n" + "          @*/\n" + "        /*@ assert (\\forall int i; 0 <= i && i < a.length; min <= a[i])\n" + "          @   && (\\exists int i; 0 <= i && i < a.length; min == a[i]);\n" + "          @*/\n" + "    }\n" + "\n" + "    /** The index where the element occurs for exercise 2. */\n" + "    private /*@ spec_public @*/ int res = 0;\n" + "\n" + "    /** Return the value of res */\n" + "    public int getRes() { return res; }\n" + "\n" + "    /** Exercise 2: find the index of an integer in an array. */\n" + "    /*@ public normal_behavior\n" + "      @   requires a != null\n" + "      @      && (\\exists int i; 0 <= i && i < a.length; a[i] == x);\n" + "      @   assignable res;\n" + "      @   ensures 0 <= res && res < a.length && a[res] == x;\n" + "      @*/\n" + "    public void find(int a[], int x)\n" + "    {\n" + "        /*@ assert a != null\n" + "          @   && (\\exists int i; 0 <= i && i < a.length; a[i] == x);\n" + "          @*/\n" + "        /*@ assert ((\\exists int i; 0 <= i && i < 0;\n" + "          @                          a[i] == x && res == i)\n" + "          @          || (\\exists int i; 0 <= i && i < a.length;\n" + "          @                             a[i] == x))\n" + "          @   && 0 < a.length + 1;\n" + "          @*/\n" + "        int j = 0;\n" + "        /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "          @                          a[i] == x && res == i)\n" + "          @               || (\\exists int i; j <= i && i < a.length;\n" + "          @                                  a[i] == x))\n" + "          @   && j < a.length + 1;\n" + "          @*/\n" + "        while (j < a.length) {\n" + "            //@ ghost final int m = a.length - j;\n" + "            /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "              @                          a[i] == x && res == i)\n" + "              @          || (\\exists int i; j <= i && i < a.length;\n" + "              @                             a[i] == x))\n" + "              @   && j <= a.length + 1\n" + "              @   && j < a.length\n" + "              @   && a.length - j <= m;\n" + "              @*/\n" + "            /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "              @                          a[i] == x && res == i)\n" + "              @          || (\\exists int i; j <= i && i < a.length;\n" + "              @                             a[i] == x))\n" + "              @   && j <= a.length + 1\n" + "              @   && j < a.length\n" + "              @   && 0 < a.length - j\n" + "              @   && a.length - j <= m;\n" + "              @*/\n" + "            /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "              @                          a[i] == x && res == i)\n" + "              @          || (\\exists int i; j <= i && i < a.length;\n" + "              @                             a[i] == x))\n" + "              @   && j < a.length\n" + "              @   && 0 <= m && a.length - j <= m;\n" + "              @*/\n" + "\n" + "            if (a[j] == x) {\n" + "                /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "                  @                          a[i] == x && res == i)\n" + "                  @          || (\\exists int i; j <= i && i < a.length;\n" + "                  @                             a[i] == x))\n" + "                  @   && j < a.length\n" + "                  @   && 0 <= m && a.length - j <= m\n" + "                  @   && a[j] == x;\n" + "                  @*/\n" + "                /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "                  @                          a[i] == x && res == i)\n" + "                  @          || (\\exists int i; j <= i && i < j+1;\n" + "                  @                             a[i] == x && j == i)\n" + "                  @          || (\\exists int i; j+1 <= i && i < a.length;\n" + "                  @                             a[i] == x))\n" + "                  @   && j < a.length\n" + "                  @   && 0 <= m && a.length - j <= m\n" + "                  @   && a[j] == x;\n" + "                  @*/\n" + "      \n" + "                res = j;\n" + "                /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "                  @                          a[i] == x && res == i)\n" + "                  @          || (\\exists int i; j <= i && i < j+1;\n" + "                  @                             a[i] == x && res == i)\n" + "                  @          || (\\exists int i; j+1 <= i && i < a.length; \n" + "                  @                             a[i] == x))\n" + "                  @   && j < a.length\n" + "                  @   && 0 <= m && a.length - j <= m\n" + "                  @   && a[res] == x;\n" + "                  @*/\n" + "                /*@ assert ((\\exists int i; 0 <= i && i < j+1;\n" + "                  @                          a[i] == x && res == i)\n" + "                  @          || (\\exists int i; j+1 <= i && i < a.length;\n" + "                  @                             a[i] == x))\n" + "                  @   && j < a.length\n" + "                  @   && 0 <= m && a.length - j <= m;\n" + "                  @*/\n" + "\n" + "            }\n" + "            else {\n" + "                /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "                  @                          a[i] == x && res == i)\n" + "                  @          || (\\exists int i; j <= i && i < a.length;\n" + "                  @                             a[i] == x))\n" + "                  @   && j < a.length\n" + "                  @   && 0 <= m && a.length - j <= m\n" + "                  @   && a[j] != x;\n" + "                  @*/\n" + "                /*@ assert ((\\exists int i; 0 <= i && i < j+1;\n" + "                  @                          a[i] == x && res == i)\n" + "                  @          || (\\exists int i; j+1 <= i && i < a.length;\n" + "                  @                             a[i] == x))\n" + "                  @   && j < a.length\n" + "                  @   && 0 <= m && a.length - j <= m;\n" + "                  @*/\n" + "            }\n" + "            /*@ assert ((\\exists int i; 0 <= i && i < j+1; \n" + "              @                          a[i] == x && res == i)\n" + "              @          || (\\exists int i; j+1 <= i && i < a.length;\n" + "              @                             a[i] == x))\n" + "              @   && j < a.length\n" + "              @   && 0 <= m && a.length - j <= m;\n" + "              @*/\n" + "            /*@ assert ((\\exists int i; 0 <= i && i < j+1;\n" + "              @                          a[i] == x && res == i)\n" + "              @          || (\\exists int i; j+1 <= i && i < a.length;\n" + "              @                             a[i] == x))\n" + "              @   && (j+1) < a.length + 1\n" + "              @   && 0 <= m && a.length - (j+1) < m;\n" + "              @*/\n" + "\n" + "            j = j + 1;\n" + "            /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "              @                          a[i] == x && res == i)\n" + "              @          || (\\exists int i; j <= i && i < a.length;\n" + "              @                             a[i] == x))\n" + "              @   && j < a.length + 1\n" + "              @   && 0 <= m && a.length - j < m;\n" + "              @*/\n" + "        }\n" + "        /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "          @                          a[i] == x && res == i)\n" + "          @          || (\\exists int i; j <= i && i < a.length;\n" + "          @                             a[i] == x))\n" + "          @   && j < a.length + 1\n" + "          @   && j >= a.length;\n" + "          @*/\n" + "\n" + "        /*@ assert ((\\exists int i; 0 <= i && i < j;\n" + "          @                          a[i] == x && res == i)\n" + "          @          || (\\exists int i; j <= i && i < a.length;\n" + "          @                             a[i] == x))\n" + "          @   && j == a.length;\n" + "          @*/\n" + "        /*@ assert ((\\exists int i; 0 <= i && i < a.length;\n" + "          @                          a[i] == x && res == i)\n" + "          @          || (\\exists int i; a.length <= i && i < a.length;\n" + "          @                             a[i] == x));\n" + "          @*/\n" + "        /*@ assert (\\exists int i; 0 <= i && i < a.length;\n" + "          @                         a[i] == x && res == i);\n" + "          @*/\n" + "        //@ assert 0 <= res && res < a.length && a[res] == x;\n" + "    }\n" + "\n" + "}\n");
    }

    public void test_Reader() {
        compile("Reader.java", "// @(#)$Id: Reader.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "/** Readers.\n" + " * @author Arnd Poetzsch-Heffter\n" + " *         from an example by K. Rustan M. Leino and Greg Nelson, in\n" + " *         Data abstraction and information hiding,\n" + " *         ACM Transactions on Programming Languages and Systems,\n" + " *         Volume 24, number 5, pp. 491-553, September 2002.\n" + " */\n" + "public interface Reader {\n" + "  //@ public model instance boolean valid;\n" + "  //@ public model instance Object  state;\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   requires    valid;\n" + "    @   assignable  state;\n" + "    @   ensures     -1 <= \\result && \\result <= 65535;\n" + "    @*/\n" + "  public int read();\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   requires    valid;\n" + "    @   assignable  valid, state;\n" + "    @*/\n" + "  public void close();\n" + "  \n" + "}\n" + "// @(#)$Id: BufferedReader.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "/** Buffered readers.\n" + " * @author Arnd Poetzsch-Heffter\n" + " *         from an example by K. Rustan M. Leino and Greg Nelson, in\n" + " *         Data abstraction and information hiding,\n" + " *         ACM Transactions on Programming Languages and Systems,\n" + " *         Volume 24, number 5, pp. 491-553, September 2002.\n" + " */\n" + "abstract class BufferedReader implements Reader {\n" + "\n" + "  protected /*@ spec_public @*/ int lo, hi;\n" + "  protected /*@ spec_public @*/ int cur;\n" + "  protected /*@ spec_public @*/ char[] buff;\n" + "  \n" + "  //@ public model boolean svalid;\n" + "\n" + "  /*@ public represents valid <-\n" + "    @  this != null  &&\n" + "    @  0 <= lo  &&  lo <= cur  &&  cur <= hi  &&\n" + "    @  buff != null  &&  hi-lo <= buff.length &&\n" + "    @  svalid ;\n" + "    @*/\n" + "\n" + "\n" + "  public int read() {\n" + "    if( cur == hi ) refill();\n" + "    if( cur == hi )\n" + "      return -1;\n" + "    else {\n" + "      int result = buff[cur-lo];\n" + "      cur++;\n" + "      return result;\n" + "    }\n" + "  }\n" + "\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   requires    valid;\n" + "    @   assignable  state;\n" + "    @   ensures     cur == \\old(cur) ;\n" + "    @*/\n" + "  public abstract void refill();\n" + "\n" + "  \n" + "}\n" + "\n" + "\n" + "// @(#)$Id: BlankReader.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** A reader that delivers a stream of blanks.\n" + " * @author Arnd Poetzsch-Heffter\n" + " *         from an example by K. Rustan M. Leino and Greg Nelson, in\n" + " *         Data abstraction and information hiding,\n" + " *         ACM Transactions on Programming Languages and Systems,\n" + " *         Volume 24, number 5, pp. 491-553, September 2002.\n" + " */\n" + "class BlankReader extends BufferedReader\n" + "{\n" + "  private int num;\n" + "  //@           in state, svalid;\n" + "\n" + "  //@ private represents svalid <- hi <= num ;\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   requires    0 <= n;\n" + "    @   assignable  valid, state;\n" + "    @   ensures     valid && svalid;\n" + "    @*/\n" + "  public BlankReader( int n ) {\n" + "    num  = n;\n" + "    buff = new char[ Math.min(n,8192) ];\n" + "    lo  = 0;\n" + "    cur = 0;\n" + "    hi  = buff.length;\n" + "    for( int i = 0; i < hi; i++ ) {\n" + "      buff[i] = 32;\n" + "    }\n" + "  }\n" + "\n" + "  public void refill() {\n" + "    lo = cur;\n" + "    hi = Math.min( lo+buff.length, num );\n" + "  }\n" + "\n" + "  public void close() {}\n" + "\n" + "}\n" + "\n" + "// @(#)$Id: ReaderTest.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 2003 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "/** Tests for the readers example.\n" + " * @author Arnd Poetzsch-Heffter\n" + " *         from an example by K. Rustan M. Leino and Greg Nelson, in\n" + " *         Data abstraction and information hiding,\n" + " *         ACM Transactions on Programming Languages and Systems,\n" + " *         Volume 24, number 5, pp. 491-553, September 2002.\n" + " */\n" + "class  ReaderTest {\n" + "  \n" + "  /** Run the tests. */\n" + "  public static void main( String[] args ) {\n" + "\n" + "    int EXPECTED = 1000000;\n" + "    Reader rd = new BlankReader(EXPECTED);\n" + "\n" + "    int count = 0;\n" + "    int chr;\n" + "    do {\n" + "      chr = rd.read();\n" + "      count++;\n" + "    } while( chr != -1 );\n" + "    rd.close();\n" + "    if (count == EXPECTED+1) {\n" + "        System.out.println(\"Test passed\");\n" + "    } else {\n" + "        System.out.println(\"Failure: count was \" + count);\n" + "    }\n" + "  }  \n" + "}\n" + "\n" + "\n" + "\n" + "\n" + "\n" + "\n" + "\n" + "\n" + "\n");
    }

    public void test_IntegerSetInterface() {
        if (testIsDisabled("Need to fix nullities and generics")) return;
        compile("IntegerSetInterface.java", "// @(#)$Id: IntegerSetInterface.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "import java.util.*;\n" + "\n" + "/** Sets of integers. */\n" + "public interface IntegerSetInterface {\n" + "    /*@ public model instance Set theSet;\n" + "      @ public instance invariant_redundantly theSet != null;\n" + "      @ public initially theSet.isEmpty();\n" + "      @ public instance invariant\n" + "      @        (\\forall Object e; theSet.contains(e);\n" + "      @                            e instanceof Integer);\n" + "      @*/\n" + "\n" + "    /** Insert the given integer into this set. */\n" + "    /*@ public normal_behavior\n" + "      @	  assignable theSet;\n" + "      @	  ensures theSet.equals(\\old(theSet.add(new Integer(elem))));\n" + "      @*/\n" + "    public void insert(int elem);\n" + "\n" + "    /** Tell if the argument is in this set. */\n" + "    /*@ public normal_behavior	\n" + "      @	  ensures \\result == theSet.contains(new Integer(elem));\n" + "      @*/\n" + "    public /*@ pure @*/ boolean isMember(int elem);\n" + "\n" + "    /** Remove the given integer from this set. */\n" + "    /*@ public normal_behavior\n" + "      @   assignable theSet;\n" + "      @   ensures theSet.equals( \\old(theSet.remove(new Integer(elem))) );\n" + "      @*/\n" + "    public void remove(int elem);\n" + "}\n" + "// @(#)$Id: IntegerSetAsTree.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Sets of integers implemented as binary search trees.\n" + " *  This implementation demonstrates the use of JML's helper modifier.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " * @author Arthur Thomas\n" + " */\n" + "class IntegerSetAsTree implements IntegerSetInterface {\n" + "\n" + "    /** Is this tree empty?  When this is true, rootValue is not defined. */\n" + "    private boolean isEmpty;\n" + "    /** The integer at the root of the set. */\n" + "    private int rootValue;\n" + "    /** The left subtree, which may be null. */\n" + "    private /*@ nullable @*/ IntegerSetAsTree left;\n" + "    /** The right subtree, which may be null. */\n" + "    private /*@ nullable @*/ IntegerSetAsTree right;\n" + "    /** The parent of this subtree, which may be null. */\n" + "    private /*@ nullable @*/ IntegerSetAsTree parent;\n" + "\n" + "    /*@ private invariant (left != null || right != null) ==> !isEmpty; \n" + "      @\n" + "      @ private invariant left != null ==>\n" + "      @            (\\forall Object i; i != null && left.theSet.contains(i);\n" + "      @                                   true);\n" + "      @ private invariant right != null ==>\n" + "      @            (\\forall Object i; i != null && right.theSet.contains(i);\n" + "      @                                   true);\n" + "      @\n" + "      @ private invariant parent != null ==> !parent.isEmpty;\n" + "      @ private invariant parent != null && parent.left != null\n" + "      @                   ==> parent.left.rootValue < parent.rootValue; \n" + "      @ private invariant parent != null && parent.right != null\n" + "      @                   ==> parent.rootValue < parent.right.rootValue;\n" + "      @*/\n" + "\n" + "    /*@ private invariant left != null\n" + "      @                    ==> !left.isEmpty && left.rootValue < rootValue;\n" + "      @  private invariant right != null\n" + "      @                    ==> !right.isEmpty && rootValue < right.rootValue;\n" + "      @*/\n" + "\n" + "    /** Initialize this integer set to be empty. */\n" + "    /*@ public normal_behavior\n" + "      @   assignable theSet;\n" + "      @   ensures theSet.isEmpty();\n" + "      @*/\n" + "    public IntegerSetAsTree() {\n" + "        isEmpty = true;\n" + "        parent = null;\n" + "        constrHelper();\n" + "    }\n" + "\n" + "    /*@ protected normal_behavior\n" + "      @   assignable theSet;\n" + "      @   ensures theSet.equals(null); \n" + "      @*/\n" + "    protected IntegerSetAsTree(int elem, IntegerSetAsTree par) {\n" + "        isEmpty = false;\n" + "        rootValue = elem;\n" + "        parent = par;\n" + "        constrHelper();\n" + "    }\n" + "\n" + "    /** Set the left and right to null. */\n" + "    //@ private normal_behavior\n" + "    //@   assignable theSet;\n" + "    //@   ensures left == null && right == null;\n" + "    //@   ensures \\not_modified(isEmpty) && \\not_modified(parent);\n" + "    //@   ensures \\not_modified(rootValue);\n" + "    private /*@ helper @*/ void constrHelper() {\n" + "        right = null;\n" + "        left = null;\n" + "    }\n" + "\n" + "    // specification inherited\n" + "    public void insert(int elem) {\n" + "        if (isEmpty) {\n" + "            isEmpty = false;\n" + "            rootValue = elem;\n" + "        } else if (rootValue != elem) {\n" + "            if (elem < rootValue) {\n" + "                if (left == null) {\n" + "                    left = new IntegerSetAsTree(elem, this);\n" + "                } else {\n" + "                    left.insert(elem);\n" + "                }\n" + "            } else {\n" + "                //@ assume rootValue < elem;\n" + "                if (right == null) {\n" + "                    right = new IntegerSetAsTree(elem, this);\n" + "                } else {\n" + "                    right.insert(elem);\n" + "                }\n" + "            }\n" + "        }\n" + "    }\n" + "\n" + "    // specification is inherited\n" + "    public /*@ pure @*/\n" + "	boolean isMember(int elem) {\n" + "        if (isEmpty) {\n" + "            return false;\n" + "        } else if (rootValue == elem) {\n" + "            return true;\n" + "        } else if (elem < rootValue) {\n" + "            if (left == null) {\n" + "                return false;\n" + "            } else {\n" + "                return left.isMember(elem);\n" + "            }\n" + "        } else {\n" + "            //@ assume rootValue < elem;\n" + "            if (right == null) {\n" + "                return false;\n" + "            } else {\n" + "                return right.isMember(elem);\n" + "            }\n" + "        }\n" + "    }\n" + "\n" + "    // specification is inherited\n" + "    public void remove(int elem) {\n" + "        removeHelper(elem);\n" + "    }\n" + "\n" + "    /** Remove the given integer from this set.  Note that the\n" + "     *  invariants don't all apply to this method.  That is important,\n" + "     *  because the tree surgery done by this method calls this method\n" + "     *  recursively in states in which the invariant does not hold.\n" + "     */\n" + "    /*@ private normal_behavior\n" + "      @   assignable theSet;\n" + "      @   ensures theSet.equals( \\old(theSet.remove(new Integer(elem))) );\n" + "      @*/\n" + "    private /*@ helper @*/ void removeHelper(int elem) {\n" + "        if (!isEmpty) {\n" + "            if (rootValue == elem) {\n" + "                if (left == null && right == null) {\n" + "                    removeLeaf();\n" + "                } else {\n" + "                    removeRoot();\n" + "                }\n" + "            } else if (elem < rootValue) {\n" + "                if (left != null) {\n" + "                    left.removeHelper(elem);\n" + "                }\n" + "            } else {\n" + "                //@ assume rootValue < elem;\n" + "                if (right != null) {\n" + "                    right.removeHelper(elem);\n" + "                }\n" + "            }\n" + "        }\n" + "    }\n" + "\n" + "    /** Replace the current node with the successor or predecessor. */\n" + "    //@ requires left != null || right != null;\n" + "    //@ assignable theSet;\n" + "    private /*@ helper @*/ void removeRoot() {\n" + "        IntegerSetAsTree next = getSuccessor(); \n" + "        if (next == null) {                 \n" + "            next = getPredecessor();            \n" + "            //@ assume next != null;\n" + "            rootValue = next.rootValue; // left subtree\n" + "            left.removeHelper(rootValue);\n" + "        } else { // right subtree\n" + "            //@ assume next != null;\n" + "            rootValue = next.rootValue;\n" + "            right.removeHelper(rootValue);\n" + "        }\n" + "    }\n" + "\n" + "    /** Remove an integer from a leaf node. */\n" + "    /*@ requires left == null && right == null;\n" + "      @ {|\n" + "      @    requires parent != null;\n" + "      @    assignable parent.theSet, isEmpty;\n" + "      @  also\n" + "      @    requires parent == null;\n" + "      @    assignable isEmpty;\n" + "      @ |}\n" + "      @*/\n" + "    private /*@ helper @*/ void removeLeaf() {\n" + "        if (parent != null) {\n" + "            if (isLeftChild()) {\n" + "                parent.left = null;\n" + "            } else {\n" + "                parent.right = null;\n" + "            }\n" + "        }\n" + "        // empty this node\n" + "        isEmpty = true;\n" + "    }\n" + "\n" + "    /** Is this node and left child of its parent?. */\n" + "    //@ requires parent != null;\n" + "    private /*@ helper pure @*/ boolean isLeftChild() {\n" + "        return parent.left == this;\n" + "    }\n" + "\n" + "    /*@ requires right == null;\n" + "      @  ensures \\result == null;\n" + "      @ also\n" + "      @  requires right != null;\n" + "      @  ensures \\result != null\n" + "      @          && \\result.theSet.contains(new Integer(\n" + "      @                (\\min int i; right.theSet.contains(new Integer(i)); i)));\n" + "      @*/\n" + "    private /*@ helper pure nullable @*/ IntegerSetAsTree getSuccessor() {\n" + "        IntegerSetAsTree tree = right;\n" + "        if (right != null) {\n" + "            while (tree.left != null) {\n" + "                tree = tree.left;\n" + "            }\n" + "            //@ assert tree.left == null;\n" + "        }\n" + "        return tree;\n" + "    }\n" + "\n" + "    /*@ requires left == null;\n" + "      @  ensures \\result == null;\n" + "      @ also\n" + "      @  requires left != null;\n" + "      @  ensures \\result != null\n" + "      @          && \\result.theSet.contains(new Integer(\n" + "      @                (\\max int i; left.theSet.contains(new Integer(i)); i)));\n" + "      @*/\n" + "    private /*@ helper pure nullable @*/ IntegerSetAsTree getPredecessor() {\n" + "        IntegerSetAsTree tree = left;\n" + "        if (left != null) {\n" + "            while (tree.right != null) {\n" + "                tree = tree.right;\n" + "            }\n" + "            //@ assert tree.right == null;\n" + "        }\n" + "        return tree;\n" + "    }\n" + "\n" + "    // specification is inherited\n" + "    public /*@ pure @*/ String toString() {\n" + "        return \"{\" + this.printTree(true) + \"}\";\n" + "    }\n" + "\n" + "    /*@ protected normal_behavior\n" + "      @   assignable \\nothing;\n" + "      @   ensures \\result != null;\n" + "      @*/\n" + "    protected /*@ pure @*/ String printTree(boolean isFirst) {\n" + "        String ans = \"\";\n" + "\n" + "        if (!isEmpty) {\n" + "            if (left != null) {\n" + "                ans += left.printTree(isFirst);\n" + "                if (!left.isEmpty) {\n" + "                    isFirst = false;\n" + "                }\n" + "            }\n" + "            if (!isFirst) {\n" + "                ans += \", \";\n" + "            }\n" + "            ans += Integer.toString(rootValue);\n" + "            if (right != null) {\n" + "                ans += right.printTree(false);\n" + "            }\n" + "        }\n" + "		\n" + "        return ans;\n" + "    }\n" + "\n" + "}\n" + "// @(#)$Id: IntegerSetAsHashSet.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** A set of integers as a HashSet.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " */\n" + "\n" + "class IntegerSetAsHashSet implements IntegerSetInterface {\n" + "\n" + "    private /*@ non_null @*/ HashSet hset;\n" + "\n" + "    /** Return the abstract value of this IntegerSetAsHashSet. */\n" + "\n" + "    /** Initialize this set to be the empty set. */\n" + "    /*@ public normal_behavior\n" + "      @   assignable theSet;\n" + "      @   ensures theSet != null && theSet.isEmpty();\n" + "      @*/\n" + "    public IntegerSetAsHashSet() {\n" + "        hset = new HashSet();\n" + "    }\n" + "\n" + "    public /*@ pure @*/ boolean isMember(int i) {\n" + "        return hset.contains(new Integer(i));\n" + "    }\n" + "\n" + "    public void insert(int i) {\n" + "        hset.add(new Integer(i));\n" + "    }\n" + "\n" + "    public void remove(int i) {\n" + "        hset.remove(new Integer(i));\n" + "    }\n" + "\n" + "    public String toString() {\n" + "        return hset.toString();\n" + "    }\n" + "\n" + "}\n");
    }

    public void test_BoundedThing() {
        compile("BoundedThing.java", "// @(#)$Id: BoundedThing.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "import java.util.*;\n" + "public interface BoundedThing {\n" + "\n" + "    //@ public model instance int MAX_SIZE;\n" + "    //@ public model instance int size;\n" + "\n" + "    /*@ public instance invariant MAX_SIZE > 0;\n" + "        public instance invariant\n" + "                0 <= size && size <= MAX_SIZE;\n" + "        public instance constraint\n" + "                MAX_SIZE == \\old(MAX_SIZE);\n" + "      @*/\n" + "\n" + "    /*@  public normal_behavior\n" + "           ensures \\result == MAX_SIZE;\n" + "      @*/\n" + "    public /*@ pure @*/ int getSizeLimit();\n" + "\n" + "    /*@  public normal_behavior\n" + "           ensures \\result <==> size == 0;\n" + "      @*/\n" + "    public /*@ pure @*/ boolean isEmpty();\n" + "\n" + "    /*@  public normal_behavior\n" + "          ensures \\result <==> size == MAX_SIZE;\n" + "      @*/\n" + "    public /*@ pure @*/ boolean isFull();\n" + "\n" + "    /*@ also\n" + "         public behavior\n" + "           assignable \\nothing;\n" + "           ensures \\result instanceof BoundedThing\n" + "               && size == ((BoundedThing)\\result).size;\n" + "           signals_only CloneNotSupportedException;\n" + "      @*/\n" + "    public Object clone ()\n" + "       throws CloneNotSupportedException;\n" + "}\n" + "// @(#)$Id: BoundedStackInterface.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "interface BoundedStackInterface extends BoundedThing {\n" + "    //@ public initially theStack != null && theStack.isEmpty();\n" + "  /*@ public model instance Stack theStack;\n" + "    @*/\n" + "  //@ public instance represents size <- theStack.size();\n" + "  /*@ public instance invariant theStack != null;\n" + "    @ public instance invariant_redundantly\n" + "    @                           theStack.size() <= MAX_SIZE;\n" + "    @ public instance invariant \n" + "    @         (\\forall int i; 0 <= i && i < theStack.size();\n" + "    @                         theStack.get(i) != null);\n" + "    @*/\n" + "\n" + "  /*@   public normal_behavior\n" + "    @     requires !theStack.isEmpty();\n" + "    @     assignable size, theStack;\n" + "    @     ensures theStack.equals(\\old(theStack));\n" + "    @ also\n" + "    @   public exceptional_behavior\n" + "    @     requires theStack.isEmpty();\n" + "    @     assignable \\nothing;\n" + "    @     signals_only BoundedStackException;\n" + "    @*/\n" + "  public void pop( ) throws BoundedStackException;\n" + "\n" + "  /*@   public normal_behavior\n" + "    @     requires theStack.size() < MAX_SIZE && x != null;\n" + "    @     assignable size, theStack;\n" + "    @     ensures theStack.equals(\\old(theStack.add(x)));\n" + "    @     ensures_redundantly theStack != null \n" + "    @              && theStack.size() \n" + "    @                     == \\old(theStack.size()+1);\n" + "    @ also\n" + "    @   public exceptional_behavior\n" + "    @     requires theStack.size() >= MAX_SIZE || x == null;\n" + "    @     assignable \\nothing;\n" + "    @     signals_only BoundedStackException, NullPointerException;\n" + "    @     signals (BoundedStackException)\n" + "    @                  theStack.size() == MAX_SIZE;\n" + "    @     signals (NullPointerException) x == null;\n" + "    @*/\n" + "  public void push(Object x )\n" + "         throws BoundedStackException, NullPointerException;\n" + "\n" + "  /*@   public normal_behavior\n" + "    @     requires !theStack.isEmpty();\n" + "    @     ensures \\result == theStack.get(0) && \\result != null;\n" + "    @ also\n" + "    @   public exceptional_behavior\n" + "    @     requires theStack.isEmpty();\n" + "    @     signals_only BoundedStackException;\n" + "    @     signals (BoundedStackException e)\n" + "    @           true;\n" + "    @*/\n" + "  public /*@ pure @*/ Object top( ) throws BoundedStackException;\n" + "}\n" + "// @(#)$Id: BoundedStackException.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "class BoundedStackException extends RuntimeException {\n" + "\n" + "    public BoundedStackException() { super(); }\n" + "    public BoundedStackException(String s) { super(s); }\n" + "\n" + "}\n" + "// @(#)$Id: BoundedStack.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "class BoundedStack implements BoundedStackInterface {\n" + "\n" + "  // implementation data structures\n" + "  protected java.lang.Object[] theItems;\n" + "  protected int nextFree;\n" + "  protected int maxSize;\n" + "\n" + "\n" + "  //@ protected invariant 0 <= nextFree && nextFree <= theItems.length;\n" + "  //@ protected invariant theItems != null;\n" + "    /*@ protected invariant\n" + "    @     (\\forall int i; 0 <= i && i < nextFree;\n" + "    @                     theItems[i] != null);\n" + "    @*/\n" + "\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   assignable MAX_SIZE, size, theStack;\n" + "    @   ensures theStack.equals(new Stack());\n" + "    @   ensures_redundantly theStack.isEmpty() && size == 0;\n" + "    @*/\n" + "  public BoundedStack( )\n" + "  { \n" + "    maxSize = 10;\n" + "    theItems = new Object[maxSize];\n" + "    nextFree = 0;\n" + "    /*@ assert \\fresh(theItems) && nextFree == 0\n" + "      @   && theItems.length == maxSize;\n" + "      @*/\n" + "  }\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   assignable MAX_SIZE, size, theStack;\n" + "    @   ensures theStack.equals(new Stack());\n" + "    @   ensures_redundantly theStack.isEmpty() && size == 0\n" + "    @        && MAX_SIZE == maxSize;\n" + "    @*/\n" + "  public BoundedStack(int maxSize)\n" + "  { \n" + "    theItems = new Object[maxSize];\n" + "    nextFree = 0;\n" + "    this.maxSize = maxSize;\n" + "    /*@ assert \\fresh(theItems) && nextFree == 0\n" + "      @   && theItems.length == maxSize;\n" + "      @*/\n" + "  }\n" + "\n" + "  public Object clone ()\n" + "  {\n" + "    BoundedStack retValue = new BoundedStack(maxSize);\n" + "    retValue.nextFree = nextFree;\n" + "    for (int k = 0; k < nextFree; k++) {\n" + "      retValue.theItems[k] = theItems[k];\n" + "    }\n" + "    return retValue;\n" + "  }\n" + "\n" + "  public int getSizeLimit()\n" + "  {\n" + "    return maxSize;\n" + "  }\n" + "\n" + "  public boolean isEmpty( )\n" + "  {\n" + "    return (nextFree == 0);\n" + "  }\n" + "\n" + "  public boolean isFull()\n" + "  {\n" + "    return (nextFree == maxSize);\n" + "  }\n" + "\n" + "  public void pop( ) throws BoundedStackException\n" + "  {\n" + "    if (nextFree == 0) {\n" + "      throw new BoundedStackException(\"Tried to pop an empty stack.\");\n" + "    } else {\n" + "      nextFree--;\n" + "      //@ assert nextFree == \\old(nextFree) - 1;\n" + "      return;\n" + "    }   \n" + "  }\n" + "\n" + "  public void push(Object x ) throws BoundedStackException\n" + "  {\n" + "    if (nextFree == maxSize) {\n" + "      throw new BoundedStackException(\"Tried to push onto a full stack\");\n" + "    } else if (x == null) {\n" + "      throw new NullPointerException(\"Argument x to push is null\");\n" + "    } else {\n" + "      theItems[nextFree++] = x;\n" + "      return;\n" + "    }   \n" + "  }\n" + "\n" + "  public Object top( ) throws BoundedStackException\n" + "  {\n" + "    if (nextFree == 0) {\n" + "      throw new BoundedStackException(\"empty stack\");\n" + "    } else {\n" + "      return theItems[nextFree - 1];\n" + "    }\n" + "  }\n" + "\n" + "  /*@ also\n" + "    @   public normal_behavior\n" + "    @     assignable \\nothing;\n" + "    @     ensures \\result != null\n" + "    @          && (* a string encoding of this is returned *);\n" + "    @*/\n" + "  public String toString()\n" + "  {\n" + "    StringBuffer ret = new StringBuffer(this.getClass().toString() + \" [\");\n" + "    boolean first = true;\n" + "    for (int k = nextFree - 1; k >= 0; k--) {\n" + "        if (first) {\n" + "            first = false;\n" + "        } else {\n" + "            ret.append(\", \");\n" + "        }\n" + "        if (theItems[k] != null) {\n" + "            ret.append(theItems[k]);\n" + "        } else {\n" + "            ret.append(\"null\");\n" + "        }\n" + "    } \n" + "    ret.append(\"]\");\n" + "    return ret.toString();\n" + "  }\n" + "\n" + "  /*@ protected normal_behavior\n" + "    @   assignable System.out;\n" + "    @   ensures (* prints a version of stack to System.out *);\n" + "    @*/\n" + "  protected void printStack ( )\n" + "  {\n" + "    System.out.println(\"The stack items are (top first):\");\n" + "    System.out.println(toString());\n" + "  }\n" + "}\n" + "// @(#)$Id: BoundedStackImplementation.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "class BoundedStackImplementation implements BoundedStackInterface {\n" + "\n" + "  // implementation data structures\n" + "  protected java.lang.Object[] theItems;\n" + "  protected int nextFree;\n" + "  //@ protected invariant 0 <= nextFree && nextFree <= theItems.length;\n" + "  //@ protected invariant theItems != null;\n" + "   /*@ protected invariant\n" + "    @     (\\forall int i; 0 <= i && i < nextFree;\n" + "    @                     theItems[i] != null);\n" + "    @*/\n" + "\n" + "  private static int MAX_STACK_ITEMS = 10;\n" + "\n" + "\n" + "  //@ private invariant theItems.length == MAX_STACK_ITEMS;\n" + "\n" + "  /*@ protected normal_behavior\n" + "    @   assignable size, theStack;\n" + "    @   assignable_redundantly theItems, nextFree;\n" + "    @   ensures nextFree == 0;\n" + "    @*/\n" + "  public BoundedStackImplementation( )\n" + "  {\n" + "    theItems = new Object[MAX_STACK_ITEMS];\n" + "    nextFree = 0;\n" + "  }\n" + "\n" + "  /*@ also\n" + "    @   protected behavior\n" + "    @     assignable \\nothing;\n" + "    @     ensures \n" + "    @       Arrays.equals(theItems,\n" + "    @                     ((BoundedStackImplementation)\\result).theItems) && \n" + "    @         nextFree == ((BoundedStackImplementation)\\result).nextFree\n" + "    @         && this != \\result;\n" + "    @     ensures_redundantly \\result != null;\n" + "    @*/\n" + "  public java.lang.Object clone () throws CloneNotSupportedException\n" + "  {\n" + "      BoundedStackImplementation res = new BoundedStackImplementation();\n" + "      res.theItems = (Object[])(theItems.clone());\n" + "      res.nextFree = nextFree;\n" + "      return res;\n" + "  }\n" + "\n" + "  /*@ also\n" + "    @   protected normal_behavior\n" + "    @     ensures \\result == theItems.length;\n" + "    @ implies_that\n" + "    @     private normal_behavior\n" + "    @     ensures \\result == MAX_STACK_ITEMS;\n" + "    @*/\n" + "  public int getSizeLimit()\n" + "  {\n" + "    return MAX_STACK_ITEMS;\n" + "  }\n" + "\n" + "  /*@ also\n" + "    @   protected normal_behavior\n" + "    @       ensures \\result == (nextFree == 0);\n" + "    @*/\n" + "  public boolean isEmpty( )\n" + "  {\n" + "    return (nextFree == 0);\n" + "  }\n" + "\n" + "  /*@ also\n" + "    @   protected normal_behavior\n" + "    @     ensures \\result == (nextFree == theItems.length);\n" + "    @*/\n" + "  public boolean isFull()\n" + "  {\n" + "    return (nextFree == MAX_STACK_ITEMS);\n" + "  }\n" + "\n" + "  /*@ also\n" + "    @    protected normal_behavior\n" + "    @     requires nextFree != 0;\n" + "    @     assignable theStack;\n" + "    @     assignable_redundantly nextFree;\n" + "    @     ensures nextFree == \\old(nextFree - 1)\n" + "    @           && \\not_modified(theItems);\n" + "    @     ensures_redundantly Arrays.equals(theItems,\\old(theItems));\n" + "    @ also \n" + "    @    protected exceptional_behavior\n" + "    @     requires nextFree == 0;\n" + "    @     assignable \\nothing;\n" + "    @     signals_only BoundedStackException;\n" + "    @*/\n" + "  public void pop( ) throws BoundedStackException\n" + "  {\n" + "    if (nextFree == 0) {\n" + "      throw new BoundedStackException(\"Tried to pop an empty stack.\");\n" + "    } else {\n" + "      nextFree--;\n" + "      return;\n" + "    }   \n" + "  }\n" + "\n" + "  /*@ also\n" + "    @    protected normal_behavior\n" + "    @     requires nextFree < theItems.length && x != null;\n" + "    @     assignable theStack;\n" + "    @     assignable_redundantly nextFree, theItems[nextFree];\n" + "    @ also\n" + "    @   protected exceptional_behavior\n" + "    @     requires nextFree >= theItems.length || x == null;\n" + "    @     assignable \\nothing;\n" + "    @     signals (BoundedStackException) nextFree >= theItems.length;\n" + "    @     signals (NullPointerException) x == null;\n" + "    @*/\n" + "  public void push(Object x ) throws BoundedStackException\n" + "  {\n" + "        if (nextFree == MAX_STACK_ITEMS) {\n" + "          throw new BoundedStackException(\"Tried to push onto a full stack\");\n" + "        } else if (x == null) {\n" + "          throw new NullPointerException(\"Argument x to push is null\");\n" + "        } else {\n" + "          theItems[nextFree++] = x;\n" + "          return;\n" + "        }       \n" + "    }\n" + "\n" + "  /*@ also\n" + "    @   protected normal_behavior\n" + "    @     requires nextFree != 0;\n" + "    @     assignable \\nothing;\n" + "    @     ensures \\result == theItems[(int)(nextFree - 1)];\n" + "    @ also \n" + "    @   protected exceptional_behavior\n" + "    @     requires nextFree == 0;\n" + "    @     assignable \\nothing;\n" + "    @*/\n" + "  public Object top( ) throws BoundedStackException\n" + "  {\n" + "    if (nextFree == 0) {\n" + "      throw new BoundedStackException(\"empty stack\");\n" + "    } else {\n" + "      return theItems[nextFree - 1];\n" + "    }\n" + "  }\n" + "\n" + "  /*@ also\n" + "    @   public normal_behavior\n" + "    @     assignable \\nothing;\n" + "    @     ensures \\result != null\n" + "    @          && (* a string encoding of this is returned *);\n" + "    @*/\n" + "  public String toString()\n" + "  {\n" + "    StringBuffer ret = new StringBuffer(this.getClass().toString() + \" [\");\n" + "    boolean first = true;\n" + "    for (int k = nextFree - 1; k >= 0; k--) {\n" + "        if (first) {\n" + "            first = false;\n" + "        } else {\n" + "            ret.append(\", \");\n" + "        }\n" + "        if (theItems[k] != null) {\n" + "            ret.append(theItems[k]);\n" + "        } else {\n" + "            ret.append(\"null\");\n" + "        }\n" + "    } \n" + "    ret.append(\"]\");\n" + "    return ret.toString();\n" + "  }\n" + "\n" + "  /*@ protected normal_behavior\n" + "    @   assignable System.out;\n" + "    @   ensures (* prints a version of stack to System.out *);\n" + "    @*/\n" + "  protected void printStack ( )\n" + "  {\n" + "    System.out.println(\"The stack items are (top first):\");\n" + "    System.out.println(toString());\n" + "  }\n" + "}\n", "");
    }

    public void test_UnboundedStack() {
        if (testIsDisabled("UnboundedStack.java [line: 2782, column: 16]: theStack cannot be resolved")) return;
        compile("UnboundedStack.java", "// @(#)$Id: UnboundedStack.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "import java.util.*;\n" + "\n" + "public abstract class UnboundedStack {\n" + "\n" + "  /*@ public model Stack theStack;\n" + "    @ public initially theStack != null\n" + "    @                  && theStack.isEmpty();\n" + "    @*/\n" + "\n" + "  //@ public invariant theStack != null;\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   requires !theStack.isEmpty();\n" + "    @   assignable theStack;\n" + "    @   ensures theStack.equals(\n" + "    @              \\old(theStack));\n" + "    @*/\n" + "  public abstract void pop( );\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   assignable theStack;\n" + "    @   ensures theStack.equals(\n" + "    @              \\old(theStack.add(x)));\n" + "    @*/\n" + "  public abstract void push(Object x);\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   requires !theStack.isEmpty();\n" + "    @   assignable \\nothing;\n" + "    @   ensures \\result == theStack.get(0);\n" + "    @*/\n" + "  public /*@ pure @*/ abstract Object top( );\n" + "}\n" + "// @(#)$Id: UnboundedStack2.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "abstract class UnboundedStack2 {\n" + "\n" + "  /*@ public model non_null Stack theStack;\n" + "    @ public initially theStack.isEmpty();\n" + "    @*/\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   requires !theStack.isEmpty();\n" + "    @   assignable theStack;\n" + "    @   ensures theStack.equals(\\old(theStack));\n" + "    @*/\n" + "  public abstract void pop( );\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   assignable theStack;\n" + "    @   ensures theStack.equals(\\old(theStack.add(x)));\n" + "    @*/\n" + "  public abstract void push(Object x);\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   requires !theStack.isEmpty();\n" + "    @   assignable \\nothing;\n" + "    @   ensures \\result == theStack.get(0);\n" + "    @*/\n" + "  public /*@ pure @*/ abstract Object top( );\n" + "}\n" + "// @(#)$Id: UnboundedStackAsArrayList.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "class UnboundedStackAsArrayList extends UnboundedStack {\n" + "\n" + "  protected ArrayList elems;\n" + "\n" + "  //@ protected invariant elems != null;\n" + "\n" + "  /*@ public normal_behavior\n" + "    @   assignable theStack;\n" + "    @   ensures theStack.isEmpty();\n" + "    @*/\n" + "  public UnboundedStackAsArrayList()\n" + "  {\n" + "    elems = new ArrayList();\n" + "  }\n" + "\n" + "  /*@ also\n" + "    @   protected normal_behavior\n" + "    @     requires !theStack.isEmpty();\n" + "    @     assignable theStack;\n" + "    @     ensures \\not_modified(elems);\n" + "    @*/\n" + "  public void pop( )\n" + "  {\n" + "    elems.remove(0);\n" + "  }\n" + "\n" + "  /*@ also\n" + "    @   protected normal_behavior\n" + "    @     assignable theStack;\n" + "    @     ensures \\not_modified(elems);\n" + "    @*/\n" + "  public void push(Object x)\n" + "  {\n" + "    elems.add(0,x);\n" + "  }\n" + "\n" + "  public Object top( )\n" + "  {\n" + "    return elems.get(0);\n" + "  }\n" + "\n" + "  public String toString() {\n" + "      StringBuffer ret = new StringBuffer(\"UnboundedStack[\");\n" + "      Iterator iter = elems.iterator();\n" + "      boolean first = true;\n" + "      while (iter.hasNext()) {\n" + "          Object o = iter.next();\n" + "          if (o != null) {\n" + "              ret.append(o.toString());\n" + "          } else {\n" + "              ret.append(\"null\");\n" + "          }\n" + "          if (first) {\n" + "              first = false;\n" + "          } else {\n" + "              ret.append(\", \");\n" + "          }\n" + "      }\n" + "      ret.append(\"]\");\n" + "      return ret.toString();\n" + "  }\n" + "}\n" + "// @(#)$Id: UnboundedStackRC.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "abstract class UnboundedStackRC {\n" + "\n" + "  /*@ public model non_null Stack theStack;\n" + "    @ public initially theStack.isEmpty();\n" + "    @*/\n" + "  //@ public invariant theStack != null;\n" + "\n" + "\n" + "  public abstract void pop( );\n" + "\n" + "  public abstract void push(Object x);\n" + "\n" + "  public abstract Object top( );\n" + "}\n" + "// @(#)$Id: UnboundedStackRC2.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "abstract class UnboundedStackRC2 {\n" + "\n" + "  /*@ public model Stack theStack;\n" + "    @ public initially theStack != null && theStack.isEmpty();\n" + "    @*/\n" + "  //@ public invariant theStack != null;\n" + "\n" + "  public abstract void pop( );\n" + "\n" + "  public abstract void push(Object x);\n" + "\n" + "  public abstract Object top( );\n" + "}\n", "");
    }

    public void test_Entry() {
        if (testIsDisabled("Need to fix nullities and generics")) return;
        compile("Entry.java", "// @(#)$Id: Entry.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Table entries, which are pairs of an index and a value.  These are\n" + " * both JMLType objects.\n" + " * @author Gary T. Leavens\n" + " * @author Albert L. Baker\n" + " */\n" + "import java.util.*;\n" + "public /*@ pure @*/ interface Entry {\n" + "\n" + "    /** The model of the index of this entry. */\n" + "    //@ public model instance Object index;\n" + "    //@ public initially index != null;\n" + "\n" + "    /** The model of the value of this entry. */\n" + "    //@ public model instance Object value;\n" + "    //@ public initially value != null;\n" + "\n" + "    //@ public instance invariant index != null && value != null;\n" + "  \n" + "    /** Return this entry's index. */\n" + "    /*@ public normal_behavior\n" + "      @     ensures \\result.equals(index);\n" + "      @*/\n" + "    public Object getIndex();\n" + "\n" + "    /** Return this entry's value. */\n" + "    /*@ public normal_behavior\n" + "      @     ensures \\result.equals(value);\n" + "      @*/\n" + "    public Object getValue();\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     requires o instanceof Entry;\n" + "      @     ensures \\result == \n" + "      @       (    ((Entry)o).index.equals(index)\n" + "      @         && ((Entry)o).value.equals(value) );\n" + "      @ also\n" + "      @   public normal_behavior\n" + "      @     requires !(o instanceof Entry);\n" + "      @     ensures \\result == false;\n" + "      @*/\n" + "    public boolean equals(/*@ nullable @*/ Object o);\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     ensures \\result instanceof Entry && \\fresh(\\result)\n" + "      @          && ((Entry)\\result).equals(this);\n" + "      @     ensures_redundantly \\result != this;\n" + "      @*/\n" + "    public Object clone();\n" + "}\n" + "// @(#)$Id: EntryImplementation.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "/** Entries for Tables that map an index to a value.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " */\n" + "/*@ pure @*/ class EntryImplementation implements Entry {\n" + "\n" + "    /** The index stored for this entry. */\n" + "    private /*@ non_null @*/ Object ind;\n" + "\n" + "    /** The value stored for this entry. */\n" + "    private /*@ non_null @*/ Object val;\n" + "\n" + "    /*@  private represents index <- ind; \n" + "      @  private represents value <- val;\n" + "      @*/\n" + "\n" + "    /** Initialize this entry. */\n" + "    /*@ public normal_behavior\n" + "      @   requires ind != null && val != null;\n" + "      @   assignable index, value;\n" + "      @     ensures index != null && value != null && \n" + "      @       index.equals(ind) && value.equals(val);\n" + "      @*/\n" + "    public EntryImplementation(Object ind, Object val) {\n" + "        this.ind = ind;\n" + "        this.val = val;\n" + "    }\n" + "\n" + "    public /*@ non_null @*/ Object getIndex() {\n" + "        return ind;\n" + "    }\n" + "\n" + "    public /*@ non_null @*/ Object getValue() {\n" + "        return val;\n" + "    }\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     requires o instanceof Entry;\n" + "      @     ensures \\result == \n" + "      @       (    ((Entry)o).index.equals(index)\n" + "      @         && ((Entry)o).value.equals(value) );\n" + "      @ also\n" + "      @   public normal_behavior\n" + "      @     requires !(o instanceof Entry);\n" + "      @     ensures \\result == false;\n" + "      @*/\n" + "    public boolean equals(/*@ nullable @*/ Object o) {\n" + "        if (o == null || !(o instanceof EntryImplementation)) {\n" + "            return false;\n" + "        }\n" + "        return ((EntryImplementation)o).ind.equals(ind)\n" + "            && ((EntryImplementation)o).val.equals(val);\n" + "    }\n" + "\n" + "    public int hashCode() {\n" + "        return ind.hashCode() + val.hashCode();\n" + "    }\n" + "\n" + "    /*@ also\n" + "      @   public normal_behavior\n" + "      @     ensures \\result instanceof Entry && \\fresh(\\result)\n" + "      @          && ((Entry)\\result).equals(this);\n" + "      @     ensures_redundantly \\result != this;\n" + "      @*/\n" + "    public Object clone() {\n" + "        return new EntryImplementation(ind, val);\n" + "    }\n" + "}\n" + "// @(#)$Id: Table.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "/** Tables are finite maps from indexes to values.\n" + " * @author Gary T. Leavens\n" + " * @author Albert L. Baker\n" + " */\n" + "interface Table {\n" + "\n" + "    /** The model of the entries (rows) in the table. */\n" + "    /*@ public model instance Set entries;\n" + "      @ public initially entries != null && entries.isEmpty();\n" + "      @*/\n" + "\n" + "    /*@ public instance invariant entries != null\n" + "      @   && (\\forall Object e; entries.contains(e); e instanceof Entry);\n" + "      @*/\n" + "\n" + "    /*@ public instance invariant\n" + "      @   (\\forall Entry e1; entries.contains(e1);\n" + "      @     (\\forall Entry e2; entries.contains(e2) && !(e1.equals(e2));\n" + "      @       true ) ); \n" + "      @*/\n" + "\n" + "    /** Is the given index used in the table? */\n" + "    /*@ public normal_behavior\n" + "      @    requires d != null;\n" + "      @    ensures \\result <==>\n" + "      @      (\\exists Entry e; entries.contains(e) && e != null; true);\n" + "      @*/\n" + "    /*@ pure @*/ boolean isUsedIndex(Object d);\n" + "\n" + "    /** Add the given entry to this table. */\n" + "    /*@ public normal_behavior\n" + "      @    requires e != null && !isUsedIndex(e.index);\n" + "      @    assignable entries;\n" + "      @    ensures entries.equals(\\old(entries.add(e)));\n" + "      @*/\n" + "    void addEntry(Entry e);\n" + " \n" + "    /** Take out the given entry from this table. */\n" + "    /*@ public normal_behavior\n" + "      @    requires d != null;\n" + "      @    assignable entries;\n" + "      @*/\n" + "    void removeEntry(Object d);\n" + " \n" + "    /** Return the value at the given index. */\n" + "    /*@ public normal_behavior\n" + "      @    requires isUsedIndex(d);\n" + "      @    assignable entries;\n" + "      @    ensures \\fresh(\\result)\n" + "      @      && (\\exists Entry e; entries.contains(e);\n" + "      @             true && \\result.equals(e.value));\n" + "      @*/\n" + "    Object mapTo(Object d);\n" + "}\n" + "// @(#)$Id: TableImplementation.java 1199 2009-02-17 19:42:32Z smshaner $\n" + "\n" + "// Copyright (C) 1998, 1999 Iowa State University\n" + "\n" + "// This file is part of JML\n" + "\n" + "// JML is free software; you can redistribute it and/or modify\n" + "// it under the terms of the GNU General Public License as published by\n" + "// the Free Software Foundation; either version 2, or (at your option)\n" + "// any later version.\n" + "\n" + "// JML is distributed in the hope that it will be useful,\n" + "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" + "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" + "// GNU General Public License for more details.\n" + "\n" + "// You should have received a copy of the GNU General Public License\n" + "// along with JML; see the file COPYING.  If not, write to\n" + "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n" + "\n" + "\n" + "/** An implementation of the Table interface.\n" + " * @author Katie Becker\n" + " * @author Gary T. Leavens\n" + " */\n" + "class TableImplementation implements Table {\n" + "\n" + "    /** The representation of this Table. */\n" + "    private /*@ non_null @*/ Hashtable table;\n" + "\n" + "\n" + "    /** Initialize this Table to contain the empty set of entries. */\n" + "    /*@ public normal_behavior\n" + "      @   assignable entries;\n" + "      @    ensures entries != null && entries.isEmpty();\n" + "      @ implies_that\n" + "      @   private normal_behavior\n" + "      @     assignable entries, table;\n" + "      @     ensures table != null;\n" + "      @*/\n" + "    public TableImplementation() {\n" + "        table = new Hashtable();\n" + "    }\n" + "\n" + "    public /*@ pure @*/ boolean isUsedIndex(Object d) {\n" + "        return table.containsKey(d);\n" + "    }\n" + "\n" + "    public void addEntry(Entry en) {\n" + "        table.put(en.getIndex(), en.getValue());\n" + "    }\n" + "\n" + "    public void removeEntry(Object d) {\n" + "        table.remove(d);\n" + "    }\n" + " \n" + "    public Object mapTo(Object d){\n" + "        return (Object)table.get(d);\n" + "    }\n" + " \n" + "    public String toString() {\n" + "        return table.toString();\n" + "    }\n" + "}  \n" + "\n" + "\n");
    }
}
