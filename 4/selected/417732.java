package com.koutra.dist.proc.sink;

import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import org.apache.log4j.Logger;
import com.koutra.dist.proc.model.ContentType;
import com.koutra.dist.proc.model.IFaucet;
import com.koutra.dist.proc.model.IPipelineItem;
import com.koutra.dist.proc.model.XformationException;

/**
 * A writer mux sink consumes a sequence of character streams generated by a
 * template item and stores them into a file concatenated one after the other.
 * The user specifies the file in their local file system and the character set
 * encoding to use.
 * 
 * @author Pafsanias Ftakas
 */
public class WriterMuxSink extends AbstractFileOrStreamMuxSink {

    private static final Logger logger = Logger.getLogger(WriterMuxSink.class);

    protected static class DequePayload {

        public IFaucet faucet;

        public Reader reader;

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof DequePayload)) return false;
            DequePayload other = (DequePayload) obj;
            if (reader == null && other.reader != null) return false;
            return faucet.equals(other.faucet) && reader.equals(other.reader);
        }
    }

    protected BlockingDeque<DequePayload> deque;

    protected Writer writer;

    protected String outputCharset;

    /**
	 * @deprecated Use any of the initializing constructors instead.
	 */
    public WriterMuxSink() {
    }

    /**
	 * Initializing constructor for the Stream type.
	 * @param id the ID of the sink.
	 * @param writer the output stream to write to.
	 */
    public WriterMuxSink(String id, Writer writer) {
        super(id);
        this.deque = new LinkedBlockingDeque<DequePayload>();
        this.writer = writer;
        this.outputCharset = null;
    }

    /**
	 * Initializing constructor for the File type.
	 * @param id the ID of the sink.
	 * @param path the path to the file to write to.
	 * @param outputCharset the charset to use when reading characters from the file
	 */
    public WriterMuxSink(String id, String path, String outputCharset) {
        super(id, path);
        this.deque = new LinkedBlockingDeque<DequePayload>();
        this.writer = null;
        this.outputCharset = outputCharset;
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 * 
	 * @param contentType the type that we want this sink to support.
	 * @return true iff this sink supports the content type argument.
	 */
    @Override
    public boolean supportsInput(ContentType contentType) {
        switch(contentType) {
            case CharStream:
                return true;
            case ByteStream:
            case XML:
            case ResultSet:
            default:
                return false;
        }
    }

    /**
	 * Override the implementation in the abstract sink to add a check that the faucet
	 * supports the proper content type.
	 */
    @Override
    protected void checkFaucetValidity(IFaucet faucet) {
        super.checkFaucetValidity(faucet);
        if (!faucet.supportsOutput(ContentType.CharStream)) throw new IllegalArgumentException("Faucet '" + faucet.getId() + "' must support the CharStream content type.");
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public void registerSource(Object source) {
        Reader reader = (Reader) source;
        DequePayload payload = new DequePayload();
        payload.faucet = faucet;
        payload.reader = reader;
        if (deque.contains(payload)) return;
        if (logger.isTraceEnabled()) logger.trace("Registering reader: " + reader + " with the mux deque");
        while (true) {
            try {
                deque.putLast(payload);
                break;
            } catch (InterruptedException e) {
            }
        }
        if (reader != null) {
            if (faucet instanceof IPipelineItem) {
                ((IPipelineItem) faucet).consume(this);
            }
        }
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public String dumpPipeline() {
        DequePayload payload = deque.peekFirst();
        return getClass().getName() + ": " + (payload == null ? null : payload.reader) + "->" + writer;
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public void dispose() {
        switch(type) {
            case File:
                try {
                    writer.close();
                } catch (IOException e) {
                    throw new XformationException("Unable to close writer", e);
                }
                break;
            case Stream:
                break;
        }
    }

    /**
	 * Implementation of the <code>ISink</code> interface.
	 */
    @Override
    public void consume() {
        if (!hookedUp && faucetTemplate == null) throw new XformationException("Sink has not been set up correctly: " + "faucet has not been set");
        switch(type) {
            case File:
                try {
                    if (outputCharset == null) writer = new BufferedWriter(new FileWriter(path)); else writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(path), outputCharset));
                } catch (IOException e) {
                    throw new XformationException("Unable to create output writer", e);
                }
                break;
            case Stream:
                break;
        }
        if (!hookedUp) {
            if (faucetTemplate instanceof IPipelineItem) {
                ((IPipelineItem) faucetTemplate).consume(this);
            }
        }
        try {
            int count;
            char[] buffer = new char[8 * 1024];
            while (true) {
                DequePayload payload = null;
                try {
                    payload = deque.takeFirst();
                } catch (InterruptedException ie) {
                }
                if (payload == null) break;
                IFaucet faucet = payload.faucet;
                Reader reader = payload.reader;
                if (logger.isTraceEnabled()) logger.trace("Removed reader: " + reader + " from the deque.");
                if (reader == null) break;
                if (logger.isTraceEnabled()) logger.trace("Using the reader " + reader + " in the mux sink");
                while ((count = reader.read(buffer)) != -1) {
                    if (logger.isTraceEnabled()) logger.trace("Read '" + new String(buffer, 0, count) + "' from reader " + reader + " in the mux sink");
                    writer.write(buffer, 0, count);
                }
                faucet.dispose();
            }
            writer.close();
            faucetTemplate.dispose();
        } catch (IOException ioe) {
            throw new XformationException("Unable to transform char stream", ioe);
        }
    }

    /**
	 * Override the <code>Streamable</code> implementation in order to deserialize
	 * local members.
	 */
    @Override
    public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {
        super.readFrom(in);
        this.deque = new LinkedBlockingDeque<DequePayload>();
        this.writer = null;
        this.outputCharset = in.readUTF();
    }

    /**
	 * Override the <code>Streamable</code> implementation in order to serialize
	 * local members.
	 */
    @Override
    public void writeTo(DataOutputStream out) throws IOException {
        super.writeTo(out);
        out.writeUTF(outputCharset);
    }
}
