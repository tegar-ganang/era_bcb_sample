package org.wwweeeportal.portal;

import java.io.*;
import java.net.*;
import java.nio.charset.*;
import java.security.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;
import java.util.logging.*;
import java.util.regex.*;
import javax.activation.*;
import javax.xml.transform.*;
import org.w3c.dom.*;
import javax.ws.rs.*;
import javax.ws.rs.core.*;
import org.springframework.core.convert.converter.*;
import org.wwweeeportal.util.*;
import org.wwweeeportal.util.collection.*;
import org.wwweeeportal.util.concurrent.*;
import org.wwweeeportal.util.convert.*;
import org.wwweeeportal.util.io.*;
import org.wwweeeportal.util.logging.*;
import org.wwweeeportal.util.security.*;
import org.wwweeeportal.util.xml.dom.*;
import org.wwweeeportal.util.xml.html.*;
import org.wwweeeportal.util.xml.transform.*;
import org.wwweeeportal.util.ws.rs.*;
import org.wwweeeportal.util.ws.rs.annotation.*;
import org.wwweeeportal.util.ws.rs.concurrent.*;

/**
 * <p>
 * The runtime instance object responsible for using a {@linkplain ContentManager.PageDefinition page definition} to
 * instantiate the corresponding {@link Channel} instances and
 * {@linkplain #doViewRequest(Request, UriInfo, SecurityContext, HttpHeaders, Map, Map, DataSource, ContentManager.ChannelSpecification.Key)
 * aggregate} their content together into a single web page {@link Response} to clients.
 * </p>
 * 
 * <p>
 * Each page within the portal is identified by a unique {@linkplain ContentManager.PageDefinition.Key key}. As requests
 * arrive to the portal, the JAX-RS framework will first route them to the {@link ContentManager} (root resource class),
 * which will {@linkplain ContentManager#getPage(String, String, String, UriInfo, SecurityContext, HttpHeaders)
 * determine} the key and then associated {@linkplain ContentManager.PageDefinition page definition} being requested,
 * and use that to {@linkplain ContentManager.PageDefinition#newInstance(WWWeeePortal) instantiate} this class. JAX-RS
 * will then either {@linkplain #getChannel(String) retrieve} and hand off the request to a {@link Channel}
 * sub-resource, if one was targeted, or render the
 * {@linkplain #doViewGetRequest(Request, UriInfo, SecurityContext, HttpHeaders, Map, Map) page view} by default. The
 * <code>Page</code> itself can only handle <code>GET</code> requests, any <code>POST</code> request <em>must</em>
 * {@linkplain #getChannel(String) target} a specific {@link Channel} sub-resource.
 * </p>
 * 
 * <p>
 * Although transformations can be used to emit any type of XML, every <code>Page</code> generates XHTML5 as it's native
 * output format. The <code>Page</code> content basically consists the the document fragments provided by each
 * {@link Channel}, appended in order, one after the other. WWWeee-Portal attempts to minimize the amount of markup
 * generated by the portal itself, and in it's normal configuration, does not emit <em>any</em> markup elements which
 * have any visual presentation associated with them by default. The <code>Page</code> <code>&lt;body&gt;</code> element
 * will contain a child <code>&lt;div&gt;</code> element for each {@linkplain ContentManager.ChannelGroupDefinition
 * channel group}, and those will, in turn, contain a child {@link Channel.ViewResponse#getResponseRootElement() root}
 * element for each {@link Channel} (see there for markup details).
 * </p>
 * 
 * <h3 id="configuration">Configuration</h3>
 * <p>
 * The following {@linkplain ConfigManager configuration properties} are supported by this class:
 * </p>
 * <ul>
 * <li>{@link #TITLE_TEXT_PROP}</li>
 * <li>{@link #GROUP_TITLE_TEXT_PROP}</li>
 * <li>{@link #TITLE_GROUP_TITLE_DISABLE_PROP}</li>
 * <li>{@link #TRANSFORM_BY_NUM_PROP}</li>
 * <li>{@link #LINK_BY_NUM_PROP}</li>
 * <li>{@link #SCRIPT_BY_NUM_PROP}</li>
 * <li>{@link #META_BY_NUM_PROP}</li>
 * <li>{@link #CLASS_BY_NUM_PROP}</li>
 * <li>{@link #CHANNEL_GROUP_CLASS_BY_NUM_PROP}</li>
 * <li>{@link #META_PROP_PUBLISH_ALL_ENABLE_PROP}</li>
 * <li>{@link #META_PROP_PUBLISH_BY_NUM_PROP}</li>
 * <li>{@link #CACHE_CONTROL_DEFAULT_PROP}</li>
 * <li>{@link #UNAUTHORIZED_WWW_AUTHENTICATE_PROP}</li>
 * <li>{@link #ENCODING_PROP}</li>
 * </ul>
 * 
 * @see Channel
 */
public class Page {

    /**
   * The key to a {@link RSProperties#RESULT_STRING_CONVERTER String} property defining the <code>Page</code>
   * {@linkplain #getTitleText(Request) title text}.
   * 
   * @see #getTitleText(Request)
   * @see Channel#TITLE_TEXT_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String TITLE_TEXT_PROP = "Page.Title.Text";

    /**
   * The key to a {@link RSProperties#RESULT_STRING_CONVERTER String} property defining the <code>Page</code>
   * {@linkplain #getGroupTitleText(Request) group title text}.
   * 
   * @see #getGroupTitleText(Request)
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String GROUP_TITLE_TEXT_PROP = "PageGroup.Title.Text";

    /**
   * The key to a {@link RSProperties#RESULT_BOOLEAN_CONVERTER Boolean} property
   * {@linkplain #isGroupTitleDisabled(Request) disabling} inclusion of the {@linkplain #GROUP_TITLE_TEXT_PROP page
   * group title} within the generated <code>Page</code>
   * <code>&lt;html&gt;&lt;head&gt;&lt;{@link #createHeadTitleElement(Request, Element) title}&gt;</code>.
   * 
   * @see #isGroupTitleDisabled(Request)
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String TITLE_GROUP_TITLE_DISABLE_PROP = "Page.Title.GroupTitle.Disable";

    /**
   * <p>
   * The prefix defining an ordered set of numbered keys to
   * {@linkplain ConfigManager#getResourcePropURLConverter(boolean) resource path} property values, each
   * {@linkplain TransformUtil#URL_TEMPLATES_CONVERTER pointing to an XSLT transformation}, which will be applied, in
   * order, to the final <code>Page</code> output.
   * </p>
   * 
   * <p>
   * Note that meta-props for the {@linkplain Request#getMetaProps(Map) request},
   * {@linkplain WWWeeePortal#getMetaProps(Map, SecurityContext, HttpHeaders) portal}, and
   * {@linkplain #getMetaProps(Request, Map) page} will all be made available as
   * {@linkplain Transformer#setParameter(String, Object) transformation parameters}.
   * </p>
   * 
   * @see #getTransformations(Request)
   * @see MarkupManager#getTransformByNumPropConverter()
   * @see org.wwweeeportal.portal.channelplugins.ChannelTransformer#VIEW_TRANSFORM_BY_NUM_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String TRANSFORM_BY_NUM_PROP = "Page.Transform.Num.";

    /**
   * @see #TRANSFORM_BY_NUM_PROP
   * @see #getTransformations(Request)
   */
    protected static final Pattern TRANSFORM_BY_NUM_PATTERN = Pattern.compile("^" + Pattern.quote(TRANSFORM_BY_NUM_PROP) + ".*");

    /**
   * The prefix defining an ordered set of numbered keys to
   * {@linkplain MarkupManager#PROP_RESULT_LINK_ELEMENT_CONVERTER query encoded} property values, each specifying a
   * <code>&lt;link&gt;</code> element to be added, in order, to the <code>Page</code>
   * <code>&lt;html&gt;&lt;head&gt;</code>. Any non-{@linkplain URI#isAbsolute() absolute} URI attributes will be
   * {@linkplain MarkupManager#resolveMetaLinkElementContextResources(Element, UriInfo) resolved}.
   * 
   * @see #getMetaLinkElements(Request)
   * @see #createHeadMetaElements(Request, Element, Map)
   * @see MarkupManager#PROP_RESULT_LINK_ELEMENT_CONVERTER
   * @see Channel#LINK_BY_NUM_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String LINK_BY_NUM_PROP = "Page.Link.Num.";

    /**
   * @see #LINK_BY_NUM_PROP
   * @see #getMetaLinkElements(Request)
   * @see #createHeadMetaElements(Request, Element, Map)
   */
    protected static final Pattern LINK_BY_NUM_PATTERN = Pattern.compile("^" + Pattern.quote(LINK_BY_NUM_PROP) + ".*");

    /**
   * The prefix defining an ordered set of numbered keys to
   * {@linkplain MarkupManager#PROP_RESULT_SCRIPT_ELEMENT_CONVERTER query encoded} property values, each specifying a
   * <code>&lt;script&gt;</code> element to be added, in order, to the <code>Page</code>
   * <code>&lt;html&gt;&lt;head&gt;</code>. Any non-{@linkplain URI#isAbsolute() absolute} URI attributes will be
   * {@linkplain MarkupManager#resolveMetaScriptElementContextResources(Element, UriInfo) resolved}.
   * 
   * @see #getMetaScriptElements(Request)
   * @see #createHeadMetaElements(Request, Element, Map)
   * @see MarkupManager#PROP_RESULT_SCRIPT_ELEMENT_CONVERTER
   * @see Channel#SCRIPT_BY_NUM_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String SCRIPT_BY_NUM_PROP = "Page.Script.Num.";

    /**
   * @see #SCRIPT_BY_NUM_PROP
   * @see #getMetaScriptElements(Request)
   * @see #createHeadMetaElements(Request, Element, Map)
   */
    protected static final Pattern SCRIPT_BY_NUM_PATTERN = Pattern.compile("^" + Pattern.quote(SCRIPT_BY_NUM_PROP) + ".*");

    /**
   * The prefix defining an ordered set of numbered keys to
   * {@linkplain MarkupManager#PROP_RESULT_META_ELEMENT_CONVERTER query encoded} property values, each specifying a
   * <code>&lt;meta&gt;</code> element to be added, in order, to the <code>Page</code>
   * <code>&lt;html&gt;&lt;head&gt;</code>. Any non-{@linkplain URI#isAbsolute() absolute} URI attributes will be
   * {@linkplain MarkupManager#resolveMetaMetaElementContextResources(Element, UriInfo) resolved}.
   * 
   * @see #getMetaMetaElements(Request)
   * @see #createHeadMetaElements(Request, Element, Map)
   * @see MarkupManager#PROP_RESULT_META_ELEMENT_CONVERTER
   * @see Channel#META_BY_NUM_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String META_BY_NUM_PROP = "Page.Meta.Num.";

    /**
   * @see #META_BY_NUM_PROP
   * @see #getMetaMetaElements(Request)
   * @see #createHeadMetaElements(Request, Element, Map)
   */
    protected static final Pattern META_BY_NUM_PATTERN = Pattern.compile("^" + Pattern.quote(META_BY_NUM_PROP) + ".*");

    /**
   * The prefix defining an ordered set of numbered keys to {@link RSProperties#RESULT_STRING_CONVERTER String} property
   * values to be added to the <code>class</code> attribute on the <code>Page</code>
   * <code>&lt;html&gt;&lt;body&gt;</code> Element.
   * 
   * @see #CHANNEL_GROUP_CLASS_BY_NUM_PROP
   * @see Channel#CLASS_BY_NUM_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String CLASS_BY_NUM_PROP = "Page.Class.Num.";

    /**
   * @see #CLASS_BY_NUM_PROP
   */
    protected static final Pattern CLASS_BY_NUM_PATTERN = Pattern.compile("^" + Pattern.quote(CLASS_BY_NUM_PROP) + ".*");

    /**
   * The prefix defining an ordered set of numbered keys to {@link RSProperties#RESULT_STRING_CONVERTER String} property
   * values to be added to the <code>class</code> attribute on the {@linkplain ContentManager.ChannelGroupDefinition
   * channel group} <code>&lt;div&gt;</code> Element.
   * 
   * @see #CLASS_BY_NUM_PROP
   * @see Channel#CLASS_BY_NUM_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String CHANNEL_GROUP_CLASS_BY_NUM_PROP = "ChannelGroup.Class.Num.";

    /**
   * @see #CHANNEL_GROUP_CLASS_BY_NUM_PROP
   */
    protected static final Pattern CHANNEL_GROUP_CLASS_BY_NUM_PATTERN = Pattern.compile("^" + Pattern.quote(CHANNEL_GROUP_CLASS_BY_NUM_PROP) + ".*");

    /**
   * The key to a {@link RSProperties#RESULT_BOOLEAN_CONVERTER Boolean} property enabling the publishing of <em>all</em>
   * {@linkplain Request#getMetaProps(Map) request},
   * {@linkplain WWWeeePortal#getMetaProps(Map, SecurityContext, HttpHeaders) portal}, and
   * {@linkplain #getMetaProps(Request, Map) page} &quot;meta-props&quot; as <code>&lt;meta&gt;</code> elements in the
   * <code>Page</code> <code>&lt;html&gt;&lt;head&gt;</code>.
   * 
   * @see #createHeadMetaElements(Request, Element, Map)
   * @see Request#getMetaProps(Map)
   * @see WWWeeePortal#getMetaProps(Map, SecurityContext, HttpHeaders)
   * @see #getMetaProps(Request, Map)
   * @see #META_PROP_PUBLISH_BY_NUM_PROP
   * @see org.wwweeeportal.portal.channelplugins.ChannelMetaProps#PUBLISH_ALL_ENABLE_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String META_PROP_PUBLISH_ALL_ENABLE_PROP = "Page.Meta.PropPublish.All.Enable";

    /**
   * The prefix defining an ordered set of numbered keys to {@link RSProperties#RESULT_STRING_CONVERTER String} property
   * values, each in turn specifying the key to a {@linkplain Request#getMetaProps(Map) request},
   * {@linkplain WWWeeePortal#getMetaProps(Map, SecurityContext, HttpHeaders) portal}, or
   * {@linkplain #getMetaProps(Request, Map) page} &quot;meta-prop&quot;, which should be published as a
   * <code>&lt;meta&gt;</code> element in the <code>Page</code> <code>&lt;html&gt;&lt;head&gt;</code>.
   * 
   * @see #createHeadMetaElements(Request, Element, Map)
   * @see Request#getMetaProps(Map)
   * @see WWWeeePortal#getMetaProps(Map, SecurityContext, HttpHeaders)
   * @see #getMetaProps(Request, Map)
   * @see #META_PROP_PUBLISH_ALL_ENABLE_PROP
   * @see org.wwweeeportal.portal.channelplugins.ChannelMetaProps#PUBLISH_BY_NUM_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String META_PROP_PUBLISH_BY_NUM_PROP = "Page.Meta.PropPublish.Num.";

    /**
   * @see #META_PROP_PUBLISH_BY_NUM_PROP
   */
    protected static final Pattern META_PROP_PUBLISH_BY_NUM_PATTERN = Pattern.compile("^" + Pattern.quote(META_PROP_PUBLISH_BY_NUM_PROP) + ".*");

    /**
   * The key to a {@link RSProperties#RESULT_STRING_CONVERTER String} property defining the default value of the
   * {@link CacheControl} response header to be used for the <code>Page</code>. This default value will be used a
   * starting point which is then modified based on the {@linkplain Channel.ViewResponse#getCacheControl() channel
   * cache-control} values.
   * 
   * @see #getCacheControlDefault(Request)
   * @see Channel#CACHE_CONTROL_DEFAULT_PROP
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String CACHE_CONTROL_DEFAULT_PROP = "Page.CacheControl.Default";

    /**
   * The key to a {@link RSProperties#RESULT_STRING_CONVERTER String} property defining the value of the &quot;
   * <code>WWW-Authenticate</code>&quot; {@linkplain javax.ws.rs.core.Response.ResponseBuilder#header(String, Object)
   * header} to be returned as part of the {@linkplain javax.ws.rs.core.Response.Status#UNAUTHORIZED unauthorized}
   * response when a client requests content for which they don't have
   * {@linkplain ContentManager.AbstractContentDefinition#getAccessControl() access}.
   * 
   * @see Request#createNoAccessResponse(RSProperties)
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String UNAUTHORIZED_WWW_AUTHENTICATE_PROP = "Page.Auth.WWW-Authenticate";

    /**
   * The key to a {@link RSProperties#RESULT_CHARSET_CONVERTER Charset} property naming the
   * {@linkplain org.wwweeeportal.util.xml.transform.TransformableDocument#setEncoding(Charset) encoding} to be used by
   * this <code>Page</code> instance. If this property is not set then the {@linkplain #DEFAULT_ENCODING default} will
   * be used.
   * 
   * @see #DEFAULT_ENCODING
   * @category WWWEEE_PORTAL_CONFIG_PROP
   */
    public static final String ENCODING_PROP = "Page.Encoding";

    /**
   * The default (&quot;<code>{@link IOUtil#UTF_8_CHARSET UTF-8}</code>&quot;) {@linkplain Charset character encoding}
   * to be {@linkplain org.wwweeeportal.util.xml.transform.TransformableDocument#setEncoding(Charset) used} by this
   * <code>Page</code> instance if no explicit {@linkplain #ENCODING_PROP property} is set.
   * 
   * @see #ENCODING_PROP
   */
    public static final Charset DEFAULT_ENCODING = IOUtil.UTF_8_CHARSET;

    /**
   * The {@link WWWeeePortal} instance hosting this <code>Page</code>.
   * 
   * @see #getPortal()
   */
    protected final WWWeeePortal portal;

    /**
   * The {@linkplain ContentManager.PageDefinition definition} for this <code>Page</code>.
   * 
   * @see #getDefinition()
   */
    protected final ContentManager.PageDefinition<?> definition;

    /**
   * The {@link Channel} instances belonging to this <code>Page</code>.
   * 
   * @see #getChannels()
   */
    protected final List<Channel> channels;

    /**
   * All client requests to this <code>Page</code> instance are required to hold a
   * {@linkplain ReentrantReadWriteLock#readLock() read lock} on this object. If a {@link ContentManager.ContentStore
   * ContentStore} wishes to take this <code>Page</code> instance out of service, it should first stop issuing requests
   * to the <code>Page</code>, and then call the {@link #destroy()} method, which will first block until it acquires a
   * {@linkplain ReentrantReadWriteLock#writeLock() write lock} on this object, guaranteeing that there are no longer
   * any active requests.
   * 
   * @see #destroy()
   */
    protected final ReentrantReadWriteLock activeRequestLock = new ReentrantReadWriteLock(true);

    /**
   * Has this <code>Page</code> been {@linkplain #init() initialized} to accept client requests?
   * 
   * @see #init()
   */
    protected volatile boolean initialized = false;

    /**
   * Construct a new <code>Page</code> instance.
   * 
   * @param portal The {@link #getPortal() WWWeeePortal} instance hosting this <code>Page</code>.
   * @param definition The {@linkplain #getDefinition() definition} for this <code>Page</code>.
   * @throws IllegalArgumentException If <code>portal</code> or <code>definition</code> were <code>null</code>.
   * @throws WWWeeePortal.Exception If there was a problem during instantiation.
   */
    public Page(final WWWeeePortal portal, final ContentManager.PageDefinition<?> definition) throws IllegalArgumentException, WWWeeePortal.Exception {
        if (portal == null) throw new IllegalArgumentException("null portal");
        if (definition == null) throw new IllegalArgumentException("null definition");
        if (!definition.isInitialized()) throw new IllegalStateException("Attempt to instantiate Page from uninitialized definition");
        this.portal = portal;
        this.definition = definition;
        channels = portal.getContentManager().constructChannels(this);
        return;
    }

    /**
   * Get the {@link WWWeeePortal} instance hosting this <code>Page</code>.
   */
    public final WWWeeePortal getPortal() {
        return portal;
    }

    /**
   * Get the {@linkplain ContentManager.PageDefinition definition} for this <code>Page</code>.
   */
    public final ContentManager.PageDefinition<?> getDefinition() {
        return definition;
    }

    /**
   * Get the {@linkplain ContentManager.PageGroupDefinition group definition} containing this <code>Page</code>.
   */
    public final ContentManager.PageGroupDefinition getPageGroupDefinition() {
        return definition.getParentDefinition();
    }

    /**
   * Get the {@linkplain ContentManager.PageDefinition.Key key} for this <code>Page</code>.
   */
    public final ContentManager.PageDefinition.Key getKey() {
        return definition.getKey();
    }

    /**
   * Get the {@link Channel} instances belonging to this <code>Page</code>.
   */
    public final List<Channel> getChannels() {
        return channels;
    }

    /**
   * <p>
   * Get the {@link Channel} instance for the specified
   * {@linkplain ContentManager.ChannelSpecification.Key#getChannelID() ID}.
   * </p>
   * 
   * <p>
   * Being the JAX-RS sub-resource method used to access any {@link Channel} instance, every client request targeting a
   * specific {@linkplain ContentManager.ChannelSpecification.Key channel key} will come through this method first,
   * before being routed onward through the returned {@link Channel} resource.
   * </p>
   * 
   * @see #getChannel(ContentManager.ChannelSpecification.Key)
   */
    @Path("/{ChannelID}/")
    public final Channel getChannel(@PathParam("ChannelID") final String channelID) {
        if (channelID == null) return null;
        if (channels != null) {
            for (Channel channel : channels) {
                if ((channel == null) || (!channel.getDefinition().getID().equals(channelID))) continue;
                return channel;
            }
        }
        return null;
    }

    /**
   * Get the {@link Channel} instance for the specified {@link ContentManager.ChannelSpecification.Key Key}.
   */
    public final Channel getChannel(final ContentManager.ChannelSpecification.Key channelKey) {
        return (channelKey != null) ? getChannel(channelKey.getChannelID()) : null;
    }

    /**
   * {@linkplain ConfigManager#getConfigProp(RSProperties, String, SecurityContext, HttpHeaders, RSProperties.Entry, Converter, Object, boolean, boolean)
   * Get} the {@linkplain ContentManager.PageDefinition#getProperties() page property} matching the specified criteria.
   * 
   * @see ConfigManager#getConfigProp(RSProperties, String, SecurityContext, HttpHeaders, RSProperties.Entry, Converter,
   * Object, boolean, boolean)
   */
    public final <V> V getConfigProp(final String key, final Request request, final Converter<RSProperties.Result, V> resultConverter, final V defaultConvertedValue, final boolean cacheValue, final boolean optional) throws IllegalArgumentException, ConfigManager.ConfigException {
        return ConfigManager.getConfigProp(definition.getProperties(), key, (request != null) ? request.getSecurityContext() : null, (request != null) ? request.getHttpHeaders() : null, null, resultConverter, defaultConvertedValue, cacheValue, optional);
    }

    /**
   * {@linkplain #getConfigProp(String, Request, Converter, Object, boolean, boolean) Get} the
   * {@linkplain ContentManager.PageDefinition#getProperties() page property} matching the specified criteria as a
   * {@link RSProperties#RESULT_STRING_CONVERTER String}.
   * 
   * @see #getConfigProp(String, Request, Converter, Object, boolean, boolean)
   */
    public final String getConfigProp(final String key, final Request request, final String defaultConvertedValue, final boolean optional) throws IllegalArgumentException, ConfigManager.ConfigException {
        return getConfigProp(key, request, RSProperties.RESULT_STRING_CONVERTER, defaultConvertedValue, false, optional);
    }

    /**
   * <p>
   * Get the title text String for this <code>Page</code>.
   * </p>
   * 
   * <p>
   * This value will normally be displayed as part of each generated <code>Page</code>
   * <code>&lt;html&gt;&lt;head&gt;&lt;{@link #createHeadTitleElement(Page.Request, Element) title}&gt;</code> element,
   * and also possibly within the <code>Page</code> content as part of any configured
   * {@linkplain org.wwweeeportal.portal.channels.PageHeadingChannel page heading} or
   * {@linkplain org.wwweeeportal.portal.channels.SiteNavigationChannel site navigation}.
   * </p>
   * 
   * @see #TITLE_TEXT_PROP
   */
    public String getTitleText(final Request request) throws ConfigManager.ConfigException {
        return getConfigProp(TITLE_TEXT_PROP, request, getKey().getPageID(), false);
    }

    /**
   * <p>
   * Get the title text String for this <code>Page</code>'s <em>{@linkplain #getPageGroupDefinition() group}</em>.
   * </p>
   * 
   * <p>
   * This value will be normally be displayed as part of each generated <code>Page</code>
   * <code>&lt;html&gt;&lt;head&gt;&lt;{@link #createHeadTitleElement(Page.Request, Element) title}&gt;</code> element
   * (unless {@linkplain #isGroupTitleDisabled(Request) disabled}), and also possibly within the <code>Page</code>
   * content as part of any configured {@linkplain org.wwweeeportal.portal.channels.PageHeadingChannel page heading} or
   * {@linkplain org.wwweeeportal.portal.channels.SiteNavigationChannel site navigation}.
   * </p>
   * 
   * @see #GROUP_TITLE_TEXT_PROP
   */
    public String getGroupTitleText(final Request request) throws ConfigManager.ConfigException {
        return getConfigProp(GROUP_TITLE_TEXT_PROP, request, getKey().getPageGroupID(), false);
    }

    /**
   * Should the {@linkplain #getGroupTitleText(Request) page group title text} be displayed within the <code>Page</code>
   * <code>&lt;html&gt;&lt;head&gt;&lt;{@link #createHeadTitleElement(Page.Request, Element) title}&gt;</code> element?
   * 
   * @see #TITLE_GROUP_TITLE_DISABLE_PROP
   * @see #getGroupTitleText(Request)
   */
    public boolean isGroupTitleDisabled(final Request request) throws ConfigManager.ConfigException {
        return getConfigProp(TITLE_GROUP_TITLE_DISABLE_PROP, request, RSProperties.RESULT_BOOLEAN_CONVERTER, Boolean.FALSE, false, false).booleanValue();
    }

    /**
   * @see #CACHE_CONTROL_DEFAULT_PROP
   */
    protected CacheControl getCacheControlDefault(final Request request) throws ConfigManager.ConfigException {
        return getConfigProp(CACHE_CONTROL_DEFAULT_PROP, request, RSProperties.RESULT_CACHE_CONTROL_CONVERTER, null, true, true);
    }

    /**
   * {@linkplain Logger#getLogger(String) Get} the {@link Logger} for this <code>Page</code> instance.
   * 
   * @return The {@link Logger} for this <code>Page</code> instance.
   * @see Logger#getLogger(String)
   */
    protected final Logger getLogger() {
        return Logger.getLogger(getClass().getName());
    }

    /**
   * Put this <code>Page</code> into a state where it is prepared to accept client requests.
   * 
   * @param logMessage A {@linkplain org.wwweeeportal.util.logging.LogAnnotation.Message message} which will be
   * {@linkplain LogAnnotation#log(Logger, LogAnnotation.Message, Class, Throwable) logged} ({@link Level#FINER}) after
   * initialization, which can be
   * {@linkplain LogAnnotation#annotate(LogAnnotation.Message, String, Object, Level, boolean) annotated} with any
   * informational notices the implementation wishes to have recorded in that log message.
   * @see #init()
   */
    protected void initInternal(final LogAnnotation.Message logMessage) throws WWWeeePortal.Exception {
        for (Channel channel : CollectionUtil.mkNotNull(channels)) {
            if (!(channel.getDefinition() instanceof ContentManager.LocalChannelDefinition<?>)) continue;
            channel.init();
        }
        return;
    }

    /**
   * <p>
   * Put this <code>Page</code> into a state where it is prepared to accept client requests.
   * </p>
   * 
   * <p>
   * This method must be called prior to any client requests being routed to the <code>Page</code>, and will
   * {@linkplain Channel#init() initialize} each of it's {@link Channel} instances. This method follows the same
   * semantics as {@link ContentManager#init()} .
   * </p>
   * 
   * @see Channel#init()
   * @see #destroy()
   * @see ContentManager#init()
   */
    public final void init() throws WWWeeePortal.Exception {
        final LogAnnotation.Message logMessage = new LogAnnotation.MessageImpl(Level.FINER, "Initialized Page: " + toString());
        activeRequestLock.writeLock().lock();
        try {
            if (initialized) return;
            try {
                initInternal(logMessage);
                initialized = true;
            } catch (WWWeeePortal.Exception wpe) {
                destroyInternal(wpe);
                throw wpe;
            }
        } finally {
            activeRequestLock.writeLock().unlock();
        }
        LogAnnotation.log(getLogger(), logMessage, getClass(), null);
        return;
    }

    /**
   * Take this <code>Page</code> out of active service.
   * 
   * @param logMessage A {@linkplain org.wwweeeportal.util.logging.LogAnnotation.Message message} which will be
   * {@linkplain LogAnnotation#log(Logger, LogAnnotation.Message, Class, Throwable) logged} ({@link Level#FINER}) after
   * destruction, which can be
   * {@linkplain LogAnnotation#annotate(LogAnnotation.Message, String, Object, Level, boolean) annotated} with any
   * informational notices the implementation wishes to have recorded in that log message.
   * @see #destroy()
   */
    protected void destroyInternal(final LogAnnotation.Message logMessage) {
        for (Channel channel : CollectionUtil.mkNotNull(channels)) {
            if ((channel == null) || (!(channel.getDefinition() instanceof ContentManager.LocalChannelDefinition<?>))) continue;
            try {
                channel.destroy();
            } catch (Exception e) {
            }
        }
        return;
    }

    /**
   * <p>
   * Take this <code>Page</code> out of active service.
   * </p>
   * 
   * <p>
   * This method will first block until all active client requests have been completed, and then
   * {@linkplain Channel#destroy() destroy} each of it's {@link Channel} instances. This method follows the same
   * semantics as {@link ContentManager#destroy()}.
   * </p>
   * 
   * @see Channel#destroy()
   * @see #init()
   * @see ContentManager#destroy()
   */
    public final void destroy() {
        final LogAnnotation.Message logMessage = new LogAnnotation.MessageImpl(Level.FINER, "Destroyed Page: " + toString());
        activeRequestLock.writeLock().lock();
        try {
            initialized = false;
            destroyInternal(logMessage);
        } finally {
            activeRequestLock.writeLock().unlock();
        }
        LogAnnotation.log(getLogger(), logMessage, getClass(), null);
        return;
    }

    /**
   * <p>
   * Populate the supplied <code>metaProps</code> Map with the set of meta-information about this <code>Page</code>.
   * </p>
   * 
   * <p>
   * This method will include information from this <code>Page</code> itself, but also it's
   * {@linkplain ContentManager.PageDefinition#getMetaProps(Page.Request, Map, SecurityContext, HttpHeaders, int)
   * definition}, that of the
   * {@linkplain ContentManager.PageGroupDefinition#getMetaProps(Page.Request, Map, SecurityContext, HttpHeaders, int)
   * page group}, and the
   * {@linkplain ContentManager.PageContentContainer#getMetaProps(Page.Request, Map, SecurityContext, HttpHeaders, int)
   * container}.
   * </p>
   * 
   * <p>
   * The following properties are provided for the <code>Page</code> itself:
   * </p>
   * <dl>
   * <dt><code>WWWeee.Page</code></dt>
   * <dd>The {@link Page} instance.</dd>
   * </dl>
   * 
   * @see ContentManager.PageDefinition#getMetaProps(Page.Request, Map, SecurityContext, HttpHeaders, int)
   * @see ContentManager.PageGroupDefinition#getMetaProps(Page.Request, Map, SecurityContext, HttpHeaders, int)
   * @see ContentManager.PageContentContainer#getMetaProps(Page.Request, Map, SecurityContext, HttpHeaders, int)
   */
    public Map<String, Object> getMetaProps(final Request request, final Map<String, Object> metaProps) throws IllegalArgumentException, ConfigManager.ConfigException {
        if (metaProps == null) throw new IllegalArgumentException("null metaProps");
        definition.getMetaProps(request, metaProps, request.getSecurityContext(), request.getHttpHeaders(), 2);
        metaProps.put("WWWeee.Page", this);
        return metaProps;
    }

    /**
   * @see #TRANSFORM_BY_NUM_PROP
   * @see #TRANSFORM_BY_NUM_PATTERN
   */
    protected Collection<Map.Entry<URL, Templates>> getTransformations(final Request request) throws ConfigManager.ConfigException {
        return ConfigManager.getConfigProps(definition.getProperties(), TRANSFORM_BY_NUM_PATTERN, request.getSecurityContext(), request.getHttpHeaders(), portal.getMarkupManager().getTransformByNumPropConverter(), true, true).values();
    }

    /**
   * @see #LINK_BY_NUM_PROP
   * @see #LINK_BY_NUM_PATTERN
   * @see Channel#getMetaLinkElements(Page.Request)
   */
    protected Collection<Element> getMetaLinkElements(final Request request) throws WWWeeePortal.Exception {
        return ConfigManager.getConfigProps(definition.getProperties(), LINK_BY_NUM_PATTERN, request.getSecurityContext(), request.getHttpHeaders(), MarkupManager.PROP_RESULT_LINK_ELEMENT_CONVERTER, true, true).values();
    }

    /**
   * @see #SCRIPT_BY_NUM_PROP
   * @see #SCRIPT_BY_NUM_PATTERN
   * @see Channel#getMetaScriptElements(Page.Request)
   */
    protected Collection<Element> getMetaScriptElements(final Request request) throws WWWeeePortal.Exception {
        return ConfigManager.getConfigProps(definition.getProperties(), SCRIPT_BY_NUM_PATTERN, request.getSecurityContext(), request.getHttpHeaders(), MarkupManager.PROP_RESULT_SCRIPT_ELEMENT_CONVERTER, true, true).values();
    }

    /**
   * @see #META_BY_NUM_PROP
   * @see #META_BY_NUM_PATTERN
   * @see Channel#getMetaMetaElements(Page.Request)
   */
    protected Collection<Element> getMetaMetaElements(final Request request) throws WWWeeePortal.Exception {
        return ConfigManager.getConfigProps(definition.getProperties(), META_BY_NUM_PATTERN, request.getSecurityContext(), request.getHttpHeaders(), MarkupManager.PROP_RESULT_META_ELEMENT_CONVERTER, true, true).values();
    }

    /**
   * <p>
   * {@linkplain FutureTask#get() Get} the {@link Channel.ViewResponse} from a {@link FutureTask
   * FutureTask&lt;Channel.ViewResponse&gt;} (while translating any exceptions).
   * </p>
   * 
   * <p>
   * It's worth pointing out that, if the supplied <code>channelViewTask</code> was already
   * {@linkplain FutureTask#run() run} (by this or another thread), then this call will simply return the already
   * calculated response, or block until it becomes available (when the other thread completes the task). If the task
   * has <em>not</em> yet been run (ie, if portal threading is {@linkplain WWWeeePortal#isThreadingDisabled() disabled}
   * ), then this call <em>will</em> perform the task in the current thread and return the calculated response.
   * </p>
   * 
   * @see FutureTask#get()
   */
    public static final Channel.ViewResponse getChannelViewResponse(final FutureTask<Channel.ViewResponse> channelViewTask) throws WWWeeePortal.Exception, WebApplicationException {
        if (channelViewTask == null) return null;
        try {
            channelViewTask.run();
            return channelViewTask.get();
        } catch (InterruptedException ie) {
            throw new WWWeeePortal.OperationalException(ie);
        } catch (ExecutionException ee) {
            final Throwable cause = ee.getCause();
            if (cause instanceof WebApplicationException) {
                throw (WebApplicationException) cause;
            } else if (cause instanceof WWWeeePortal.Exception) {
                throw (WWWeeePortal.Exception) cause;
            }
            throw new WWWeeePortal.SoftwareException(cause);
        }
    }

    /**
   * Look through the supplied list of <code>channelViewTasks</code> for the one with the specified
   * <code>channelKey</code> and {@linkplain #getChannelViewResponse(FutureTask) get} it's response.
   * 
   * @return The response for the specified <code>channelKey</code>, or <code>null</code> if not found.
   */
    public static final Channel.ViewResponse getChannelViewResponse(final List<Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>>> channelViewTasks, final ContentManager.ChannelSpecification.Key channelKey) throws WWWeeePortal.Exception, WebApplicationException {
        if (channelKey == null) return null;
        for (Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>> channelViewTask : channelViewTasks) {
            if (channelKey.equals(channelViewTask.getKey().getKey())) {
                return getChannelViewResponse(channelViewTask.getValue());
            }
        }
        return null;
    }

    /**
   * Create the <code>&lt;html&gt;&lt;head&gt;&lt;title&gt;</code> element for the <code>Page</code>.
   * 
   * @see WWWeeePortal#getName(SecurityContext, HttpHeaders)
   * @see #getGroupTitleText(Request)
   * @see #getTitleText(Request)
   * @see Channel.ViewResponse#getTitle()
   */
    protected Element createHeadTitleElement(final Request request, final Element headElement) throws ConfigManager.ConfigException {
        final Element titleElement = DOMUtil.createElement(HTMLUtil.HTML_NS_URI, HTMLUtil.HTML_NS_PREFIX, "title", headElement);
        final StringBuffer titleText = new StringBuffer();
        titleText.append(portal.getName(request.getSecurityContext(), request.getHttpHeaders()));
        if (!isGroupTitleDisabled(request)) {
            titleText.append(" - ");
            titleText.append(getGroupTitleText(request));
        }
        titleText.append(" - ");
        titleText.append(getTitleText(request));
        if (request.getMaximizedChannelKey() != null) {
            titleText.append(" - ");
            try {
                final Channel.ViewResponse channelViewResponse = getChannelViewResponse(request.getChannelViewTasks(), request.getMaximizedChannelKey());
                titleText.append(channelViewResponse.getTitle());
            } catch (WWWeeePortal.Exception wpe) {
                titleText.append(request.getPage().getChannel(request.getMaximizedChannelKey()).getTitleText(request));
            }
        }
        DOMUtil.appendText(titleElement, titleText.toString());
        return titleElement;
    }

    /**
   * Create the <code>&lt;html&gt;&lt;head&gt;</code> meta elements for the <code>Page</code>.
   * 
   * @see #getMetaLinkElements(Request)
   * @see #getMetaScriptElements(Request)
   * @see #getMetaMetaElements(Request)
   * @see Channel.ViewResponse#getMetaElements()
   * @see #META_PROP_PUBLISH_ALL_ENABLE_PROP
   * @see #META_PROP_PUBLISH_BY_NUM_PROP
   */
    protected void createHeadMetaElements(final Request request, final Element headElement, final Map<String, Object> publishMetaProps) throws WWWeeePortal.Exception {
        for (Element metaLinkElement : getMetaLinkElements(request)) {
            DOMUtil.appendChild(headElement, MarkupManager.resolveMetaLinkElementContextResources(metaLinkElement, request.getUriInfo()));
        }
        for (Element metaScriptElement : getMetaScriptElements(request)) {
            DOMUtil.appendChild(headElement, MarkupManager.resolveMetaScriptElementContextResources(metaScriptElement, request.getUriInfo()));
        }
        for (Element metaMetaElement : getMetaMetaElements(request)) {
            DOMUtil.appendChild(headElement, MarkupManager.resolveMetaMetaElementContextResources(metaMetaElement, request.getUriInfo()));
        }
        for (Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>> channelViewTask : request.getChannelViewTasks()) {
            final Channel.ViewResponse channelViewResponse = getChannelViewResponse(channelViewTask.getValue());
            for (Element metaElement : CollectionUtil.mkNotNull(channelViewResponse.getMetaElements())) {
                DOMUtil.appendChild(headElement, metaElement);
            }
        }
        if (publishMetaProps != null) {
            for (String key : publishMetaProps.keySet()) {
                final Object value = publishMetaProps.get(key);
                final Element metaElement = DOMUtil.createElement(HTMLUtil.HTML_NS_URI, null, "meta", headElement);
                metaElement.setAttributeNS(null, "name", key);
                if (value != null) metaElement.setAttributeNS(null, "content", value.toString());
                metaElement.setAttributeNS(null, "scheme", "wwweee_internal");
            }
        }
        return;
    }

    /**
   * Create the <code>&lt;html&gt;&lt;head&gt;</code> element for the <code>Page</code>.
   * 
   * @see #createHeadTitleElement(Request, Element)
   * @see #createHeadMetaElements(Request, Element, Map)
   * @see #META_PROP_PUBLISH_ALL_ENABLE_PROP
   * @see #META_PROP_PUBLISH_BY_NUM_PROP
   */
    protected Element createHeadElement(final Request request, final TransformableDocument responseDocument, final Map<String, Object> publishMetaProps) throws WWWeeePortal.Exception {
        final Element htmlElement = responseDocument.getDocument().getDocumentElement();
        final Element headElement = DOMUtil.createElement(HTMLUtil.HTML_NS_URI, HTMLUtil.HTML_NS_PREFIX, "head", htmlElement, DOMUtil.getDocument(htmlElement), true, false);
        htmlElement.insertBefore(headElement, htmlElement.getFirstChild());
        createHeadTitleElement(request, headElement);
        createHeadMetaElements(request, headElement, publishMetaProps);
        return headElement;
    }

    /**
   * Set the <code>id</code> and <code>class</code> attributes on the <code>&lt;html&gt;&lt;body&gt;</code> element for
   * the <code>Page</code>.
   */
    protected final void setBodyIDAndClassAttrs(final Element bodyElement, final Request request) throws WWWeeePortal.Exception {
        final String portalID = portal.getPortalID();
        final ArrayList<String> idComponents = new ArrayList<String>();
        idComponents.add(portalID);
        idComponents.add("page");
        idComponents.add(definition.getKey().getOwnerID());
        idComponents.add(definition.getKey().getPageGroupID());
        idComponents.add(definition.getKey().getPageID());
        if (request.getMaximizedChannelKey() != null) idComponents.add(request.getMaximizedChannelKey().getChannelID());
        final String idValue = ConversionUtil.invokeConverter(MarkupManager.MARKUP_ENCODE_CONVERTER, idComponents);
        DOMUtil.createAttribute(null, null, "id", idValue, bodyElement);
        final StringBuffer classBuffer = new StringBuffer();
        classBuffer.append(ConversionUtil.invokeConverter(MarkupManager.MARKUP_ENCODE_CONVERTER, Arrays.asList(portalID, "page")));
        classBuffer.append(' ');
        classBuffer.append(ConversionUtil.invokeConverter(MarkupManager.MARKUP_ENCODE_CONVERTER, Arrays.asList(portalID, "page", "owner", definition.getKey().getOwnerID())));
        classBuffer.append(' ');
        classBuffer.append(ConversionUtil.invokeConverter(MarkupManager.MARKUP_ENCODE_CONVERTER, Arrays.asList(portalID, "page", "group", definition.getKey().getPageGroupID())));
        classBuffer.append(' ');
        classBuffer.append(ConversionUtil.invokeConverter(MarkupManager.MARKUP_ENCODE_CONVERTER, Arrays.asList(portalID, "page", definition.getKey().getOwnerID(), definition.getKey().getPageGroupID(), definition.getKey().getPageID())));
        if (request.getMaximizedChannelKey() != null) {
            classBuffer.append(' ');
            classBuffer.append(ConversionUtil.invokeConverter(MarkupManager.MARKUP_ENCODE_CONVERTER, Arrays.asList(portalID, "page", "maximized")));
        }
        for (String classAttr : ConfigManager.getConfigProps(definition.getProperties(), CLASS_BY_NUM_PATTERN, request.getSecurityContext(), request.getHttpHeaders(), RSProperties.RESULT_STRING_CONVERTER, false, false).values()) {
            classBuffer.append(' ');
            classBuffer.append(classAttr);
        }
        DOMUtil.createAttribute(null, null, "class", classBuffer.toString(), bodyElement);
        return;
    }

    /**
   * Create the {@link TransformableDocument} for containing the content which will result from
   * {@linkplain #doViewRequest(Request, UriInfo, SecurityContext, HttpHeaders, Map, Map, DataSource, ContentManager.ChannelSpecification.Key)
   * viewing} this <code>Page</code>.
   */
    protected TransformableDocument createResponseDocument(final Request request) throws WWWeeePortal.Exception {
        final TransformableDocument responseDocument = new TransformableDocument(this);
        responseDocument.setIncremental(true);
        final Element htmlElement = DOMUtil.createElement(HTMLUtil.HTML_NS_URI, null, "html", responseDocument.getDocument());
        final Element bodyElement = DOMUtil.createElement(HTMLUtil.HTML_NS_URI, HTMLUtil.HTML_NS_PREFIX, "body", htmlElement);
        setBodyIDAndClassAttrs(bodyElement, request);
        responseDocument.setMediaType(HTMLUtil.APPLICATION_XHTML_XML_MIME_TYPE);
        responseDocument.setSystemID(HTMLUtil.HTML_SYSTEM_ID);
        responseDocument.setEncoding(getConfigProp(ENCODING_PROP, request, RSProperties.RESULT_CHARSET_CONVERTER, DEFAULT_ENCODING, true, false));
        responseDocument.setIndent(true);
        return responseDocument;
    }

    /**
   * Generate an {@link EntityTag} for some content.
   * 
   * @param request The {@link Request} driving the response which will contain this ETag.
   * @param responseCacheControl The {@link CacheControl} header for the response, or <code>null</code> if not known.
   * @param responseContentSignature Some arbitrary length text string which can be used as input to create a unique
   * {@linkplain MessageDigest hash} for the content, or <code>null</code> if not available.
   * @param responseContentLength The number of bytes in the content, or <code>null</code> if not known.
   * @param responseLastModified The date the content was last modified, or <code>null</code> if not known.
   * @param forceWeak Force creation of a {@linkplain EntityTag#isWeak() weak} ETag.
   * @return An {@link EntityTag} value, or <code>null</code> if not enough arguments were supplied to generate one.
   * @throws NullPointerException If the <code>request</code> was <code>null</code>.
   */
    public static final EntityTag createEntityTag(final Request request, final CacheControl responseCacheControl, final CharSequence responseContentSignature, final Long responseContentLength, final Date responseLastModified, final boolean forceWeak) throws NullPointerException {
        if (!(((responseContentSignature != null) && (responseContentSignature.length() > 0)) || (responseContentLength != null) || (responseLastModified != null))) return null;
        final MD5DigestOutputStream md5dos = new MD5DigestOutputStream();
        final PrintStream md5ps = new PrintStream(md5dos);
        if ((responseCacheControl != null) && (responseCacheControl.isPrivate())) {
            if (request.getSecurityContext().getUserPrincipal() != null) {
                md5ps.append(request.getSecurityContext().getUserPrincipal().getName());
            } else {
                md5ps.append("private");
            }
        } else {
            md5ps.append("public");
        }
        md5ps.append(':');
        if (request.getHttpHeaders().getAcceptableLanguages() != null) {
            md5ps.append(CollectionUtil.toString(request.getHttpHeaders().getAcceptableLanguages(), null, null, ","));
        }
        md5ps.append(':');
        if ((responseContentSignature != null) && (responseContentSignature.length() > 0)) md5ps.append(responseContentSignature);
        md5ps.append(':');
        if (responseContentLength != null) md5ps.append(String.valueOf(responseContentLength));
        md5ps.append(':');
        if (responseLastModified != null) md5ps.append(String.valueOf(responseLastModified.getTime()));
        return new EntityTag(md5dos.getDigestHexString(), ((forceWeak) || (responseContentSignature == null) || (responseContentSignature.length() <= 0)));
    }

    /**
   * Perform any final post-channel-rendering modifications on the <code>responseDocument</code> resulting from a
   * request to
   * {@linkplain #doViewRequest(Request, UriInfo, SecurityContext, HttpHeaders, Map, Map, DataSource, ContentManager.ChannelSpecification.Key)
   * view} this <code>Page</code> (such as filling in the
   * {@linkplain #createHeadElement(Request, TransformableDocument, Map) header},
   * {@linkplain #getTransformations(Request) transformations}, etc).
   * 
   * @see #getTransformations(Request)
   * @see #META_PROP_PUBLISH_ALL_ENABLE_PROP
   * @see #META_PROP_PUBLISH_BY_NUM_PROP
   * @see #createHeadElement(Request, TransformableDocument, Map)
   */
    protected void finalizeResponseDocument(final Request request, final TransformableDocument responseDocument) throws WWWeeePortal.Exception {
        final Collection<Map.Entry<URL, Templates>> transformations = getTransformations(request);
        Map<String, Object> publishMetaProps = null;
        Map<String, Object> transformationParameters = null;
        final boolean isMetaPropPublishAllEnabled = getConfigProp(META_PROP_PUBLISH_ALL_ENABLE_PROP, request, RSProperties.RESULT_BOOLEAN_CONVERTER, Boolean.FALSE, false, false).booleanValue();
        final SortedMap<String, String> metaPropsPublishedByNum = (!isMetaPropPublishAllEnabled) ? ConfigManager.getConfigProps(definition.getProperties(), META_PROP_PUBLISH_BY_NUM_PATTERN, request.getSecurityContext(), request.getHttpHeaders(), RSProperties.RESULT_STRING_CONVERTER, true, true) : null;
        if ((isMetaPropPublishAllEnabled) || (!metaPropsPublishedByNum.isEmpty()) || (!transformations.isEmpty())) {
            final Map<String, Object> metaProps = new HashMap<String, Object>();
            request.getMetaProps(metaProps);
            portal.getMetaProps(metaProps, request.getSecurityContext(), request.getHttpHeaders());
            getMetaProps(request, metaProps);
            transformationParameters = metaProps;
            if (isMetaPropPublishAllEnabled) {
                publishMetaProps = metaProps;
            } else {
                publishMetaProps = new HashMap<String, Object>();
                for (String publishMetaProp : metaPropsPublishedByNum.values()) {
                    final Object value = metaProps.get(publishMetaProp);
                    if (value != null) publishMetaProps.put(publishMetaProp, value);
                }
            }
        }
        createHeadElement(request, responseDocument, publishMetaProps);
        if (!transformations.isEmpty()) {
            responseDocument.setTransformations(transformations);
            responseDocument.setTransformationParameters(transformationParameters);
        }
        return;
    }

    /**
   * Take the final <code>responseDocument</code> resulting from a request to
   * {@linkplain #doViewRequest(Request, UriInfo, SecurityContext, HttpHeaders, Map, Map, DataSource, ContentManager.ChannelSpecification.Key)
   * view} this <code>Page</code>, using it to {@linkplain RESTUtil#evaluatePreconditions(Request, Date, EntityTag)
   * evaluate any preconditions} and {@linkplain javax.ws.rs.core.Response.ResponseBuilder build} a {@link Response}.
   */
    protected Response buildResponse(final Request request, final TransformableDocument responseDocument) throws WWWeeePortal.Exception {
        Date lastModified = null;
        Date expires = null;
        CacheControl cacheControl = ConversionUtil.invokeConverter(RESTUtil.CACHE_CONTROL_DEFAULT_CONVERTER, getCacheControlDefault(request));
        int maxAge = cacheControl.getMaxAge();
        int sMaxAge = cacheControl.getSMaxAge();
        boolean weakETag = false;
        final MD5DigestOutputStream md5dos = new MD5DigestOutputStream();
        final PrintStream md5ps = new PrintStream(md5dos);
        for (ContentManager.ChannelGroupDefinition channelGroup : CollectionUtil.mkNotNull(definition.getMatchingChildDefinitions(null, null, null, true, request.getSecurityContext(), request.getHttpHeaders(), -1, false, true))) {
            if (channelGroup == null) continue;
            md5ps.append(channelGroup.getID());
            md5ps.append('{');
            for (ContentManager.ChannelSpecification<?> channelSpecification : CollectionUtil.mkNotNull(channelGroup.getMatchingChildDefinitions(null, null, null, true, request.getSecurityContext(), request.getHttpHeaders(), -1, false, true))) {
                if (channelSpecification == null) continue;
                final Channel.ViewResponse channelViewResponse = getChannelViewResponse(request.getChannelViewTasks(), channelSpecification.getKey());
                if (channelViewResponse == null) continue;
                md5ps.append(channelSpecification.getID());
                md5ps.append('{');
                final Date channelLastModified = channelViewResponse.getLastModified();
                if (channelLastModified != null) {
                    if (lastModified == null) {
                        lastModified = channelLastModified;
                    } else if (channelLastModified.after(lastModified)) {
                        lastModified = channelLastModified;
                    }
                }
                final Date channelExpires = channelViewResponse.getExpires();
                if (channelExpires != null) {
                    if (expires == null) {
                        expires = channelExpires;
                    } else if (channelExpires.before(expires)) {
                        expires = channelExpires;
                    }
                }
                final CacheControl channelCacheControl = channelViewResponse.getCacheControl();
                if (channelCacheControl != null) {
                    if (channelCacheControl.isPrivate()) {
                        cacheControl.setPrivate(true);
                        cacheControl.getCacheExtension().remove("public");
                    }
                    if (channelCacheControl.isNoCache()) cacheControl.setNoCache(true);
                    if (channelCacheControl.isNoStore()) cacheControl.setNoStore(true);
                    if (channelCacheControl.isNoTransform()) cacheControl.setNoTransform(true);
                    if (channelCacheControl.isMustRevalidate()) cacheControl.setMustRevalidate(true);
                    if (channelCacheControl.isProxyRevalidate()) cacheControl.setProxyRevalidate(true);
                    final int channelMaxAge = channelCacheControl.getMaxAge();
                    if (channelMaxAge >= 0) {
                        if (maxAge < 0) {
                            maxAge = channelMaxAge;
                        } else if (channelMaxAge < maxAge) {
                            maxAge = channelMaxAge;
                        }
                    }
                    final int channelSMaxAge = channelCacheControl.getSMaxAge();
                    if (channelSMaxAge >= 0) {
                        if (sMaxAge < 0) {
                            sMaxAge = channelSMaxAge;
                        } else if (channelSMaxAge < sMaxAge) {
                            sMaxAge = channelSMaxAge;
                        }
                    }
                }
                final EntityTag channelEntityTag = channelViewResponse.getEntityTag();
                if (channelEntityTag != null) {
                    if (channelEntityTag.isWeak()) weakETag = true;
                    md5ps.append(channelEntityTag.getValue());
                } else {
                    weakETag = true;
                }
                md5ps.append('}');
            }
            md5ps.append('}');
        }
        cacheControl.setMaxAge(maxAge);
        cacheControl.setSMaxAge(sMaxAge);
        cacheControl = ConversionUtil.invokeConverter(RESTUtil.CACHE_CONTROL_NULL_CONVERTER, cacheControl);
        final EntityTag entityTag = createEntityTag(request, cacheControl, md5dos.getDigestHexString(), null, lastModified, weakETag);
        Response.ResponseBuilder responseBuilder = RESTUtil.evaluatePreconditions(request.getRSRequest(), lastModified, entityTag);
        if (responseBuilder != null) return responseBuilder.build();
        responseBuilder = Response.ok();
        responseBuilder.lastModified(lastModified);
        responseBuilder.expires(expires);
        responseBuilder.tag(entityTag);
        responseBuilder.cacheControl(cacheControl);
        responseBuilder.entity(responseDocument);
        return responseBuilder.build();
    }

    /**
   * <p>
   * Perform a request to view this <code>Page</code> instance.
   * </p>
   * 
   * <p>
   * Most functionality within this class is to support the implementation of this method. This method will obtain a
   * {@linkplain #activeRequestLock request lock}, check {@linkplain Request#checkAccess() access-control},
   * {@linkplain #createResponseDocument(Request) create} the response container document, identify the
   * {@linkplain #getChannels() channels} to be displayed, {@linkplain Channel#doViewRequest(Page.Request, Node)
   * execute} each {@link Channel}, aggregate and {@linkplain #finalizeResponseDocument(Request, TransformableDocument)
   * finalize} the <code>Page</code> content, and finally {@linkplain #buildResponse(Request, TransformableDocument)
   * build} a response for the client.
   * </p>
   * 
   * @see Channel#doViewRequest(Page.Request, Node)
   */
    final Response doViewRequest(final javax.ws.rs.core.Request rsRequest, final UriInfo uriInfo, final SecurityContext securityContext, final HttpHeaders httpHeaders, final Map<String, Object> requestAttributes, final Map<String, Object> sessionAttributes, final DataSource entity, final ContentManager.ChannelSpecification.Key maximizedChannelKey) throws WWWeeePortal.Exception, WebApplicationException {
        activeRequestLock.readLock().lock();
        try {
            if (!initialized) throw new IllegalStateException("Attempt to have uninitialized Page handle a request");
            final List<Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>>> channelViewTasks = new ArrayList<Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>>>(CollectionUtil.size(channels));
            final Request request = new Request(new ConcurrentRequestWrapper(rsRequest), new ConcurrentUriInfoWrapper(uriInfo), new ConcurrentSecurityContextWrapper(securityContext), new ConcurrentHttpHeadersWrapper(httpHeaders), requestAttributes, sessionAttributes, entity, this, maximizedChannelKey, channelViewTasks);
            final Response noAccessResponse = request.checkAccess();
            if (noAccessResponse != null) {
                return noAccessResponse;
            }
            final TransformableDocument responseDocument = createResponseDocument(request);
            final Channel maximizedChannel = getChannel(maximizedChannelKey);
            final ContentManager.ChannelSpecification<?> maximizedChannelSpecification = definition.getChannelSpecification(maximizedChannelKey);
            final ContentManager.ChannelGroupDefinition maximizedChannelGroup = (maximizedChannelSpecification != null) ? maximizedChannelSpecification.getParentDefinition() : null;
            final int priorityNeededToView = (maximizedChannel != null) ? maximizedChannel.getMaximizationMaximizedPriority(request) : 0;
            for (ContentManager.ChannelGroupDefinition channelGroup : CollectionUtil.mkNotNull(definition.getMatchingChildDefinitions(null, null, null, true, securityContext, httpHeaders, -1, false, true))) {
                if (channelGroup == null) continue;
                final Element channelGroupElement = DOMUtil.createElement(HTMLUtil.HTML_NS_URI, HTMLUtil.HTML_NS_PREFIX, "div", DOMUtil.getChildElement(responseDocument.getDocument().getDocumentElement(), HTMLUtil.HTML_NS_URI, "body"));
                DOMUtil.createAttribute(null, null, "id", ConversionUtil.invokeConverter(MarkupManager.MARKUP_ENCODE_CONVERTER, Arrays.asList(portal.getPortalID(), "page", "group", channelGroup.getID())), channelGroupElement);
                final StringBuffer channelGroupClassBuffer = new StringBuffer();
                channelGroupClassBuffer.append(ConversionUtil.invokeConverter(MarkupManager.MARKUP_ENCODE_CONVERTER, Arrays.asList(portal.getPortalID(), "page", "group")));
                if (channelGroup.equals(maximizedChannelGroup)) {
                    channelGroupClassBuffer.append(' ');
                    channelGroupClassBuffer.append(ConversionUtil.invokeConverter(MarkupManager.MARKUP_ENCODE_CONVERTER, Arrays.asList(portal.getPortalID(), "page", "group", "maximized")));
                }
                for (String classAttr : ConfigManager.getConfigProps(channelGroup.getProperties(), CHANNEL_GROUP_CLASS_BY_NUM_PATTERN, request.getSecurityContext(), request.getHttpHeaders(), RSProperties.RESULT_STRING_CONVERTER, false, false).values()) {
                    channelGroupClassBuffer.append(' ');
                    channelGroupClassBuffer.append(classAttr);
                }
                DOMUtil.createAttribute(null, null, "class", channelGroupClassBuffer.toString(), channelGroupElement);
                for (ContentManager.ChannelSpecification<?> channelSpecification : CollectionUtil.mkNotNull(channelGroup.getMatchingChildDefinitions(null, null, null, true, securityContext, httpHeaders, -1, false, true))) {
                    if (channelSpecification == null) continue;
                    final Channel channel = getChannel(channelSpecification.getID());
                    if (channel == null) continue;
                    if ((maximizedChannelKey != null) && (!maximizedChannelKey.equals(channelSpecification.getKey()))) {
                        final int channelPriority = channel.getMaximizationNormalPriority(request);
                        if (channelPriority < priorityNeededToView) {
                            continue;
                        }
                    }
                    final RSAccessControl channelAC = channel.getDefinition().getAccessControl();
                    if ((channelAC != null) && (!channelAC.hasAccess(securityContext))) {
                        continue;
                    }
                    final FutureTask<Channel.ViewResponse> channelViewTask = new FutureTaskGC<Channel.ViewResponse>(new Callable<Channel.ViewResponse>() {

                        @Override
                        public Channel.ViewResponse call() throws Exception {
                            return channel.doViewRequest(request, channelGroupElement);
                        }
                    });
                    channelViewTasks.add(new AbstractMap.SimpleImmutableEntry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>>(channelSpecification, channelViewTask));
                }
            }
            final ExecutorService executorService = portal.getExecutorService();
            if (executorService != null) {
                for (Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>> channelViewTask : channelViewTasks) {
                    executorService.submit(channelViewTask.getValue());
                }
            }
            try {
                for (Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>> channelViewTask : channelViewTasks) {
                    final Channel.ViewResponse channelViewResponse = getChannelViewResponse(channelViewTask.getValue());
                    final Node channelResponseContainerNode = channelViewResponse.getResponseContainerNode();
                    final Element channelResponseRootElement = channelViewResponse.getResponseRootElement();
                    channelResponseContainerNode.appendChild(channelResponseRootElement);
                }
            } catch (Exception e) {
                for (Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>> channelViewTask : channelViewTasks) {
                    channelViewTask.getValue().cancel(true);
                }
                throw e;
            }
            finalizeResponseDocument(request, responseDocument);
            return buildResponse(request, responseDocument);
        } catch (WebApplicationException wae) {
            throw wae;
        } catch (WWWeeePortal.Exception wpe) {
            throw LogAnnotation.log(getLogger(), LogAnnotation.annotate(LogAnnotation.annotate(LogAnnotation.annotate(wpe, "SecurityContext", securityContext, null, false), "UriInfo", uriInfo, null, false), "Page", this, null, false), getClass(), wpe);
        } catch (Exception e) {
            throw LogAnnotation.log(getLogger(), LogAnnotation.annotate(LogAnnotation.annotate(LogAnnotation.annotate(new WWWeeePortal.SoftwareException(e), "SecurityContext", securityContext, null, false), "UriInfo", uriInfo, null, false), "Page", this, null, false), getClass(), e);
        } finally {
            activeRequestLock.readLock().unlock();
        }
    }

    /**
   * Perform a {@link GET} request to view this <code>Page</code> instance.
   * 
   * @see #doViewRequest(Request, UriInfo, SecurityContext, HttpHeaders, Map, Map, DataSource,
   * ContentManager.ChannelSpecification.Key)
   */
    @GET
    @Produces("application/xhtml+xml,*/*")
    public final Response doViewGetRequest(@Context final javax.ws.rs.core.Request rsRequest, @Context final UriInfo uriInfo, @Context final SecurityContext securityContext, @Context final HttpHeaders httpHeaders, @RequestAttributes final Map<String, Object> requestAttributes, @SessionAttributes final Map<String, Object> sessionAttributes) throws WWWeeePortal.Exception, WebApplicationException {
        return doViewRequest(rsRequest, uriInfo, securityContext, httpHeaders, requestAttributes, sessionAttributes, null, null);
    }

    @Override
    public final boolean equals(final Object object) {
        if (object == null) return false;
        if (object == this) return true;
        if (!(object instanceof Page)) return false;
        return definition.equals(((Page) object).getDefinition());
    }

    @Override
    public final int hashCode() {
        return definition.hashCode();
    }

    @Override
    public final String toString() {
        final StringBuffer sb = new StringBuffer();
        sb.append(getClass().getSimpleName());
        sb.append('@');
        sb.append(Integer.toHexString(System.identityHashCode(this)).toUpperCase());
        sb.append('(');
        sb.append(definition);
        sb.append(')');
        return sb.toString();
    }

    /**
   * <p>
   * Encapsulates the info set representing a client request to a {@link Page}.
   * </p>
   */
    public final class Request {

        /**
     * @see #getRSRequest()
     */
        protected final javax.ws.rs.core.Request rsRequest;

        /**
     * @see #getUriInfo()
     */
        protected final UriInfo uriInfo;

        /**
     * @see #getSecurityContext()
     */
        protected final SecurityContext securityContext;

        /**
     * @see #getHttpHeaders()
     */
        protected final HttpHeaders httpHeaders;

        /**
     * @see #getAttributes()
     */
        protected final Map<String, Object> attributes;

        /**
     * @see #getSessionAttributes()
     */
        protected final Map<String, Object> sessionAttributes;

        /**
     * @see #getEntity()
     */
        protected final DataSource entity;

        /**
     * @see #getPage()
     */
        protected final Page page;

        /**
     * @see #getMaximizedChannelKey()
     */
        protected final ContentManager.ChannelSpecification.Key maximizedChannelKey;

        /**
     * @see #getChannelViewTasks()
     */
        protected final List<Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>>> channelViewTasks;

        /**
     * @see #getBaseURL()
     */
        protected final URL baseURL;

        /**
     * @see #getChannelLocalPath(Channel)
     */
        protected final URI channelLocalPath;

        /**
     * Construct a new <code>Page.Request</code> instance.
     */
        public Request(final javax.ws.rs.core.Request rsRequest, final UriInfo uriInfo, final SecurityContext securityContext, final HttpHeaders httpHeaders, final Map<String, Object> attributes, final Map<String, Object> sessionAttributes, final DataSource entity, final Page page, final ContentManager.ChannelSpecification.Key maximizedChannelKey, final List<Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>>> channelViewTasks) throws WWWeeePortal.Exception, WebApplicationException {
            this.rsRequest = rsRequest;
            this.uriInfo = uriInfo;
            this.securityContext = securityContext;
            this.httpHeaders = httpHeaders;
            this.attributes = attributes;
            this.sessionAttributes = sessionAttributes;
            this.entity = entity;
            this.page = page;
            this.maximizedChannelKey = maximizedChannelKey;
            this.channelViewTasks = channelViewTasks;
            try {
                baseURL = uriInfo.getBaseUri().toURL();
                final String requestPath = new URI(uriInfo.getPath(false)).getPath();
                final List<PathSegment> requestPathSegments = uriInfo.getPathSegments();
                if (requestPathSegments.size() > 5) {
                    final int channelPathLength = requestPathSegments.get(0).getPath().length() + requestPathSegments.get(1).getPath().length() + requestPathSegments.get(2).getPath().length() + requestPathSegments.get(3).getPath().length() + requestPathSegments.get(4).getPath().length() + 5;
                    final int requestPathLength = requestPath.length();
                    if (requestPathLength > channelPathLength) {
                        channelLocalPath = new URI(requestPath.substring(channelPathLength));
                    } else {
                        channelLocalPath = null;
                    }
                } else {
                    channelLocalPath = null;
                }
            } catch (MalformedURLException mue) {
                throw new WebApplicationException(Response.Status.BAD_REQUEST);
            } catch (URISyntaxException urise) {
                throw new WebApplicationException(Response.Status.BAD_REQUEST);
            }
            return;
        }

        /**
     * Get the {@link Page} instance associated with this <code>Page.Request</code>.
     */
        public Page getPage() {
            return Page.this;
        }

        /**
     * Get the client {@link javax.ws.rs.core.Request Request} instance making with this <code>Page.Request</code>.
     */
        public javax.ws.rs.core.Request getRSRequest() {
            return rsRequest;
        }

        /**
     * Get the {@link UriInfo} for the client making with this <code>Page.Request</code>.
     */
        public UriInfo getUriInfo() {
            return uriInfo;
        }

        /**
     * Get the {@link SecurityContext} for the client making with this <code>Page.Request</code>.
     */
        public SecurityContext getSecurityContext() {
            return securityContext;
        }

        /**
     * Get the {@link HttpHeaders} for the client making with this <code>Page.Request</code>.
     */
        public HttpHeaders getHttpHeaders() {
            return httpHeaders;
        }

        /**
     * Get the {@link RequestAttributes} for the client making with this <code>Page.Request</code>.
     */
        public Map<String, Object> getAttributes() {
            return attributes;
        }

        /**
     * Get the {@link SessionAttributes} for the client making with this <code>Page.Request</code>.
     */
        public Map<String, Object> getSessionAttributes() {
            return sessionAttributes;
        }

        /**
     * Get the request entity data.
     */
        public DataSource getEntity() {
            return entity;
        }

        /**
     * Get the {@linkplain ContentManager.ChannelSpecification.Key key} for the {@link Channel} which was
     * {@linkplain Page#getChannel(String) targeted} by this <code>Page.Request</code>.
     * 
     * @return The key, or <code>null</code> if the {@link Page} itself was targeted, and not any specific
     * {@link Channel}.
     */
        public ContentManager.ChannelSpecification.Key getMaximizedChannelKey() {
            return maximizedChannelKey;
        }

        /**
     * Get the {@link FutureTask} objects to be used for rendering each {@link Channel} {@linkplain Channel#VIEW_MODE
     * view}, mapped to the {@linkplain ContentManager.ChannelSpecification specification} for the {@link Channel}
     * behind it.
     * 
     * @return The rendering objects, or <code>null</code> if this is a {@linkplain Channel#RESOURCE_MODE resource}
     * request.
     */
        public List<Map.Entry<ContentManager.ChannelSpecification<?>, FutureTask<Channel.ViewResponse>>> getChannelViewTasks() {
            return channelViewTasks;
        }

        /**
     * Get the {@linkplain UriInfo#getBaseUri() base} {@link URL} of the {@link Application}.
     * 
     * @see UriInfo#getBaseUri()
     */
        public URL getBaseURL() {
            return baseURL;
        }

        /**
     * Get the {@linkplain ContentManager.ChannelSpecification specification} for the specified {@link Channel} from the
     * <code>Page</code> {@linkplain Page#getDefinition() definition} for this <code>Page.Request</code>.
     */
        public ContentManager.ChannelSpecification<?> getChannelSpecification(final Channel channel) {
            return (channel != null) ? definition.getChannelSpecification(channel.getDefinition().getID()) : null;
        }

        /**
     * Does this <code>Page.Request</code> {@linkplain #getMaximizedChannelKey() target} the specified {@link Channel}?
     */
        public boolean isMaximized(final Channel channel) {
            return (maximizedChannelKey != null) && (maximizedChannelKey.equals(ContentManager.ChannelSpecification.getKey(getChannelSpecification(channel))));
        }

        /**
     * <p>
     * Get the component of the request {@linkplain UriInfo#getPath(boolean) path} beyond the portion
     * {@linkplain ContentManager.ChannelSpecification.Key identifying} the {@linkplain Page#getChannel(String)
     * requested} {@link Channel}.
     * </p>
     * 
     * <p>
     * Since a request is obviously made to a single path, and can thus only target one {@link Channel} (if any) in that
     * path, this value can <em>only</em> then exist under a <em>{@linkplain #isMaximized(Channel) maximized}</em>
     * {@link Channel}. If the request is to
     * {@linkplain Page#doViewGetRequest(Request, UriInfo, SecurityContext, HttpHeaders, Map, Map) view} the
     * <code>Page</code> itself, with no {@link Channel} specific targeted/maximized {@link Channel}, then there will be
     * <em>no</em> {@link Channel} with a local path. A request to a specific/maximized {@link Channel}
     * <em>may or may not</em> contain a local path, as the request might just be to the default {@link Channel}
     * document, in which case no path is required. Any request for a {@link Channel} document <em>other</em> than the
     * default <em>must</em> have a local path to specify said document. Generally, every request for a
     * {@linkplain Channel#RESOURCE_MODE resource} <em>will</em> include a local path, though that is <em>not</em>
     * strictly required, as a {@link Channel} implementation is free to provide a default resource.
     * </p>
     * 
     * @param channel The {@link Channel} for which the local path is desired, or <code>null</code> if the path for
     * whatever <code>Channel</code> happens to be {@linkplain #isMaximized(Channel) maximized} is desired.
     * @return The component of the request {@linkplain UriInfo#getPath(boolean) path} which is local to the
     * {@link Channel}, as a <em>relative</em> {@link URI} ({@linkplain UriInfo#getQueryParameters(boolean)
     * query-parameters} are <em>not</em> included, {@linkplain #getUriInfo() get} the {@link UriInfo} for those), or
     * <code>null</code> if the specified <code>channel</code> either wasn't {@linkplain #isMaximized(Channel)
     * maximized}, or if there was no local path provided within the maximized <code>channel</code>.
     */
        public URI getChannelLocalPath(final Channel channel) {
            if (channel == null) return channelLocalPath;
            return isMaximized(channel) ? channelLocalPath : null;
        }

        /**
     * @see #UNAUTHORIZED_WWW_AUTHENTICATE_PROP
     */
        public Response createNoAccessResponse(final RSProperties properties) throws ConfigManager.ConfigException {
            if (securityContext.getUserPrincipal() == null) {
                return Response.status(Response.Status.UNAUTHORIZED).header("WWW-Authenticate", ConfigManager.getConfigProp(properties, UNAUTHORIZED_WWW_AUTHENTICATE_PROP, securityContext, httpHeaders, null, RSProperties.RESULT_STRING_CONVERTER, null, false, true)).build();
            }
            return Response.status(Response.Status.FORBIDDEN).build();
        }

        /**
     * Does the client {@linkplain RSAccessControl#hasAccess(SecurityContext) have access} to the
     * {@linkplain ContentManager.AbstractContentContainer content container},
     * {@link ContentManager.PageGroupDefinition PageGroupDefinition}, {@link ContentManager.PageDefinition
     * PageDefinition}, and {@link ContentManager.ChannelSpecification ChannelSpecification} targeted by this
     * <code>Page.Request</code>?
     * 
     * @return A {@linkplain #createNoAccessResponse(RSProperties) no-access} {@link Response} if permission is denied,
     * else <code>null</code>.
     */
        public Response checkAccess() throws ConfigManager.ConfigException {
            final RSAccessControl contentContainerAC = definition.getContentContainer().getAccessControl();
            if ((contentContainerAC != null) && (!contentContainerAC.hasAccess(securityContext))) {
                return createNoAccessResponse(definition.getContentContainer().getProperties());
            }
            final RSAccessControl pageGroupAC = definition.getParentDefinition().getAccessControl();
            if ((pageGroupAC != null) && (!pageGroupAC.hasAccess(securityContext))) {
                return createNoAccessResponse(definition.getParentDefinition().getProperties());
            }
            final RSAccessControl pageAC = definition.getAccessControl();
            if ((pageAC != null) && (!pageAC.hasAccess(securityContext))) {
                return createNoAccessResponse(definition.getProperties());
            }
            if (maximizedChannelKey != null) {
                final ContentManager.ChannelSpecification<?> maximizedChannelSpec = definition.getChannelSpecification(maximizedChannelKey);
                final RSAccessControl channelGroupAC = maximizedChannelSpec.getParentDefinition().getAccessControl();
                if ((channelGroupAC != null) && (!channelGroupAC.hasAccess(securityContext))) {
                    return createNoAccessResponse(maximizedChannelSpec.getParentDefinition().getProperties());
                }
                final RSAccessControl channelSpecAC = maximizedChannelSpec.getAccessControl();
                if ((channelSpecAC != null) && (!channelSpecAC.hasAccess(securityContext))) {
                    return createNoAccessResponse(maximizedChannelSpec.getProperties());
                }
            }
            return null;
        }

        /**
     * <p>
     * Populate the supplied <code>metaProps</code> Map with the set of meta-information about this request.
     * </p>
     * 
     * <p>
     * The following properties are provided:
     * </p>
     * <dl>
     * <dt><code>WWWeee.Request.Parameter.</code> + key</dt>
     * <dd>The {@linkplain UriInfo#getQueryParameters() query parameters} from the {@linkplain #getUriInfo() URI info}.</dd>
     * <dt><code>WWWeee.Request.Attribute.</code> + key</dt>
     * <dd>The {@linkplain #getAttributes() request attributes}.</dd>
     * <dt><code>WWWeee.Session.Attribute.</code> + key</dt>
     * <dd>The {@linkplain #getSessionAttributes() session attributes}.</dd>
     * <dt><code>WWWeee.Request.Locale.</code> + index</dt>
     * <dd>The {@linkplain I18nUtil#LOCALE_LANGUAGE_TAG_CONVERTER language tag} for a provided
     * {@linkplain HttpHeaders#getAcceptableLanguages() acceptable language}.</dd>
     * <dt><code>WWWeee.Request.Locale.</code> + index + <code>.Language</code></dt>
     * <dd>The {@linkplain Locale#getLanguage() language} value for a provided
     * {@linkplain HttpHeaders#getAcceptableLanguages() acceptable language}.</dd>
     * <dt><code>WWWeee.Request.Locale.</code> + index + <code>.Country</code></dt>
     * <dd>The {@linkplain Locale#getCountry() country} value for a provided
     * {@linkplain HttpHeaders#getAcceptableLanguages() acceptable language}.</dd>
     * <dt><code>WWWeee.Request.Locale.</code> + index + <code>.Variant</code></dt>
     * <dd>The {@linkplain Locale#getVariant() variant} value for a provided
     * {@linkplain HttpHeaders#getAcceptableLanguages() acceptable language}.</dd>
     * <dt><code>WWWeee.Request.RemoteUser</code></dt>
     * <dd>The {@linkplain Principal#getName() name} of the {@linkplain SecurityContext#getUserPrincipal() user
     * principal} behind the request.</dd>
     * <dt><code>WWWeee.Request</code></dt>
     * <dd>The {@link Request} instance.</dd>
     * <dt><code>WWWeee.UriInfo</code></dt>
     * <dd>The {@link UriInfo} instance.</dd>
     * <dt><code>WWWeee.SecurityContext</code></dt>
     * <dd>The {@link SecurityContext} instance.</dd>
     * <dt><code>WWWeee.HttpHeaders</code></dt>
     * <dd>The {@link HttpHeaders} instance.</dd>
     * <dt><code>WWWeee.Request.MaximizedChannel.Key</code></dt>
     * <dd>The {@linkplain #getMaximizedChannelKey() maximized channel key} instance.</dd>
     * <dt><code>WWWeee.Request.MaximizedChannel.ID</code></dt>
     * <dd>The {@linkplain ContentManager.ChannelSpecification.Key#getChannelID() channel identifier} for the
     * {@linkplain #getMaximizedChannelKey() maximized channel}.</dd>
     * </dl>
     * 
     * @see ContentManager.PageDefinition#getMetaProps(Page.Request, Map, SecurityContext, HttpHeaders, int)
     * @see ContentManager.PageGroupDefinition#getMetaProps(Page.Request, Map, SecurityContext, HttpHeaders, int)
     * @see ContentManager.PageContentContainer#getMetaProps(Page.Request, Map, SecurityContext, HttpHeaders, int)
     */
        public Map<String, Object> getMetaProps(final Map<String, Object> metaProps) throws ConfigManager.ConfigException {
            if (metaProps == null) throw new IllegalArgumentException("null metaProps");
            final Map<String, List<String>> requestParams = uriInfo.getQueryParameters();
            if (requestParams != null) {
                for (String requestParamKey : requestParams.keySet()) {
                    final List<String> requestParamValues = requestParams.get(requestParamKey);
                    if (requestParamValues == null) continue;
                    for (int i = 0; i < requestParamValues.size(); i++) {
                        metaProps.put("WWWeee.Request.Parameter." + requestParamKey + ((i > 0) ? '.' + String.valueOf(i + 1) : ""), requestParamValues.get(i));
                    }
                }
            }
            if (attributes != null) {
                for (String key : attributes.keySet()) {
                    final Object value = attributes.get(key);
                    metaProps.put("WWWeee.Request.Attribute." + key, value);
                }
            }
            if (sessionAttributes != null) {
                for (String key : sessionAttributes.keySet()) {
                    final Object value = sessionAttributes.get(key);
                    metaProps.put("WWWeee.Session.Attribute." + key, value);
                }
            }
            int localeIndex = 0;
            for (Locale locale : CollectionUtil.mkNotNull(httpHeaders.getAcceptableLanguages())) {
                metaProps.put("WWWeee.Request.Locale." + String.valueOf(++localeIndex), ConversionUtil.invokeConverter(I18nUtil.LOCALE_LANGUAGE_TAG_CONVERTER, locale));
                if (!locale.getLanguage().isEmpty()) metaProps.put("WWWeee.Request.Locale." + String.valueOf(localeIndex) + ".Language", locale.getLanguage());
                if (!locale.getCountry().isEmpty()) metaProps.put("WWWeee.Request.Locale." + String.valueOf(localeIndex) + ".Country", locale.getCountry());
                if (!locale.getVariant().isEmpty()) metaProps.put("WWWeee.Request.Locale." + String.valueOf(localeIndex) + ".Variant", locale.getVariant());
            }
            final Principal remoteUser = securityContext.getUserPrincipal();
            if (remoteUser != null) metaProps.put("WWWeee.Request.RemoteUser", remoteUser.getName());
            metaProps.put("WWWeee.Request", rsRequest);
            metaProps.put("WWWeee.UriInfo", uriInfo);
            metaProps.put("WWWeee.SecurityContext", securityContext);
            metaProps.put("WWWeee.HttpHeaders", httpHeaders);
            if (maximizedChannelKey != null) {
                metaProps.put("WWWeee.Request.MaximizedChannel.Key", maximizedChannelKey);
                metaProps.put("WWWeee.Request.MaximizedChannel.ID", maximizedChannelKey.getChannelID());
            }
            return metaProps;
        }
    }
}
